## Useful in defining list predicates in LINQ.
# sig contains : ([a]) ~> ((a) {}-> Bool)
# fun contains(l) {
#   switch (l) {
#     case [] -> fun (x) {false}
#     case x::xs -> fun (y) { x == y || contains(xs)(x) }
#   }
# }


sig contains : ([a]) ~> ((a) {}-> Bool)
fun contains(xs) {
  fun containsInner(xs, q) {
    switch(xs) {
      case [] -> q
      case x :: xs ->
        containsInner(xs, fun(y) {
          x == y || q(y)
        })
    }
  }

  containsInner(xs, fun(_) { false })
}


sig uniquify : ([a]) ~> [a]
fun uniquify(xs) {
  fun uniqueCons(x, xs) {
    if (elem(x, xs)) {
      xs
    } else {
      x :: xs
    }
  }

  reverse(fold_left(fun(xs, x) { uniqueCons(x, xs) }, [], xs))
}

fun listEmpty(xs) { empty(xs) }

fun cmpName(name) {
  # Firstly, strip &..; tags
  var cmpName = (name =~ s/&.*;//) : String;
  dropWhile(fun(c) {
      not(('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'))
  }, map(toLower, explode(cmpName)))
}

var alphabet = map(fun(c) { chr(c) }, [65..90]);

# Preconditions:
# 1. List is sorted
# 2. The (a) -> Char function returns an alphabetical character
sig alphabetise : (((a) ~%~> [Char]), ((a) ~%~> b), [a]) ~%~> [(Char, [b])]
fun alphabetise(getString, transform, xs) {
  var (chunks, _) =
    fold_left(fun((chunks, remaining), letter) {
        fun safeCmp(exploded) {
          switch(exploded) {
            case [] -> true # Dirty data -- take it anyway
            case x :: _ ->
              x == toLower(letter)
          }
        }
        var (thisChunk, next) = span(fun(x) { safeCmp(getString(x)) }, remaining);
        ((letter, (map(transform, thisChunk))) :: chunks, next)
    }, ([], xs), alphabet);
  reverse(chunks)
}

