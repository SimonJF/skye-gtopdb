open Reference;
open Mvu;
open MvuHTML;
open MvuAttrs;
open MvuEvents;
open Tables;
open Template;
open RenderMarkup;
open Parser;
open Utility;

typename ExternalRef = (
  refId: String,
  refSpeciesName: String,
  refUrl: String
);

typename Interaction = (
  interactionLigandId: Int,
  interactionLigandName: String,
  interactionType: String,
  interactionAction: String,
  interactionSelective: Bool,
  interactionLabelled: Bool,
  interactionSpeciesId: String
);

fun makeInteraction(id, name, type, action, selectivity, labelled, endogenous, speciesId) {
  (interactionLigandId=id, interactionLigandName=name, interactionType=type, interactionAction=action,
   interactionSelective=(selectivity == "Selective"),
   interactionLabelled=labelled,
   interactionEndogenous=endogenous,
   interactionSpeciesId=speciesId
  )
}

typename Synonym = (synonymName: String, synonymOrder: Int);

var emptyER = (refId="", refSpeciesName="", refUrl="");

typename GeneRef = (geneName: String, geneSpeciesId: Int); # TODO: URL

typename ReceptorSummary = (
   receptorId: Int,
   receptorNomenclature: String,
   receptorSynonyms: [String],
   receptorGenes: [GeneRef],
   receptorEnsemblRefs: [ExternalRef],
   receptorUniprotRefs: [ExternalRef],
   receptorPrincipalTransductions: [String],
   receptorInteractions: [Interaction],
   # Need to sort in-memory, since `orderby` not supported w/ shredding
   receptorDisplayOrder: Int
  );

typename ReceptorBox =
  (receptorSummary: ReceptorSummary, receptorBoxVisible: Bool);

typename ContentBox(a) =
  (boxName: String,  boxVisible: Bool, contents: a);

# BUG (hacky workaround): Type arguments don't appear to be renamed
typename Reference = Reference;
typename Markup = Parser.Markup;

typename Contributor =
  (contribId: Int, contribName: String,
   contribRole: String, contribAddress: Parser.Markup);

typename Contributors =
  (subcommittee: [Contributor], additional: [Contributor]);

typename ReferenceId = Int;
typename ReferenceNumber = Int;
typename LigandId = Int;
typename LigandName = String;
typename SpeciesId = Int;
typename SpeciesShortName = String;
typename SpeciesLongName = String;

typename Model =
  Maybe((familyId: Int,
         familyName: String,
         overview: ContentBox(Markup),
         receptors: ContentBox([ReceptorSummary]),
         comments: ContentBox(Markup),
         furtherReading: ContentBox([Reference]),
         references: ContentBox([(ReferenceId, (ReferenceNumber, Reference))]),
         contributors: ContentBox(Contributors),
         ligandNames: [(LigandId, LigandName)],
         speciesNames: [(SpeciesId, (SpeciesShortName, SpeciesLongName))]
        ));

typename Message = [|
    ToggleOverview | ToggleReceptors | ToggleComments
  | ToggleFurtherReading | ToggleReferences | ToggleContributors
  | SetAllVisibilities:Bool
  | ToggleReceptorSummary:Int
|];

fun toggleBox(box) {
  (box with boxVisible=(not(box.boxVisible)))
}

fun setBoxVisibility(box, visible) {
  (box with boxVisible=visible)
}

fun withModel(model, f) {
  switch(model) {
    case Just(model) -> Just(f(model))
    case Nothing -> Nothing
  }
}

fun setBoxVisibilities(visible, model) {
  fun sbv(box) { setBoxVisibility(box, visible) }

  (model with
    overview=sbv(model.overview),
    receptors=sbv(model.receptors),
    comments=sbv(model.comments),
    furtherReading=sbv(model.furtherReading),
    references=sbv(model.references),
    contributors=sbv(model.contributors))
}

fun toggleReceptor(receptorBox, id) {
  var contents = receptorBox.contents;

  var newContents =
    map(fun(receptorBox) {
      if (receptorBox.receptorSummary.receptorId == id) {
        (receptorBox with receptorBoxVisible = not(receptorBox.receptorBoxVisible))
      } else {
        receptorBox
      }
    }, contents);
  (receptorBox with contents = newContents)
}

fun updt(msg, model) {
  withModel(model, fun(model) {
      switch(msg) {
        case ToggleOverview ->
          (model with overview=toggleBox(model.overview))
        case ToggleReceptors ->
          (model with receptors=toggleBox(model.receptors))
        case ToggleComments ->
          (model with comments=toggleBox(model.comments))
        case ToggleFurtherReading ->
          (model with furtherReading=toggleBox(model.furtherReading))
        case ToggleReferences ->
          (model with references=toggleBox(model.references))
        case ToggleContributors ->
          (model with contributors=toggleBox(model.contributors))
        case SetAllVisibilities(vis) -> setBoxVisibilities(vis, model)
        case ToggleReceptorSummary(id) ->
          (model with receptors=toggleReceptor(model.receptors, id))
      }
  })
}

fun view(model) {
  var a0 = MvuAttrs.empty;
  var h0 = MvuHTML.empty;
  fun viewModel(model) {

    # showBox: Generic content box, supporting show/hide functionality.
    # sig showBox : forall a. (ContentBox(a), Message, (a) ~> HTML(Message)) ~> HTML(Message)
    fun showBox(box, toggleMsg, f) {
      var inner = f(box.contents);
      var showHideLink =
        if(box.boxVisible) {
          a(id("hide_overview") +@ onClick(fun() { toggleMsg }),
            small(a0, textNode("Hide")))
        } else {
          a(id("show_overview") +@ onClick(fun() { toggleMsg }),
            small(a0, textNode("Show")))
        };

      var innerSection =
        if(box.boxVisible) {
          div(class("visibleSection"), inner)
        } else {
          h0
        };

      div(class("grid_16 alpha"),
        h4(a0, textNode(box.boxName)) +*
        div(class("contentboxfullhelp"),
          div(class("imageleft"), textNode("?")) +*
          div(class("textright"),
            p(class("split_para"), showHideLink) +*
            innerSection)))
    }
    # headerBox: Header information for given family
    var headerBox =
      div(class("grid_16 alpha"),
        a(name("top"), h0) +*
        div(class("contentboxfull"),
          h2(style("margin-top: 0px;"), textNode(model.familyName)) +*
          div(class("textright"),
            p(style("font-weight:normal;font-size:90%;"),
              textNode("Unless otherwise stated all data on this page refer to the human proteins. ") +*
              textNode("Gene information is provided for human (Hs), mouse (Mm) and rat (Rn).")) +*
            div(style("text-align:right;padding: 0px 5px 5px 0x;"),
              button(onClick(fun() { SetAllVisibilities(true) }), textNode("Expand all sections")) +*
              button(onClick(fun() { SetAllVisibilities(false) }), textNode("Collapse all sections"))
            )
          )));

    # Core rendering function for references.
    # TODO: Consider moving to reference.links, since this might be useful
    # in different files.
    fun renderReference(prefixNode, reference) {
      fun tn(x) { textNode(x) }
      var issueNode =
        if(reference.issue == "") {
          MvuHTML.empty
        } else {
          tn(" (" ^^ reference.issue ^^ ")")
        };
      var volumeNode =
        if (reference.volume == "") {
          MvuHTML.empty
        } else {
          b(a0, tn(reference.volume))
        };

      var pubMedHref =
        "javascript:newWindow('http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=pubmed&dopt=AbstractPlus&list_uids="
        ^^ intToString(reference.pubmedId) ^^ "', 800, 500)";

      var pubMedNode =
        tn("[PMID:") +*
        a(href(pubMedHref), tn(intToString(reference.pubmedId))) +*
        tn("]");

      p(class("grac_text"),
        prefixNode
        +* tn(reference.authors)
        +* tn(". ")
        +* tn(reference.title)
        +* tn(". ")
        +* i(a0, tn(reference.journalName))
        +* tn(", ")
        +* volumeNode
        +* issueNode
        +* tn(": ")
        +* tn(reference.pages)
        +* tn(". ")
        +* pubMedNode)
    }

    fun displayOverview(overviewMarkup) {
      var renderedMarkup =
        RenderMarkup.renderMarkup(overviewMarkup,
          model.references.contents, model.ligandNames);

      p(class("grac_text"), renderedMarkup)
    }

    fun displayReceptors(boxes) {

      fun displayReceptorBox(box) {
        var summary = box.receptorSummary;
        var toggleMsg = ToggleReceptorSummary(summary.receptorId);
        var showHideLink =
          if(box.receptorBoxVisible) {
            a(onClick(fun() { toggleMsg }),
              span(class("object_summary_link"), textNode("  Hide summary")))
          } else {
            a(onClick(fun() { toggleMsg }),
              small(class("object_summary_link"), textNode("  Show summary")))
          };

        fun mkRow(name, contents) {
          hr(class("divider_dashed"), MvuHTML.empty) +*
          table_(class("grac_data_table fullwidth"),
            tr(a0,
              td(class("grac_category_simple"), textNode(name)) +*
              td(class("grac_info_simple"), contents)))
        }

        fun resolveSpeciesShortName(speciesId) {
          switch (lookup(speciesId, model.speciesShortNames)) {
            case Just((name, _)) -> name
            case Nothing -> "?"
          }
        }

        fun resolveSpeciesLongName(speciesId) {
          switch (lookup(speciesId, model.speciesShortNames)) {
            case Just((_, name)) -> name
            case Nothing -> "?"
          }
        }


        # In the case that an interaction is with a labelled ligand, it is
        # only classed as labelled. Similarly, if the interaction is endogenous,
        # it is only classed as endogenous.
        fun splitInteractions(interactions) {
          fun go(is, labelled, endogenous, selective, neither) {
            switch(is) {
              case [] -> (labelled, endogenous, selective, neither)
              case i :: is ->
              if (i.interactionLabelled) {
                go(is, i :: labelled, endogenous, selective, neither)
              } else if (i.interactionEndogenous) {
                go(is, labelled, i :: endogenous, selective, neither)
              } else if (i.interactionSelective) {
                go(is, labelled, endogenous, i :: selective, neither)
              } else {
                go(is, labelled, endogenous, selective, i :: neither)
              }
            }
          }

          var (labelled, endogenous, selective, neither) = go(interactions, [], [], [], []);
          (reverse(labelled), reverse(endogenous), reverse(selective), reverse(neither))
        }

        var allAgonists =
          filter(fun(i) { i.interactionType == "Agonist" }, summary.receptorInteractions);
        var allAntagonists =
          filter(fun(i) { i.interactionType == "Antagonist" }, summary.receptorInteractions);
        var (labelledAgonists, endogenousAgonists,
            selectiveAgonists, otherAgonists) = splitInteractions(allAgonists);
        var (labelledAntagonists, endogenousAntagonists,
            selectiveAntagonists, otherAntagonists) = splitInteractions(allAntagonists);

        var labelledLigands = labelledAgonists ++ labelledAntagonists;

        fun showInteraction(i) {
          var interactionActionNode =
            if (not(i.interactionAction == "Agonist"
                  || i.interactionAction == "Antagonist")) {
              textNode(" (" ^^ i.interactionAction ^^ ")")
            } else { MvuHTML.empty };
          var speciesName = resolveSpeciesLongName(i.interactionSpeciesId);
          var speciesNode =
            if (speciesName <> "Human") {
              textNode(" - " ^^ speciesName)
            } else {
              MvuHTML.empty
            };

            a(href("ligandDisplay?ligandId=" ^^
                intToString(i.interactionLigandId)),
                textNode(i.interactionLigandName)) +*
            interactionActionNode +*
            speciesNode
        }

        fun mkInteractionRow(interactionType, interactions) {
          if (listEmpty(interactions)) {
            MvuHTML.empty
          } else {
            var renderedInteractions =
              map(fun(i) { [showInteraction(i)] }, interactions);

            var separatedInteractions =
              MvuHTML.concat(join([br(MvuAttrs.empty, MvuHTML.empty)], renderedInteractions));
            mkRow(interactionType, separatedInteractions)
          }
        }


        fun showSummary() {
          if (box.receptorBoxVisible) {
            var synonyms = sortBy(fun(syn) { syn.synonymOrder }, summary.receptorSynonyms);
            var synonyms = map(fun(x) { [textNode(x.synonymName)] }, synonyms);
            var separatedSynonyms = MvuHTML.concat(join([textNode(" | ")], synonyms));
            var genes = map(fun((name, id)) {
              [textNode(name) +* textNode("(" ^^ resolveSpeciesShortName(id) ^^ ")")]
              }, summary.receptorGenes);
            var separatedGenes = MvuHTML.concat(join([textNode(", ")], genes));

            mkRow("Target Id", textNode(intToString(summary.receptorId))) +*
            mkRow("Nomenclature", textNode(summary.receptorNomenclature)) +*
            mkRow("Previous and unofficial names", separatedSynonyms) +*
            mkRow("Genes", separatedGenes) +*
            mkRow("Principal transduction",
              MvuHTML.concat(map(fun(x) { textNode(x) },
                summary.receptorPrincipalTransductions))) +*
            mkInteractionRow("Endogenous agonists", endogenousAgonists) +*
            mkInteractionRow("Endogenous antagonists", endogenousAntagonists) +*
            mkInteractionRow("Agonists", otherAgonists) +*
            mkInteractionRow("Selective agonists", selectiveAgonists) +*
            mkInteractionRow("Antagonists", otherAntagonists) +*
            mkInteractionRow("Selective antagonists", selectiveAntagonists) +*
            mkInteractionRow("Labelled ligands", labelledLigands)
          } else {
            MvuHTML.empty
          }
        }

        tr(a0,
          td(class("grac_info"),
            p(class("grac_heading split_para"),
              # TODO: This needs to be parsed and rendered as markup
              textNode(box.receptorSummary.receptorNomenclature) +*
              span(class("cgtp"), textNode(" C")) +*
              showHideLink +*
              span(class("split_para_right_text detailed_view_link"),
                a(href("objectDisplay?objectId=" ^^ intToString(summary.receptorId)),
                  textNode("More detailed page") +*
                  img(attr("src", "/images/go.jpg"), MvuHTML.empty)))) +*
              showSummary()
            ))
      }

      div(class("data_tables_container"),
        table_(class("receptor_data_tables fullwidth"),
          tbody(a0,
            MvuHTML.concat(
              map(fun(x) { displayReceptorBox(x) }, boxes)))))
    }

    fun displayComments(commentMarkup) {
      var renderedMarkup =
        RenderMarkup.renderMarkup(commentMarkup,
          model.references.contents, model.ligandNames);

      p(class("grac_text"), renderedMarkup)
    }

    fun displayFurtherReading(refs) {
      p(a0, textNode("* Key further reading is highlighted with an asterisk")) +*
      MvuHTML.concat(map(fun(x) {
        var prefixNode = if(x.isKey) { textNode("* ") } else { MvuHTML.empty };
        renderReference(prefixNode, x)
      }, refs))
    }

    fun displayReferences(refs) {
      MvuHTML.concat(map(fun((_, (i, ref))) {
        var prefixNode =
          a(id("ref" ^^ intToString(i)), MvuHTML.empty) +*
          textNode(intToString(i + 1) ^^ ". ");
        renderReference(prefixNode, ref)}, refs))
    }

    sig displayContributors : (Contributors) ~> HTML(Message)
    fun displayContributors(contributors) {
      fun renderContributor(c) {
        var roleNode =
          if (c.contribRole == "") {
            MvuHTML.empty
          } else {
            textNode(" (" ^^ c.contribRole ^^ ")")
          };

        p(a0, b(a0,
          a(href("/contributorDisplay?contributorId="
            ^^ intToString(c.contribId)),
            textNode(c.contribName)) +* roleNode) +*
          br(a0, h0) +*
          RenderMarkup.renderMarkup(c.contribAddress, [], [])
        )
      }

      var subcommitteeMembers =
        MvuHTML.concat(map(renderContributor, contributors.subcommittee));
      var otherContributors =
        MvuHTML.concat(map(renderContributor, contributors.additional));

      div(id("13_subcommittee") +@ class("visibleSection") +@ style("display: block;"),
        table_(a0,
          tbody(a0,
            tr(a0,
            td(style("vertical-align: top;"),
              h3(a0, textNode("Subcommittee members:")) +*
              subcommitteeMembers) +*
            td(style("vertical-align: top;"),
              h3(a0, textNode("Other contributors:")) +*
              otherContributors)))))
    }

    # (boxName: String,  boxVisible: Bool, contents: a);
    headerBox +*
    showBox(model.overview, ToggleOverview, displayOverview) +*
    showBox(model.receptors, ToggleReceptors, displayReceptors) +*
    showBox(model.comments, ToggleComments, displayComments) +*
    showBox(model.furtherReading, ToggleFurtherReading, displayFurtherReading) +*
    showBox(model.references, ToggleReferences, displayReferences) +*
    showBox(model.contributors, ToggleContributors, displayContributors)
  }

  switch(model) {
    case Just(model) -> viewModel(model)
    case Nothing -> p(a0, textNode("Invalid family ID."))
  }
}

# sig getInitialModel : () ~> Model
fun getInitialModel() {
  fun getFamilyInfo(familyId) {
    # First, grab the basic information.
    var basicInfo =
      for (f <-- Tables.family)
        where (f.family_id == familyId)
        for (g <-- Tables.grac_family_text)
          where (g.family_id == familyId)
          [ (f.name, g.overview, g.comments) ];

    switch(basicInfo) {
      case [] -> Nothing
      case (name, overview, comments)::_ ->
        # At this point, we need to populate the rest of the data
        # (further reading, contributors, and interaction data).
        ### Further reading
        var furtherReading =
          for (fr <-- Tables.grac_further_reading)
            where (fr.family_id == familyId)
            for (ref <-- Tables.reference)
              where (ref.reference_id == fr.reference_id)
              [
                (makeReference(ref.reference_id,
                   ref.type, ref.title, ref.article_title, ref.year,
                   ref.volume, ref.issue, ref.pages, ref.publisher,
                   ref.publisher_address, ref.editors, ref.pubmed_id,
                   ref.isbn, ref.authors, fr.key_ref))
              ];
        var furtherReading =
          sortBy(fun(ref) { ref.authors }, furtherReading);

        # Given some markup, either parses it, or dumps it raw and displays
        # the error.
        fun markupOrError(str) {
          switch (Parser.parse(str)) {
            case OK(markup) -> markup
            case Error(str) ->
              MarkupAppend(MarkupText("Error: " ^^ str),
              MarkupAppend(MarkupHTMLTag("br", [], MarkupEmpty), MarkupText(str)))
          }
        }

        ### Contributors
        # It's not possible to abstract over the table here,
        # unfortunately, I don't think? Maybe we could do a
        # row annotation? There could be a way to make this slightly
        # neater, perhaps?
        var subcommitteeMembers =
          for (t <-- Tables.subcommittee)
            where (t.family_id == familyId)
            for (contrib <-- Tables.contributor_copy)
              where (contrib.contributor_id == t.contributor_id)
              orderby (-(t.display_order))
              [(resultId=contrib.contributor_id,
                resultName=(contrib.first_names ^^ " " ^^ contrib.surname),
                resultAddress=contrib.address,
                resultRole=t.role)];

        var additionalContributors =
          for (t <-- Tables.contributor2family)
            where (t.family_id == familyId)
            for (contrib <-- Tables.contributor_copy)
              where (contrib.contributor_id == t.contributor_id)
              orderby (-(t.display_order))
              [(resultId=contrib.contributor_id,
                resultName=(contrib.first_names ^^ " " ^^ contrib.surname),
                resultAddress=contrib.address,
                resultRole=t.role)];

        var subcommitteeMembers = map(fun(res) {
          (contribId=res.resultId,
          contribName=res.resultName,
          contribAddress=markupOrError(res.resultAddress),
          contribRole=res.resultRole)
        }, subcommitteeMembers);

        var additionalContributors = map(fun(res) {
          (contribId=res.resultId,
          contribName=res.resultName,
          contribAddress=markupOrError(res.resultAddress),
          contribRole=res.resultRole)
        }, additionalContributors);



        var (contributors: Contributors) =
          (subcommittee=subcommitteeMembers, additional=additionalContributors);

        # Receptors
        var receptors =
          query {
            for (r2f <-- receptor2family)
              where (r2f.family_id == familyId)
              for (receptor <-- object)
                where (receptor.object_id == r2f.object_id)
                [
                   (receptorId=receptor.object_id,
                   receptorNomenclature=receptor.name,
                   receptorSynonyms =
                     for (s <-- Tables.synonym)
                       where (s.object_id == receptor.object_id && s.display)
                       [(synonymName=s.synonym, synonymOrder=s.display_order)],
                   receptorGenes=
                      for (g <-- structural_info)
                        where (g.object_id == receptor.object_id)
                        [ (g.gene_name, g.species_id) ],
                   receptorEnsemblRefs=emptyER, # TODO
                   receptorUniprotRefs=emptyER, # TODO
                   receptorPrincipalTransductions=
                      for (tr <-- Tables.grac_transduction)
                        where (tr.object_id == receptor.object_id)
                        [tr.transduction], # There should only be one.
                    receptorInteractions=
                      for (i <-- Tables.interaction)
                        where (i.object_id == receptor.object_id && i.from_grac)
                          for (l <-- Tables.ligand)
                            where (l.ligand_id == i.ligand_id)
                              [ (makeInteraction(l.ligand_id, l.name, i.type, i.action, i.selectivity, l.labelled, i.endogenous, i.species_id)) ],
                   receptorDisplayOrder=r2f.display_order)
                ]
          };

        var receptorBoxes =
          map(fun (r) { (receptorSummary=r, receptorBoxVisible=false) },
            receptors);

        # We need to parse the markup we get, and use it to
        # get the required information from the DB.
        var overviewMarkup = markupOrError(overview);
        var commentsMarkup = markupOrError(comments);
        var (oRefs, oLigands) = collectIds(overviewMarkup);
        var (cRefs, cLigands) = collectIds(commentsMarkup);
        var refs = uniquify(oRefs ++ cRefs);
        var ligands = uniquify(oLigands ++ cLigands);

        # `contains` allows us to construct a (tame) predicate which checks
        # list membership and can be efficiently compiled to the DB. It can
        # be thought of as building up a series of "OR" clauses in a type-safe
        # way.
        var containsReference = contains(refs);
        var containsLigand = contains(ligands);

        var references =
          query {
          for (ref <-- reference)
            where (containsReference(ref.reference_id))
              [
                (makeReference(ref.reference_id,
                     ref.type, ref.title, ref.article_title, ref.year,
                     ref.volume, ref.issue, ref.pages, ref.publisher,
                     ref.publisher_address, ref.editors, ref.pubmed_id,
                     ref.isbn, ref.authors, false))
              ]
            };

        # References need to be numbered based on ordering.
        # This constructs a map from reference IDs to pairs of reference
        # numbers and references.
        var referenceData =
          mapi(fun(ref, i) { (ref.referenceId, (i, ref)) },
            sortBy(fun(ref) { ref.authors }, references));

        var ligands = query {
            for (l <-- ligand)
              where (containsLigand(l.ligand_id))
              [ (l.ligand_id, l.name) ]
          };

        # Species mapping is simple enough for us to just do in memory
        # and saves us the faff of doing joins.
        var speciesMap = query {
          for (s <-- Tables.species)
            [(s.species_id, (s.short_name, s.name))]
        };


        Just((familyId=familyId, familyName=name,
           overview=(boxName="Overview", boxVisible=true, contents=overviewMarkup),
           receptors=(boxName="Receptors", boxVisible=true, contents=receptorBoxes),
           comments=(boxName="Comments", boxVisible=true, contents=commentsMarkup),
           furtherReading=(boxName="Further Reading", boxVisible=true,
             contents=furtherReading),
           references=(boxName="References", boxVisible=true, contents=referenceData),
           contributors=(boxName="Contributors", boxVisible=true, contents=contributors),
           ligandNames = ligands,
           speciesShortNames=speciesMap
           ))
    }
  }

  switch(lookup("familyId", environment())) {
    case Just(id) -> getFamilyInfo(stringToInt(id))
    case Nothing -> Nothing
  }
}

fun mainPage() {
  var initialModel = getInitialModel();
  runSimple("vdom_placeholder", initialModel, view, updt);
  template("Family Display")
}
