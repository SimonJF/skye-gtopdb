open Reference;
open Mvu;
open MvuHTML;
open MvuAttrs;
open MvuEvents;
open Tables;
open Template;
open Parser;
open RenderMarkup;

typename ExternalRef = (
  refId: String,
  refSpeciesName: String,
  refUrl: String
);


typename Interaction = (
  interactionLigandId: Int,
  interactionLigandName: String,
  interactionType: String,
  interactionAction: String,
  interactionSelective: Bool,
  interactionLabelled: Bool
);

typename Synonym = (synonymName: String, synonymOrder: Int);

var emptyER = (refId="", refSpeciesName="", refUrl="");

typename ReceptorSummary = (
   receptorId: Int,
   receptorNomenclature: String,
   receptorSynonyms: [String],
   receptorGenes: [String],
   receptorEnsemblRefs: [ExternalRef],
   receptorUniprotRefs: [ExternalRef],
   receptorPrincipalTransduction: String,
#   receptorInteractions: [Interaction],
   # Need to sort in-memory, since `orderby` not supported w/ shredding
   receptorDisplayOrder: Int
  );

typename ReceptorBox =
  (receptorSummary: ReceptorSummary, boxVisible: Bool);

typename ContentBox(a) =
  (boxName: String,  boxVisible: Bool, contents: a);

# BUG (hacky workaround): Type arguments don't appear to be renamed
typename Reference = Reference;
typename Markup = Markup;

typename Contributor =
  (contribId: Int, contribName: String,
   contribRole: String, contribAddress: String);

typename Contributors =
  (subcommittee: [Contributor], additional: [Contributor]);

typename ReferenceId = Int;
typename ReferenceNumber = Int;
typename LigandId = Int;
typename LigandName = String;

typename Model =
  Maybe((familyId: Int,
         familyName: String,
         overview: ContentBox(Markup),
         receptors: ContentBox([ReceptorSummary]),
         comments: ContentBox(Markup),
         furtherReading: ContentBox([Reference]),
         references: ContentBox([(ReferenceId, (ReferenceNumber, Reference))]),
         contributors: ContentBox(Contributors),
         referenceData: [(ReferenceId, (ReferenceNumber, Reference))],
         ligandNames: [(LigandId, LigandName)]
        ));

typename Message = [|
    ToggleOverview | ToggleReceptors | ToggleComments
  | ToggleFurtherReading | ToggleReferences | ToggleContributors
  | SetAllVisibilities:Bool
|];

fun toggleBox(box) {
  (box with boxVisible=(not(box.boxVisible)))
}

fun setBoxVisibility(box, visible) {
  (box with boxVisible=visible)
}

fun withModel(model, f) {
  switch(model) {
    case Just(model) -> Just(f(model))
    case Nothing -> Nothing
  }
}

fun setBoxVisibilities(visible, model) {
  fun sbv(box) { setBoxVisibility(box, visible) }

  (model with
    overview=sbv(model.overview),
    receptors=sbv(model.receptors),
    comments=sbv(model.comments),
    furtherReading=sbv(model.furtherReading),
    references=sbv(model.references),
    contributors=sbv(model.contributors))
}

fun updt(msg, model) {
  withModel(model, fun(model) {
      switch(msg) {
        case ToggleOverview ->
          (model with overview=toggleBox(model.overview))
        case ToggleReceptors ->
          (model with receptors=toggleBox(model.receptors))
        case ToggleComments ->
          (model with comments=toggleBox(model.comments))
        case ToggleFurtherReading ->
          (model with furtherReading=toggleBox(model.furtherReading))
        case ToggleReferences ->
          (model with references=toggleBox(model.references))
        case ToggleContributors ->
          (model with contributors=toggleBox(model.contributors))
        case SetAllVisibilities(vis) -> setBoxVisibilities(vis, model)
      }
  })
}
# span(class("split_para_right_text detailed_view_link"),
#           a(href("familyIntroduction?familyId=" ^^ intToString(model.familyId)),
#             textNode("More detailed introduction") +*
#             img(src("/images/go.jpg"), h0)
#          ))

fun view(model) {
  var a0 = MvuAttrs.empty;
  var h0 = MvuHTML.empty;
  fun viewModel(model) {

    # showBox: Generic content box, supporting show/hide functionality.
    # sig showBox : forall a. (ContentBox(a), Message, (a) ~> HTML(Message)) ~> HTML(Message)
    fun showBox(box, toggleMsg, f) {
      var inner = f(box.contents);
      var showHideLink =
        if(box.boxVisible) {
          a(id("hide_overview") +@ onClick(fun() { toggleMsg }),
            small(a0, textNode("Hide")))
        } else {
          a(id("show_overview") +@ onClick(fun() { toggleMsg }),
            small(a0, textNode("Show")))
        };

      var innerSection =
        if(box.boxVisible) {
          div(class("visibleSection"), inner)
        } else {
          h0
        };

      div(class("grid_16 alpha"),
        h4(a0, textNode(box.boxName)) +*
        div(class("contentboxfullhelp"),
          div(class("imageleft"), textNode("?")) +*
          div(class("textright"),
            p(class("split_para"), showHideLink) +*
            innerSection)))
    }
    # headerBox: Header information for given family
    var headerBox =
      div(class("grid_16 alpha"),
        a(name("top"), h0) +*
        div(class("contentboxfull"),
          h2(style("margin-top: 0px;"), textNode(model.familyName)) +*
          div(class("textright"),
            p(style("font-weight:normal;font-size:90%;"),
              textNode("Unless otherwise stated all data on this page refer to the human proteins. ") +*
              textNode("Gene information is provided for human (Hs), mouse (Mm) and rat (Rn).")) +*
            div(style("text-align:right;padding: 0px 5px 5px 0x;"),
              button(onClick(fun() { SetAllVisibilities(true) }), textNode("Expand all sections")) +*
              button(onClick(fun() { SetAllVisibilities(false) }), textNode("Collapse all sections"))
            )
          )));

    # Core rendering function for references.
    # TODO: Consider moving to reference.links, since this might be useful
    # in different files.
    fun renderReference(reference) {
      fun tn(x) { textNode(x) }
      var issueNode =
        if(reference.issue == "") {
          MvuHTML.empty
        } else {
          tn(" (" ^^ reference.issue ^^ ")")
        };

      var pubMedHref =
        "javascript:newWindow('http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=pubmed&dopt=AbstractPlus&list_uids="
        ^^ intToString(reference.pubmedId) ^^ "', 800, 500)";

      var pubMedNode =
        tn("[PMID:") +*
        a(href(pubMedHref), tn(intToString(reference.pubmedId))) +*
        tn("]");

      var keyNode =
        if(reference.isKey) {
          textNode("* ")
        } else {
          MvuHTML.empty
        };

      p(class("grac_text"),
        keyNode
        +* tn(reference.authors)
        +* tn(". ")
        +* tn(reference.title)
        +* tn(". ")
        +* i(a0, tn(reference.journalName))
        +* tn(", ")
        +* b(a0, tn(intToString(reference.volume)))
        +* issueNode
        +* tn(": ")
        +* tn(reference.pages)
        +* tn(". ")
        +* pubMedNode)
    }

    fun displayOverview(overviewText) {
      p(class("grac_text"), textNode(overviewText))
    }
    fun displayReceptors(_) {
      MvuHTML.empty
    }
    fun displayComments(commentText) {
      p(class("grac_text"), textNode(commentText))
    }
    fun displayFurtherReading(refs) {
      p(a0, textNode("* Key further reading is highlighted with an asterisk")) +*
      MvuHTML.concat(map(fun(x) { renderReference(x)}, refs))
    }

    fun displayReferences(refs) {
      MvuHTML.concat(map(fun((_, (i, ref))) { textNode(intToString(i) ^^ " ") +*
        renderReference(ref)}, refs))
    }

    sig displayContributors : (Contributors) ~> HTML(Message)
    fun displayContributors(contributors) {
      fun renderContributor(c) {
        var roleNode =
          if (c.contribRole == "") {
            MvuHTML.empty
          } else {
            textNode(" (" ^^ c.contribRole ^^ ")")
          };

        p(a0, b(a0,
          a(href("/contributorDisplay?contributorId="
            ^^ intToString(c.contribId)),
            textNode(c.contribName)) +* roleNode) +*
          br(a0, h0) +*
          textNode(c.contribAddress)
        )
      }

      var subcommitteeMembers =
        MvuHTML.concat(map(renderContributor, contributors.subcommittee));
      var otherContributors =
        MvuHTML.concat(map(renderContributor, contributors.additional));

      div(id("13_subcommittee") +@ class("visibleSection") +@ style("display: block;"),
        table_(a0,
          tbody(a0,
            tr(a0,
            td(style("vertical-align: top;"),
              h3(a0, textNode("Subcommittee members:")) +*
              subcommitteeMembers) +*
            td(style("vertical-align: top;"),
              h3(a0, textNode("Other contributors:")) +*
              otherContributors)))))
    }

    # (boxName: String,  boxVisible: Bool, contents: a);
    headerBox +*
    showBox(model.overview, ToggleOverview, displayOverview) +*
    showBox(model.receptors, ToggleReceptors, displayReceptors) +*
    showBox(model.comments, ToggleComments, displayComments) +*
    showBox(model.furtherReading, ToggleFurtherReading, displayFurtherReading) +*
    showBox(model.referenceData, ToggleReferences, displayReferences) +*
    showBox(model.contributors, ToggleContributors, displayContributors)
  }

  div(class("container_16"),
    div(class("grid_12"),
      switch(model) {
        case Just(model) -> viewModel(model)
        case Nothing -> p(a0, textNode("Invalid family ID."))
      }))
}

# sig getInitialModel : () ~> Model
fun getInitialModel() {
  fun getFamilyInfo(familyId) {
    # First, grab the basic information.
    var basicInfo =
      for (f <-- Tables.family)
        where (f.family_id == familyId)
        for (g <-- Tables.grac_family_text)
          where (g.family_id == familyId)
          [ (f.name, g.overview, g.comments) ];

    switch(basicInfo) {
      case [] -> Nothing
      case (name, overview, comments)::_ ->
        # At this point, we need to populate the rest of the data
        # (further reading, contributors, and interaction data).
        ### Further reading
        var furtherReading =
          for (fr <-- Tables.grac_further_reading)
            where (fr.family_id == familyId)
            for (ref <-- Tables.reference)
              where (ref.reference_id == fr.reference_id)
              orderby(ref.authors)
              [
                (makeReference(ref.reference_id,
                   ref.type, ref.title, ref.article_title, ref.year,
                   ref.volume, ref.issue, ref.pages, ref.publisher,
                   ref.publisher_address, ref.editors, ref.pubmed_id,
                   ref.isbn, ref.authors, fr.key_ref))
              ];
          var furtherReading = reverse(furtherReading);

        ### Contributors
        # It's not possible to abstract over the table here,
        # unfortunately, I don't think? Maybe we could do a
        # row annotation? There could be a way to make this slightly
        # neater, perhaps?
        var (subcommitteeMembers: [Contributor]) =
          for (t <-- Tables.subcommittee)
            where (t.family_id == familyId)
            for (contrib <-- Tables.contributor_copy)
              where (contrib.contributor_id == t.contributor_id)
              orderby (-(t.display_order))
              [(contribId=contrib.contributor_id,
                contribName=(contrib.first_names ^^ " " ^^ contrib.surname),
                contribAddress=contrib.address,
                contribRole=t.role)];

        var (additionalContributors: [Contributor]) =
          for (t <-- Tables.contributor2family)
            where (t.family_id == familyId)
            for (contrib <-- Tables.contributor_copy)
              where (contrib.contributor_id == t.contributor_id)
              orderby (-(t.display_order))
              [(contribId=contrib.contributor_id,
                contribName=(contrib.first_names ^^ " " ^^ contrib.surname),
                contribAddress=contrib.address,
                contribRole=t.role)];


        var (contributors: Contributors) =
          (subcommittee=subcommitteeMembers, additional=additionalContributors);

        # Receptors
        var receptors =
          query {
            for (r2f <-- receptor2family)
              where (r2f.family_id == familyId)
              for (receptor <-- object)
                where (receptor.object_id == r2f.object_id)
                [
                   (receptorId=receptor.object_id,
                   receptorNomenclature=receptor.name,
                   receptorSynonyms =
                     for (s <-- Tables.synonym)
                       where (s.object_id == receptor.object_id && s.from_grac && s.display)
                       [(synonymName=s.synonym, synonymOrder=s.display_order)],
                   receptorGenes="", # TODO
                   receptorEnsemblRefs=emptyER, # TODO
                   receptorUniprotRefs=emptyER, # TODO
                   receptorPrincipalTransduction="", # TODO
                   # receptorInteractions=[], # TODO
                   receptorDisplayOrder=r2f.display_order)
                ]
          };

        # Given some markup, either parses it, or dumps it raw and displays
        # the error.
        fun markupOrError(str) {
          switch (Parser.parse(str)) {
            case OK(markup) -> markup
            case Error(str) ->
              MarkupAppend(MarkupText("Error: " ^^ str),
              MarkupAppend(MarkupHTMLTag("br", MarkupEmpty), MarkupText(str)))
          }
        }

        # TODO: Duplicate handling
        # Right, here we need to parse the markup we get, and use it to
        # get the required information from the DB.
        var overviewMarkup = markupOrError(overview);
        var commentsMarkup = markupOrError(comments);
        var (oRefs, oLigands) = collectIds(overviewMarkup);
        var (cRefs, cLigands) = collectIds(commentsMarkup);
        var refs = oRefs ++ cRefs;
        var ligands = oLigands ++ cLigands;

        # Now, we need to get the references and ligand names from the DB.
        # The tricky thing is we can't do a simple LINQ query (as far as I can see),
        # since list membership is wild.
        # We have two (unappealing) options: a single query for each reference (which would lead to
        # somewhere in the order of 20-30 queries), or fetching the data into memory and filtering
        # (which is about 9000 tuples for Ligands, and about 35000 tuples for references)
        # I'm going to go to the former, I suppose.
        var references =
          concatMap(fun(ref) {
            query {
              for (r <-- reference)
                where (r.reference_id == ref.referenceId)
                [
                  (makeReference(ref.referenceId,
                     ref.type, ref.title, ref.article_title, ref.year,
                     ref.volume, ref.issue, ref.pages, ref.publisher,
                     ref.publisher_address, ref.editors, ref.pubmed_id,
                     ref.isbn, ref.authors, ref.key_ref))
                ]
            }
          }, refs);

        # References need to be numbered based on ordering.
        # This constructs a map from reference IDs to pairs of reference
        # numbers and references.
        var referenceData =
          mapi(fun(i, x) { (ref.reference_id, (i, x)) },
            sortBy(fun(ref) { ref.authors }, references));

        var ligands = concatMap(fun(ligandId) {
          query {
            for (l <-- ligand)
              where (l.ligand_id == ligandId)
              [ (ligandId, l.name) ]
          }
        });


        Just((familyId=familyId, familyName=name,
           overview=(boxName="Overview", boxVisible=true, contents=overview),
           receptors=(boxName="Receptors", boxVisible=true, contents=[]),
           comments=(boxName="Comments", boxVisible=true, contents=comments),
           furtherReading=(boxName="Further Reading", boxVisible=true,
             contents=furtherReading),
           references=(boxName="References", boxVisible=true,
             contents=referenceData),
           contributors=(boxName="Contributors", boxVisible=true, contents=contributors),
           referenceData = referenceData,
           ligandNames = ligands))
    }
  }

  switch(lookup("familyId", environment())) {
    case Just(id) -> getFamilyInfo(stringToInt(id))
    case Nothing -> Nothing
  }
}

fun mainPage() {
  var initialModel = getInitialModel();
  runSimple("vdom_placeholder", initialModel, view, updt);
  template("Family Display")
}
