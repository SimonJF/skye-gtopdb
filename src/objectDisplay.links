# Ooft, the one I've been dreading.
# Detailed information about objects (i.e., ligand targets: receptors,
# ion channels, etc.)

# TODO (22nd April list):
# 5. Immuno process associations (mostly done; still a bit to do)
# 6. Phenotypes etc.
# 7. Expression datasets
# 9. Activator / inhibitor tables with voltage information
# 10. Annotation status
# 11. Gene expression and pathophysiology + comments
# 12. Clinically-relevant mutations and pathophysiology + comments


# TODO: Voltage dependence field for VGICs.
# Functional characteristics
open Parser;
open RenderMarkup;
open Reference;
open DataTable;
open Contributor;
open InteractionUtilities;
open Transduction;
open Utility;
open MvuHTML;
open MvuAttrs;
open Mvu;
open Template;
open Ligand;
open Species;
open ToggleBox;
open AnnotationStatus;

typename InteractionTable = [|
    AgonistsTable         | AntagonistsTable | AllostericModulatorsTable
  | ActivatorsTable       | InhibitorsTable  | ChannelBlockersTable
  | GatingInhibitorsTable | SubunitSpecificTable
|];

typename ColumnName = String;

typename Message = [|
    SortInteractionTable:(InteractionTable, ColumnName, SortDirection)
  | ToggleReferences | ToggleContributors | ToggleShowIEA:Int
|];

typename Family = (familyId: Int, familyName: Markup);
typename AnnotationStatus = Int; # TODO: More meaningful datatype here
typename LigandID = Int;
typename SpeciesID = Int;
typename PDBID = String;

typename GeneProteinInfo = (
    gpiSpeciesID: Int,
    gpiSymbol: String,
    gpiShortName: String,
    gpiName: Markup,
    gpiTransmembraneDomains: Int,
    gpiAminoAcids: Int,
    gpiReferences: [ReferenceID],
    gpiChromosomalLocation: String
);

typename PDBData = (
    pdbCode: PDBID,
    pdbLigandId: Int,
    pdbLigandName: Markup,
    pdbLigandDescription: Markup,
    pdbSpeciesId: SpeciesID,
    pdbReferences: [ReferenceID],
    pdbResolution: Float
);

typename EndogenousLigandSummary =
  (elsName: Markup, elsSpeciesID: SpeciesID, elsLigandID: LigandID);

typename Phenotype = (
    phenoAllele: Markup,
    phenoComposition: Markup,
    phenoAccessions: Markup,
    phenoSpeciesID: SpeciesID,
    phenoPubmedID: String,
    phenoPhenotype: Markup
);

typename CellTypeAssociation = (
  ctaImmunoCelltype: (immunoCTID: Int, immunoCTName: String),
  ctaComments: Markup,
  ctaCellOntologyType: (cellOntologyName: String, cellOntologyID: String),
  ctaReferences: [ReferenceID]
);


typename ImmunoProcessAssociation = (
  ipImmunoProcess: (immunoProcessID: Int, immunoProcessName: String),
  ipShowIEA: Bool,
  ipGoProcesses: [
    (goProcessID: String,
     goProcessComment: String,
     goProcessEvidence: String)
  ],
  ipReferences: [ReferenceID]
);

typename LigandSize = [| Small | Peptide | OtherSize |];

typename Interaction = (
    iLigandId: Int,
    iLigandName: Markup,
    iLigandRawName: String,
    iLigandSize: LigandSize,
    iLigandApproved: Bool,
    iLigandPrimary: Bool,
    iLigandEndogenous: Bool,
    iLigandLabelled: Bool,
    iLigandRadioactive: Bool,
    iLigandSpecies: SpeciesID,
    iLigandAction: String,
    iLigandAffinity: InteractionAffinity,
    iLigandReferences: [ReferenceID],
    iLigandImmuno: Bool,
    iLigandSelective: Bool,
    iLigandSelectivity: String,
    iLigandPDB: Bool,
    iLigandDetailedAffinity: [(String, ReferenceID)]
);

typename SortedInteractions = (
  agonists: SortableTable(Interaction, Message),
  antagonists: SortableTable(Interaction, Message),
  allostericModulators: SortableTable(Interaction, Message),
  activators: SortableTable(Interaction, Message),
  inhibitors: SortableTable(Interaction, Message),
  channelBlockers: SortableTable(Interaction, Message),
  gatingInhibitors: SortableTable(Interaction, Message),
  subunitSpecific: SortableTable(Interaction, Message));

typename Variant = (
    vId: Int,
    vType: String,
    vSpecies: SpeciesID,
    vDescription: Markup,
    vReferences: [ReferenceID]
);

typename ReceptorComments = (
  listComments: Markup,
  associatedProteinsComments: Markup,
  functionalAssayComments: Markup,
  tissueDistributionComments: Markup,
  functionsComments: Markup,
  alteredExpressionComments: Markup,
  expressionPathophysiologyComments: Markup,
  mutationsPathophysiologyComments: Markup,
  variantsComments: Markup,
  xenobioticExpressionComments: Markup,
  antibodyComments: Markup,
  agonistsComments: Markup,
  antagonistsComments: Markup,
  allostericModulatorsComments: Markup,
  activatorsComments: Markup,
  inhibitorsComments: Markup,
  channelBlockersComments: Markup,
  gatingInhibitorsComments: Markup,
  generalComments: Markup,
  immunoComments: Markup,
  malariaComments: Markup
);

typename DataTableEntry = (
  entryComment: Markup,
  entryData: [(String, Markup)],
  entryReferences: [ReferenceID]
);

typename DataTableBox = (
    boxName: String,
    boxRows: [DataTableEntry]
);

typename URL = String;

typename DatabaseLink = (
  dbID: Int,
  dbName: String,
  dbURL: URL,
  dbSpecialist: Bool,
  dbPrefix: String,
  dbEntries: [(SpeciesID, String, URL)]
);

# TODO: Best to do this all gradually, and uncomment things as they're implemented
typename ObjectInfo = (
    objectId: Int,
    objectName: Markup,
    objectSynonyms: [Markup],
    objectFamily: Family,
    objectAnnotationStatus: AnnotationStatus,
    objectGeneProteinInfo:
      (giComments: Markup, giEntries: [GeneProteinInfo]),
    # TODO: Suss this out and add it in
    # objectQuaternaryStructure: (),
    objectDatabaseLinks: [DatabaseLink],
    objectPDBData: [PDBData],
    objectEndogenousLigands: [EndogenousLigandSummary],
    # TODO: Potency order(!?)
  # objectPotencyOrder: (),
    objectSortedInteractions: SortedInteractions,
    objectTransductionMechanisms: [TransductionMechanism],
    objectTissueDistribution: DataTableBox,
    objectCellTypeAssociations: [CellTypeAssociation],
    objectImmunoProcessAssociations: [ImmunoProcessAssociation],
    # TODO: Expression dataset(!?)
   # objectExpressionDataset: (),
    objectFunctionalAssays: DataTableBox,
    objectPhysiologicalFunctions: DataTableBox,
    objectPhysiologicalConsequences: DataTableBox,
   # objectPhenotypes: SortableTable(Phenotype, Message),
    objectVariants: [Variant],
    objectComments: ReceptorComments,
    objectShowReferences: Bool,
    objectReferences: [(ReferenceID, (ReferenceNumber, Reference.Reference))],
    objectLigandNames: [(LigandId, LigandName)],
    objectSpeciesMap: SpeciesMap,
    objectContributors: ContentBox([Contributor.Contributor])
);

typename Model = Maybe(ObjectInfo);

sig getInitialModel : () ~%~> Model
fun getInitialModel() {

  sig getObjectInfo : (Int) ~%~> Maybe(ObjectInfo)
  fun getObjectInfo(objectId) {
    var defaultRB =
      (object_id=objectId,
       list_comments="",
       associated_proteins_comments="",
       functional_assay_comments="",
       tissue_distribution_comments="",
       functions_comments="",
       altered_expression_comments="",
       expression_pathophysiology_comments="",
       mutations_pathophysiology_comments="",
       variants_comments="",
       xenobiotic_expression_comments="",
       antibody_comments="",
       agonists_comments="",
       antagonists_comments="",
       allosteric_modulators_comments="",
       activators_comments="",
       inhibitors_comments="",
       channel_blockers_comments="",
       gating_inhibitors_comments="");

    # Each object should have at most one `receptor_basic` entry.
    # If there aren't any, we need to (manually) create a dummy one.
    fun rbOrDefault(rbs) {
      switch(rbs) {
        case [] -> defaultRB
        case x :: _ -> x
      }
    }

    var raw = query {
      for (o <-- Tables.object)
        where (o.object_id == objectId)
        for (rb <-- Tables.receptor_basic)
          where (rb.object_id == objectId)
            [(id = objectId,
             name = o.name,
             comments = o.comments,
             grac_comments = o.grac_comments,
             immuno_comments = o.gtip_comment,
             malaria_comments = o.gtmp_comment,
             synonyms =
               for (s <-- Tables.synonym)
                 where (s.object_id == objectId && s.display)
                 [(synonym=s.synonym, order=s.display_order)],
             family =
               for (r2f <-- Tables.receptor2family)
                 where (r2f.object_id == o.object_id)
                   for (f <-- Tables.family)
                     where (f.family_id == r2f.family_id)
                     [(id=f.family_id, name=f.name)],
             annotationStatus = o.annotation_status,
             generalComments = o.comments,
             gpcrComments =
               for (gpcr <-- Tables.gpcr)
                where (gpcr.object_id == objectId)
                  [gpcr.class],
             geneInformation =
               for (si <-- Tables.structural_info)
                 where (si.object_id == objectId)
                 [(si=si,
                   refs =
                     for (siRef <-- Tables.structural_info_refs)
                       where (siRef.structural_info_id == si.structural_info_id)
                       [siRef.reference_id])],
             databaseLinks =
               for (dbl <-- Tables.database_link)
                 where (dbl.object_id == objectId)
                   [dbl],
             pdbData =
               for (pdb <-- Tables.pdb_structure)
                 where (pdb.object_id == objectId)
                 for (l <-- Tables.ligand)
                   where (l.ligand_id == pdb.ligand_id)
                   [(pdb = pdb,
                     ligand = l,
                     refs =
                       for (pdbR <-- Tables.pdb_structure_refs)
                         where (pdbR.pdb_structure_id == pdb.pdb_structure_id)
                         [pdbR.reference_id])],
             potencyOrder = (), # FIXME: FILL ME IN
             receptorBasic = rb,
             cellTypeAssociations =
               for (cta <-- Tables.celltype_assoc)
               where (cta.object_id == objectId)
                 for (ctac <-- Tables.celltype_assoc_colist)
                 where (ctac.celltype_assoc_id == cta.celltype_assoc_id)
                   for (ct <-- Tables.co_celltype)
                   where (ct.cellonto_id == ctac.cellonto_id)
                     for (immuno <-- Tables.immuno_celltype)
                     where (immuno.immuno_celltype_id == cta.immuno_celltype_id)
                     [( ctaComment = cta.comment,
                        cellType = ct,
                        immuno = immuno,
                        refs =
                          for (car <-- Tables.celltype_assoc_refs)
                          where (car.celltype_assoc_id == cta.celltype_assoc_id)
                          [car.reference_id]
                      )],
             immunoProcessAssociations =
               for (pa <-- Tables.process_assoc)
               where (pa.object_id == objectId)
                 for (gtip <-- Tables.gtip_process)
                 where (gtip.gtip_process_id == pa.gtip_process_id)
                   # Relevant immuno processes
                   [( gtipProc = gtip,
                      goProcs =
                        # FIXME: This doesn't quite work; we also need to do something with
                        # go_process_rel.
                        # GO immuno processes associated with relevant GTIP processes,
                        # where the GO processes are associated with the given object.
                        # (Just because a GO process is associated with a GTIP process,
                        # does not mean that it's relevant for a given object).
                        for (g2go <-- Tables.gtip2go_process)
                        where (g2go.gtip_process_id == gtip.gtip_process_id)
                          for (o2go <-- Tables.object2go_process)
                          where (o2go.object_id == objectId && o2go.go_process_id == g2go.go_process_id)
                            for (go <-- Tables.go_process)
                            where (go.go_process_id == o2go.go_process_id)
                            [(o2go = o2go, go = go)],
                      refs =
                        for (r <-- Tables.process_assoc_refs)
                        where (r.process_assoc_id == pa.process_assoc_id)
                        [r.reference_id])],
             interactions =
               for (i <-- Tables.interaction)
                 where (i.object_id == objectId)
                   for (l <-- Tables.ligand)
                     where (l.ligand_id == i.ligand_id)
                     [(interaction = i,
                       ligand = l,
                       hasPDB =
                        length(
                          for (pdb <-- Tables.pdb_structure)
                            where (pdb.object_id == objectId && pdb.ligand_id == l.ligand_id)
                            [pdb]) > 0,
                       refs =
                         for (iar <-- Tables.interaction_affinity_refs)
                           where (iar.interaction_id == i.interaction_id)
                           [iar.reference_id])],
             tissueDistribution =
               for (td <-- Tables.tissue_distribution)
                 where (td.object_id == objectId)
                   [(td = td,
                     refs =
                       for (r <-- Tables.tissue_distribution_refs)
                         where (r.tissue_distribution_id == td.tissue_distribution_id)
                         [r.reference_id])],
             expressionDataset = (), # FIXME: FILL ME IN
             functionalAssays =
               for (fa <-- Tables.functional_assay)
                 where (fa.object_id == objectId)
                   [(fa=fa, refs=
                       for (faRef <-- Tables.functional_assay_refs)
                         where (faRef.functional_assay_id == fa.functional_assay_id)
                         [faRef.reference_id])],
             physiologicalFunctions =
               for (pf <-- Tables.physiological_function)
                 where (pf.object_id == objectId)
                   [(pf = pf,
                     refs =
                       for (pfRef <-- Tables.physiological_function_refs)
                         where (pfRef.physiological_function_id == pf.physiological_function_id)
                         [pfRef.reference_id])],
             alteredExpressions =
               for (ae <-- Tables.altered_expression)
                 where (ae.object_id == objectId)
                   [(ae = ae,
                     refs =
                       for (aeRef <-- Tables.altered_expression_refs)
                         where (aeRef.altered_expression_id == ae.altered_expression_id)
                         [aeRef.reference_id])],
             alleles = (), # Getting this is a faff, requiring structural info, etc. Leaving for now.
             variants =
               for (v <-- Tables.variant)
                 where (v.object_id == objectId)
                   [(v=v,
                     refs =
                       for (vRef <-- Tables.variant_refs)
                         where (vRef.variant_id == v.variant_id)
                         [vRef.reference_id])],
             contributors =
               for (c2o <-- Tables.contributor2object)
                 where (c2o.object_id == objectId)
                   for (c <-- Tables.contributor_copy)
                     where (c.contributor_id == c2o.contributor_id)
                     [(c = c, order=c2o.display_order)]
             )]
    };

    fun mkModel(raw) {
      var speciesMap = Species.getSpeciesMap();
      fun speciesShortName(speciesID) { resolveSpeciesShortName(speciesID, speciesMap) }
      fun speciesLongName(speciesID) { resolveSpeciesLongName(speciesID, speciesMap) }
      # OK, first parse interactions. Given the interactions field from the raw
      # data, this should get us a record of:
      # (agonists: [Interaction],
      #  antagonists: [Interaction],
      #  allostericModulators: [Interaction],
      #  activators: [Interaction],
      #  inhibitors: [Interaction],
      #  channelBlockers: [Interaction],
      #  gatingInhibitors: [Interaction],
      #  subunitSpecific: [Interaction],
      #  endogenous: [EndogenousLigandSummary],
      #  references: [ReferenceID])
      fun transformInteractions(rawInteractions) {
        var emptyResult =
          (agonists = [], antagonists = [], allostericModulators = [],
           activators = [], inhibitors = [], channelBlockers = [],
           gatingInhibitors = [], subunitSpecific = [], endogenous = [],
           references = []);

        fold_left(fun(acc, x) {
          var i = x.interaction;
          var l = x.ligand;
          var refs = x.refs;
          var size = {
            if (l.type == "Peptide" || l.type == "Antibody") {
              Peptide
            } else if (l.type == "Metabolite"
                || l.type == "Synthetic organic" || l.type == "Natural product") {
              Small
            } else {
              OtherSize
            }
          };

          var interaction_aff = (
              affinityUnits = i.affinity_units,
              affinityLow = i.affinity_low,
              affinityMedian = i.affinity_median,
              affinityHigh = i.affinity_high
            );

          var parsed = (
            iLigandId = l.ligand_id,
            iLigandName = parseOrError(l.name),
            iLigandRawName = l.name,
            iLigandSize = size,
            iLigandApproved = l.approved,
            iLigandPrimary = i.primary_target,
            iLigandEndogenous = i.endogenous,
            iLigandLabelled = l.labelled,
            iLigandRadioactive = l.radioactive,
            iLigandSpecies = i.species_id,
            iLigandAction = i.action,
            iLigandAffinity = interaction_aff,
            iLigandReferences = refs,
            iLigandImmuno = l.in_gtip,
            iLigandSelective = i.selective,
            iLigandSelectivity = i.selectivity,
            iLigandPDB = x.hasPDB,
            iLigandDetailedAffinity = []
          );

          var acc =
            if (i.type == "Agonist") {
              (acc with agonists = ( parsed :: acc.agonists ))
            } else if (i.type == "Antagonist") {
              (acc with antagonists = ( parsed :: acc.antagonists ))
            } else if (i.type == "Allosteric modulator") {
              (acc with allostericModulators = ( parsed :: acc.allostericModulators ))
            } else if (i.type == "Activator") {
              (acc with activators = ( parsed :: acc.activators ))
            } else if (i.type == "Inhibitor") {
              (acc with inhibitors = ( parsed :: acc.inhibitors ))
            } else if (i.type == "Channel blocker") {
              (acc with channelBlockers = ( parsed :: acc.channelBlockers ))
            } else if (i.type == "Gating inhibitor") {
              (acc with gatingInhibitors = ( parsed :: acc.gatingInhibitors ))
            } else if (i.type == "Subunit-specific") {
              (acc with subunitSpecific = ( parsed :: acc.subunitSpecific ))
            } else {
              acc
            };

          var acc =
            if (i.endogenous) {
              var els =
                (elsName = parseOrError(l.name),
                 elsSpeciesID = i.species_id,
                 elsLigandID = i.ligand_id);
              (acc with endogenous = els :: acc.endogenous)
            } else { acc };

          (acc with references = (refs ++ acc.references))
        }, emptyResult, rawInteractions)
      }

      fun mkInteractionTables(parsedInteractions) {
        # Columns are slightly different based on the type of interaction.
        # Agonists / antagonists / channel blockers / allosteric modulators:
        #  ligand, data cols, species, action, affinity, parameter, references
        # Activators / Inhibitors / Gating inhibitors:
        #  ligand, data cols, species, action, affinity, parameter, holding voltage, reference

        fun mkStandardInteractionTable(tableTy, interactions) {
          var cols = [
            ("Ligand", ("", Sortable(fun(x, y) { simpleCmp(x.iLigandRawName, y.iLigandRawName) }))),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("Sp.", ("keybox_header",
              Sortable(fun(x, y) { simpleCmp(x.iLigandSpecies, y.iLigandSpecies) }))),
            ("Action", ("action_header",
              Sortable(fun(x, y) { simpleCmp(x.iLigandAction, y.iLigandAction) }))),
            ("Affinity", ("affinity_header", Sortable(fun(x, y) {
                InteractionUtilities.sortAffinity(x.iLigandAffinity, y.iLigandAffinity)}))),
            ("Affinity Units", ("units_header", Sortable(fun(x, y) {
                simpleCmp(x.iLigandAffinity.affinityUnits, y.iLigandAffinity.affinityUnits) }))),
            ("References", ("reference_header", NotSortable))
          ];
          fun sortMessage(colName, sortDir) { SortInteractionTable(tableTy, colName, sortDir) }
          DataTable.makeTable(cols, interactions, sortMessage)
        }

        fun mkActivatorTable(tableTy, interactions) {
          var cols = [
            ("Ligand", ("", Sortable(fun(x, y) { simpleCmp(x.iLigandRawName, y.iLigandRawName) }))),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("Species", ("keybox_header",
              Sortable(fun(x, y) { simpleCmp(x.iLigandSpecies, y.iLigandSpecies) }))),
            ("Affinity", ("affinity_header", Sortable(fun(x, y) {
                simpleCmp(x.iLigandAffinity.affinityMedian,
                    y.iLigandAffinity.affinityMedian) }))),
            ("Parameter", ("units_header", Sortable(fun(x, y) {
                simpleCmp(x.iLigandAffinity.affinityUnits, y.iLigandAffinity.affinityUnits)}))),
             # FIXME: Need to fix these up when we have the right details in the model
            ("Concentration range (M)", ("", NotSortable)), ("Holding voltage (mV)", ("", NotSortable)),
            ("References", ("reference_header", NotSortable))
          ];

          fun sortMessage(colName, sortDir) { SortInteractionTable(tableTy, colName, sortDir) }
          DataTable.makeTable(cols, interactions, sortMessage)
        }

        (agonists = mkStandardInteractionTable(AgonistsTable, parsedInteractions.agonists),
         antagonists = mkStandardInteractionTable(AntagonistsTable, parsedInteractions.antagonists),
         allostericModulators =
           mkStandardInteractionTable(AllostericModulatorsTable,
             parsedInteractions.allostericModulators),
         activators =
           mkActivatorTable(ActivatorsTable, parsedInteractions.activators),
         inhibitors =
           mkActivatorTable(InhibitorsTable, parsedInteractions.inhibitors),
         channelBlockers =
           mkActivatorTable(ChannelBlockersTable, parsedInteractions.channelBlockers),
         gatingInhibitors =
           mkActivatorTable(GatingInhibitorsTable, parsedInteractions.gatingInhibitors),
         subunitSpecific =
           mkStandardInteractionTable(SubunitSpecificTable, parsedInteractions.subunitSpecific))
      }

      fun transformPDBs(rawPDBs) {
        fun transformPDB(rawPDB) {
          var pdb = rawPDB.pdb;
          var ligand = rawPDB.ligand;
          var refs = rawPDB.refs;
          var res =
            (pdbCode = pdb.pdb_code,
             pdbLigandId = ligand.ligand_id,
             pdbLigandName = parseOrError(ligand.name),
             pdbLigandDescription = parseOrError(pdb.description),
             pdbSpeciesId = pdb.species_id,
             pdbReferences = [],
             pdbResolution = pdb.resolution);
          var (descriptionRefs, descriptionLigands) =
            RenderMarkup.collectIds(res.pdbLigandDescription);
          var allRefs = refs ++ descriptionRefs;
          ((res with pdbReferences = allRefs), allRefs, descriptionLigands)
        }

        var (pdbsRev, pdbRefs, pdbLigands) =
          fold_left(fun((pdbs, pdbRefs, pdbLigands), pdb) {
              var (pdb, refs, ligands) = transformPDB(pdb);
              (pdb :: pdbs, refs ++ pdbRefs, ligands ++ pdbLigands)
          }, ([], [], []), rawPDBs);
        (reverse(pdbsRev), pdbRefs, pdbLigands)
      }

      fun transformVariants(rawVs) {
        var (variantsRev, vRefs, vLigands) =
          fold_left(fun((variants, vRefs, vLigands), rawV) {
            var v = rawV.v;
            var desc = parseOrError(v.description);
            var (refIDs, ligandIDs) = collectIds(desc);
            var res =
              (vId = v.variant_id,
               vType = v.type,
               vSpecies = v.species_id,
               vDescription = desc,
               vReferences = rawV.refs
              );
            (res :: variants, refIDs ++ res.vReferences, ligandIDs)
          }, ([], [], []), rawVs);
        (reverse(variantsRev), vRefs, vLigands)
      }


      fun transformReceptorComments(rb, general, immuno, malaria) {
        var res = (
          listComments = parseOrError(rb.list_comments),
          associatedProteinsComments = parseOrError(rb.associated_proteins_comments),
          functionalAssayComments = parseOrError(rb.functional_assay_comments),
          tissueDistributionComments = parseOrError(rb.tissue_distribution_comments),
          functionsComments = parseOrError(rb.functions_comments),
          alteredExpressionComments = parseOrError(rb.altered_expression_comments),
          expressionPathophysiologyComments = parseOrError(rb.expression_pathophysiology_comments),
          mutationsPathophysiologyComments = parseOrError(rb.mutations_pathophysiology_comments),
          variantsComments = parseOrError(rb.variants_comments),
          xenobioticExpressionComments = parseOrError(rb.xenobiotic_expression_comments), antibodyComments = parseOrError(rb.antibody_comments),
          agonistsComments = parseOrError(rb.agonists_comments),
          antagonistsComments = parseOrError(rb.antagonists_comments),
          allostericModulatorsComments = parseOrError(rb.allosteric_modulators_comments),
          activatorsComments = parseOrError(rb.activators_comments),
          inhibitorsComments = parseOrError(rb.inhibitors_comments),
          channelBlockersComments = parseOrError(rb.channel_blockers_comments),
          gatingInhibitorsComments = parseOrError(rb.gating_inhibitors_comments),
          generalComments = parseOrError(general),
          immunoComments = parseOrError(immuno),
          malariaComments = parseOrError(malaria));


        var (commentRefs, commentLigands) = collectAllIds(
          [res.listComments, res.associatedProteinsComments,
            res.functionalAssayComments, res.tissueDistributionComments,
            res.functionsComments, res.alteredExpressionComments,
            res.expressionPathophysiologyComments,
            res.mutationsPathophysiologyComments, res.variantsComments,
            res.xenobioticExpressionComments, res.antibodyComments,
            res.agonistsComments, res.antagonistsComments,
            res.allostericModulatorsComments, res.activatorsComments,
            res.inhibitorsComments, res.channelBlockersComments,
            res.gatingInhibitorsComments, res.generalComments,
            res.immunoComments, res.malariaComments]);
        (res, commentRefs, commentLigands)
      }

      fun transformSynonyms(synonyms) {
        map(fun(s) {parseOrError(s.synonym) },
            sortBy(fun(s) { s.order }, synonyms))
      }

      fun transformFamily(fs) {
        switch(fs) {
          case [] -> (familyId = (-1), familyName = MarkupEmpty)
          case f :: _ -> (familyId = f.id, familyName = parseOrError(f.name))
        }
      }

      fun transformGeneProteinInfo(gpcrComments, gis) {
        var (gisRev, giRefs) =
          fold_left(fun((gis_rev, refs), gi) {
            var references = gi.refs;
            var gi = gi.si;
            var res = (
              gpiSpeciesID = gi.species_id,
              gpiName = parseOrError(gi.gene_long_name),
              gpiSymbol = gi.official_gene_id,
              gpiShortName = gi.gene_name,
              gpiTransmembraneDomains = gi.transmembrane_domains,
              gpiAminoAcids = gi.amino_acids,
              gpiReferences = references,
              gpiChromosomalLocation = gi.genomic_location
            );
            (res :: gis_rev, references ++ refs)
          }, ([], []), gis);

        var (comment, commentRefs, commentLigands) =
          fold_right(fun(gc, (comment, commentRefs, commentLigands)) {
            var parsedComment = parseOrError(gc);
            var (refIDs, ligandIDs) = RenderMarkup.collectIds(parsedComment);
            (MarkupAppend(parsedComment, comment),
             refIDs ++ commentRefs,
             ligandIDs ++ commentLigands)
          }, (MarkupEmpty, [], []), gpcrComments);

        ((giComments = comment, giEntries = reverse(gisRev)),
           giRefs ++ commentRefs, commentLigands)
      }

      sig mkDataTableBox : (String, [DataTableEntry]) ~%~> DataTableBox
      fun mkDataTableBox(name, rows) {
        (boxName = name, boxRows = rows)
      }

      sig mkDataTableEntry : (Markup, [(String, Markup)], [ReferenceID]) ~%~> DataTableEntry
      fun mkDataTableEntry(comment, data, references) {
        (entryComment = comment, entryData = data, entryReferences = references)
      }

      sig transformDataTableBox : forall a . (String, (a) ~%~> DataTableEntry, [a]) ~>
        (DataTableBox, [ReferenceID], [LigandID])
      fun transformDataTableBox(boxName, getRow, data) {
        var (rows_rev, refs, ligands) =
          fold_left(fun((rows_rev, refs, ligands), x) {
            var row = getRow(x);
            var (rowRefs, rowLigands) =
              RenderMarkup.collectAllIds(map(second, row.entryData));
            (row :: rows_rev, rowRefs ++ row.entryReferences ++ refs,
               rowLigands ++ ligands)
          }, ([], [], []), data);
        var box = (boxName = boxName, boxRows = reverse(rows_rev));
        (box, refs, ligands)
      }

      fun transformFunctionalAssays(fas) {
        transformDataTableBox("Functional Assays",
          fun(fa) {
            var references = fa.refs;
            var fa = fa.fa;
            mkDataTableEntry(parseOrError(fa.description),
              [("Species", parseOrError(resolveSpeciesLongName(fa.species_id, speciesMap))),
               ("Tissue", parseOrError(fa.tissue)),
               ("Response measured", parseOrError(fa.response_measured))], references)
          }, fas)
      }

      fun transformPhysiologicalFunctions(pfs) {
        transformDataTableBox("Physiological Functions",
          fun(pf) {
            var references = pf.refs;
            var pf = pf.pf;
            mkDataTableEntry(parseOrError(pf.description),
              [("Species", parseOrError(resolveSpeciesLongName(pf.species_id, speciesMap))),
               ("Tissue", parseOrError(pf.tissue))], references)
          }, pfs)
      }

      fun transformPhysiologicalConsequences(aes) {
        transformDataTableBox("Physiological Consequences of Altering Gene Expression",
          fun(ae) {
            var references = ae.refs;
            var ae = ae.ae;
            mkDataTableEntry(parseOrError(ae.description),
              [("Species", parseOrError(resolveSpeciesLongName(ae.species_id, speciesMap))),
               ("Tissue", parseOrError(ae.tissue)),
               ("Technique", parseOrError(ae.technique))], references)
          }, aes)
      }

      fun transformTissueDistribution(tds) {
        transformDataTableBox("Tissue Distribution",
          fun(td) {
            var references = td.refs;
            var td = td.td;
            mkDataTableEntry(parseOrError(td.tissues),
              [("Species", parseOrError(resolveSpeciesLongName(td.species_id, speciesMap))),
               ("Technique", parseOrError(td.technique))], references)
          }, tds)
      }

      fun transformDBLinks(dbls) {
        var dbIDs = map(fun(x) { x.database_id }, dbls);
        var dbPred = contains(dbIDs);
        var dbMap = query {
          for (db <-- Tables.tbl_database)
            where (dbPred(db.database_id))
              [(db.database_id, db)]
        };
        var groupedDBLs =
          groupBy(fun(dbl) { dbl.database_id }, dbls);

        var baseLinks =
          listConcatMap(fun((dbID, dbls)) {
            switch (lookup(dbID, dbMap)) {
              case Nothing ->
                debug("Invalid DB ID: " ^^ intToString(dbID));
                []
              case Just(db) ->
                var entries =
                  map(fun(dbl) { (dbl.species_id, dbl.placeholder,
                        replacePlaceholder(db.url, dbl.placeholder)) }, dbls);

                [(dbID = db.database_id,
                  dbName = db.name, dbURL = db.url, dbSpecialist = db.specialist,
                  dbPrefix = db."prefix",
                  dbEntries = entries)]
            }
          }, groupedDBLs);

        var extraLinks =
          listConcatMap(fun(dbl) {
            if (dbl.dbID == 15) {
              listConcatMap(fun((species, code, url)) {
                  if (speciesShortName(species) == "Hs") {
                    var dbURL = "http://www.proteinatlas.org/$PLACEHOLDER";
                    var url = replacePlaceholder(dbURL, code);
                    [(dbID = (-1), # hack
                      dbName = "Human Protein Atlas",
                      dbURL = dbURL,
                      dbSpecialist = false,
                      dbPrefix = "",
                      dbEntries = [(species, code, url)])]
                  } else {
                    []
                  }
              }, dbl.dbEntries)
            } else if (dbl.dbID == 3) {
              var dbURL = "https://www.genome.jp/dbget-bin/www_bget?$PLACEHOLDER";
              var entries = map(fun((species, code, url)) {
                var speciesShort = speciesShortName(species);
                var codePrefix =
                  if (speciesShort == "Hs") { "hsa:" }
                  else if (speciesShort == "Mm") { "mmu:" }
                  else if (speciesShort == "Rn") { "rno:" }
                  else { "" };
                var code = codePrefix ^^ code;
                var url = replacePlaceholder(dbURL, code);
                (species, code, url)
              }, dbl.dbEntries);
              [(dbID = (-1), # Hack
               dbName = "Kegg Gene",
               dbURL = dbURL,
               dbSpecialist = false,
               dbPrefix = "",
               dbEntries = entries)]
            } else {
              []
            }
          }, baseLinks);
        baseLinks ++ extraLinks
      }

      fun transformContributors(cs) {
        var sorted = sortBy(fun(c) { c.order }, cs);
        mkTBox("Contributors", false, map(
          fun(c) {
            var c = c.c;
            mkContributor(c.contributor_id, c.first_names ^^ " " ^^ c.surname,
                parseOrError(c.address), "")
          }, sorted))
      }

      fun transformCellTypeAssociations(ctas) {
        var (ctasRev, ctaRefs, ctaLigands) =
          fold_left(fun((ctasRev, ctaRefs, ctaLigands), x) {
            var comment = parseOrError(x.ctaComment);
            var cellType =
              (cellOntologyID = x.cellType.cellonto_id,
               cellOntologyName = x.cellType.name);
            var immuno =
              (immunoCTID = x.immuno.immuno_celltype_id, immunoCTName = x.immuno.term);
            var (commentRefs, commentLigands) = collectIds(comment);
            var allRefs = commentRefs ++ x.refs;
            var res =
              (ctaImmunoCelltype = immuno,
               ctaComments = comment,
               ctaCellOntologyType = cellType,
               ctaReferences = x.refs);
            (res :: ctasRev, allRefs ++ ctaRefs, commentLigands ++ ctaLigands)
          }, ([], [], []), ctas);
        (reverse(ctasRev), ctaRefs, ctaLigands)
      }

      fun transformImmunoProcessAssociations(ipas) {
        var (ipasRev, ipaRefs) =
          fold_left(fun((ipasRev, ipaRefs), x) {
            var goProcs =
              map(fun(g) {
                  (goProcessID = g.go.go_id,
                   goProcessComment = g.go.term,
                   goProcessEvidence = g.o2go.go_evidence)
              }, x.goProcs);
            (
             (ipImmunoProcess =
              (immunoProcessID = x.gtipProc.gtip_process_id,
               immunoProcessName = x.gtipProc.term),
             ipShowIEA = false,
             ipGoProcesses = goProcs,
             ipReferences = x.refs
            ) :: ipasRev, x.refs ++ ipaRefs)
          }, ([], []), ipas);
        (reverse(ipasRev), ipaRefs)
      }

      var dbLinks = transformDBLinks(raw.databaseLinks);

      var (variants, variantRefs, variantLigands) =
        transformVariants(raw.variants);

      var (pdbData, pdbRefs, pdbLigands) = transformPDBs(raw.pdbData);

      var interactions = transformInteractions(raw.interactions);
      var endogenousLigands = interactions.endogenous;

      var sortedInteractions = mkInteractionTables(interactions);
      var interactionRefs = interactions.references;

      var (transductions, transductionRefs, transductionLigands) =
        Transduction.transductionsForObject(objectId);

      var (functionalAssays, faRefs, faLigands) =
        transformFunctionalAssays(raw.functionalAssays);

      var (physiologicalFunctions, pfRefs, pfLigands) =
        transformPhysiologicalFunctions(raw.physiologicalFunctions);

      var (physiologicalConsequences, pcRefs, pcLigands) =
        transformPhysiologicalConsequences(raw.alteredExpressions);

      var (tissueDistribution, tdRefs, tdLigands) =
        transformTissueDistribution(raw.tissueDistribution);

      var (geneProteinInfo, gpiRefs, gpiLigands) =
        transformGeneProteinInfo(raw.gpcrComments, raw.geneInformation);

      var (cellTypeAssociations, ctaRefs, ctaLigands) =
        transformCellTypeAssociations(raw.cellTypeAssociations);

      var (immunoProcessAssociations, ipaRefs) =
        transformImmunoProcessAssociations(raw.immunoProcessAssociations);

      # TODO: A few more comment fields (grac_comments, structural_info_comments, quanternary_structure_comments)
      # still to be handled
      var (receptorComments, commentRefs, commentLigands) =
        transformReceptorComments(raw.receptorBasic, raw.comments,
            raw.immuno_comments, raw.malaria_comments);

      var refIDs =
        uniquify(
          variantRefs ++
          interactionRefs ++
          pdbRefs ++
          transductionRefs ++
          faRefs ++
          pfRefs ++
          pcRefs ++
          gpiRefs ++
          tdRefs ++
          ctaRefs ++
          ipaRefs ++
          commentRefs);

      var ligandIDs =
        uniquify(
          variantLigands ++
          pdbLigands ++
          transductionLigands ++
          faLigands ++
          pfLigands ++
          pcLigands ++
          gpiLigands ++
          tdLigands ++
          ctaLigands ++
          commentLigands);

      var ligandNames = Ligand.queryLigands(ligandIDs);

      var refs = Reference.mkReferenceData(Reference.queryReferences(refIDs));

      (objectId = objectId,
       objectName = parseOrError(raw.name),
       objectSynonyms = transformSynonyms(raw.synonyms),
       objectFamily = transformFamily(raw.family),
       objectGeneProteinInfo = geneProteinInfo,
       objectDatabaseLinks = dbLinks,
       objectAnnotationStatus = raw.annotationStatus,
       objectPDBData = pdbData,
       objectEndogenousLigands = endogenousLigands,
       objectSortedInteractions = sortedInteractions,
       objectTransductionMechanisms = transductions,
       objectVariants = variants,
       objectComments = receptorComments,
       objectLigandNames = ligandNames,
       objectShowReferences = false,
       objectReferences = refs,
       objectFunctionalAssays = functionalAssays,
       objectPhysiologicalFunctions = physiologicalFunctions,
       objectPhysiologicalConsequences = physiologicalConsequences,
       objectTissueDistribution = tissueDistribution,
       objectCellTypeAssociations = cellTypeAssociations,
       objectImmunoProcessAssociations = immunoProcessAssociations,
       objectSpeciesMap = speciesMap,
       objectContributors = transformContributors(raw.contributors))
    }

    switch(raw) {
      case [] -> Nothing
      case x :: _ -> Just(mkModel(x))
    }
  }

  switch(lookup("objectId", environment())) {
    case Just(id) -> getObjectInfo(stringToInt(id))
    case Nothing -> Nothing
  }
}

sig view : (Model) ~%~> HTML(Message)
fun view(model) {
  sig viewModel : (ObjectInfo) ~%~> HTML(Message)
  fun viewModel(objectInfo) {
    var a0 = MvuAttrs.empty;
    var h0 = MvuHTML.empty;

    fun speciesLongName(speciesId) {
      Species.resolveSpeciesLongName(speciesId, objectInfo.objectSpeciesMap)
    }

    fun speciesShortName(speciesId) {
      Species.resolveSpeciesShortName(speciesId, objectInfo.objectSpeciesMap)
    }

    sig renderM : (Markup) ~%~> HTML(Message)
    fun renderM(m) {
      RenderMarkup.renderMarkup(m,
          objectInfo.objectReferences,
          objectInfo.objectLigandNames)
    }

    fun renderKeyVal((key, val)) {
      tr(a0,
        td(class("key"), textNode(key ^^ ":")) +*
        td(class("value"), val))
    }

    var infoBox = {
    div(class("grid_16 alpha"),
      a(name("top"), MvuHTML.empty) +*
      h4(a0, renderM(objectInfo.objectName)) +*
      div(class("contentboxfullhelp"),
        div(class("textmiddle"),
          p(a0, b(a0, textNode("Target id: ")) +*
            textNode(intToString(objectInfo.objectId))) +*
          p(a0,
            b(a0, textNode("Nomenclature: ")) +*
            renderM(objectInfo.objectName)) +*
          p(a0,
            b(a0, textNode("Family: ")) +*
            a(href("/familyDisplay?familyId=" ^^ intToString(objectInfo.objectFamily.familyId)),
              renderM(objectInfo.objectFamily.familyName))) +*
          p(a0,
            b(a0, textNode("Annotation status: ")) +*
            renderAnnotationStatus(objectInfo.objectAnnotationStatus)))))
    };


    fun dataBox(header, cols, contents) {
      var cs = if (cols == 1) { MvuAttrs.empty } else { colSpan(cols) };
      table_(class("receptor_data_tables fullwidth"),
        thead(a0,
          tr(name("hotspot") +@ class("hotspot"),
            td(class("info category") +@ cs,
              textNode(header)))) +*
        tbody(name("toggle"), contents))
    }

    fun commentsBox(header, markup) {
      if (Parser.markupEmpty(markup)) {
        MvuHTML.empty
      } else {
        dataBox(header, 1,
          tr(a0,
          td(class("info"),
            renderM(markup))))
      }
    }

    var comments = objectInfo.objectComments;

    var geneProteinInfoBox = MvuHTML.empty;

    var synonymsBox = {
      if (objectInfo.objectSynonyms == []) { MvuHTML.empty } else {
        var renderedSynonyms = map(fun(m) { [renderM(m)] }, objectInfo.objectSynonyms);
        var separatedSynonyms = MvuHTML.concat(join([textNode(" | ")], renderedSynonyms));
        var row = tr(a0, td(class("info"), separatedSynonyms));
        dataBox("Previous and Unofficial Names", 1, row)
      }
    };

  # <a name="DatabaseLinks"></a>
  #<table class="receptor_data_tables fullwidth">
  #  <tr>
  #      <td class="info category" colspan="2">Database Links <a style="color:#CCCCCC;" href="JavaScript:callRef('helpPagePopup.jsp#DBLinks', 800, 400)" title="Click here for help"><img id="logo" style="vertical-align:baseline;" src="images/help_blue_small_transparent_bkground.png" alt="Click here for help"/></a></td>
  #  </tr>
  #      <tr>
  #          <td class="info" colspan="2" style="font-style: italic; font-weight: bold;">
  #              Specialist databases
  #          </td>
  #      </tr>
  #          <tr>
  #              <td class="info" style="min-width:250px;max-width:250px;width:250px;">
  #                  GPCRDB
  #              </td>
    var dbLinksBox = {
      fun renderDBLink(dbl) {
        fun renderLink((speciesID, code, url)) {
          a(href(url),
            textNode(dbl.dbPrefix ^^ code)) +*
          textNode(" (" ^^ speciesShortName(speciesID) ^^ ")")
        }
        var renderedLinks =
          MvuHTML.concat(
            join([textNode(", ")],
                  map(fun(l) { [renderLink(l)] }, dbl.dbEntries)));

        tr(a0,
          td(class("info") +@ style("min-width:250px;max-width:250px;width:250px;"),
            textNode(dbl.dbName)) +*
          td(class("info"), renderedLinks))
      }

      var (specialist, others) =
        partition(fun(dbl) { dbl.dbSpecialist }, objectInfo.objectDatabaseLinks);
      var specialist = sortBy(fun(db) { db.dbName }, specialist);
      var others = sortBy(fun(db) { db.dbName }, others);
      fun dbLinkHeader(text) {
        tr(a0,
          td(class("info") +@ colSpan(2) +@
            style("font-style: italic; font-weight: bold;"),
            textNode(text)))
      }
      var renderedSpecialists =
        if (specialist == []) { MvuHTML.empty } else {
          dbLinkHeader("Specialist Databases") +*
          MvuHTML.concatMap(renderDBLink, specialist)
        };
      var renderedOthers =
        if (others == []) { MvuHTML.empty } else {
          dbLinkHeader("Other Databases") +*
          MvuHTML.concatMap(renderDBLink, others)
        };

      a(name("DatabaseLinks"), h0) +*
      table_(class("receptor_data_tables fullwidth"),
        tr(a0,
          td(class("info category") +@ colSpan(2), textNode("Database Links"))) +*
        renderedSpecialists +*
        renderedOthers)

    };
    var pdbStructureBox = MvuHTML.empty;
    var endogenousLigandsBox = {
      fun renderSummary(els) {
        tr(class("info"),
            td(a0,
              a(href("/ligandDisplay?ligandId=" ^^ intToString(els.elsLigandID)),
                renderM(els.elsName))))
      }

      var renderedSummaries =
        MvuHTML.concatMap(renderSummary, objectInfo.objectEndogenousLigands);

      a(name("Endogenous"), h0) +*
      table_(class("receptor_data_tables fullwidth"),
        thead(a0,
          tr(a0,
            td(class("info category"), textNode("Natural/Endogenous Ligands")))) +*
        tbody(a0,
          renderedSummaries +*
          tr(class("info"),
            td(a0,
              b(a0, textNode("Comments: ")) +*
              renderM(objectInfo.objectComments.listComments)))))
    };

    var potencyOrderBox = MvuHTML.empty;

    var interactionsTables = {
      fun renderRow(i) {
        var imgCols = {
          var sizeCol = {
            switch(i.iLigandSize) {
              case Small ->
                boolImage(("/images/benzene.gif", true,
                      "Small molecule or natural product"))
              case Peptide ->
                boolImage(("/images/peptide_cartoon.png", true,
                      "Peptide or antibody"))
              case OtherSize ->
                boolImage(("", false, ""))
            }
          };

          var approvedCol = boolImage(("/images/approved.png", i.iLigandApproved, "Approved ligand"));
          var primaryCol = boolImage(("/images/primary.png", i.iLigandPrimary, "Primary interaction"));
          var selectiveCol =
            boolCol(i.iLigandSelective,
              a(href("/ligandInteractions?ligandId=" ^^
                  intToString(i.iLigandId) ^^ "&speciesId=" ^^ intToString(i.iLigandSpecies)), h0) +*
              img(src("/images/select.gif") +@ alt("Click here for species-specific selectivity table"), h0));
          var endogenousCol =
            boolImage(("/images/endogenous.gif", i.iLigandEndogenous,
                  "Ligand is endogenous in the given species"));
          var labelled = boolImage(("/images/probe.png", i.iLigandEndogenous, "Ligand is labelled"));
          var radioactive = boolImage(("/images/rad.gif", i.iLigandRadioactive, "Ligand is radioactive"));
          var hasPDB =
            boolImage(("/images/protein_structure_icon.png", i.iLigandPDB, "Ligand has a PDB structure"));
          var immuno =
            boolImage(("/images/immuno_ligand.png", i.iLigandImmuno, "Immunopharmacology Ligand"));

          MvuHTML.concat([sizeCol, approvedCol, primaryCol, selectiveCol, endogenousCol,
              labelled, radioactive, hasPDB, immuno])
        };

        var nameCol =
          td(a0,
            a(href("/ligandDisplay?ligandId=" ^^ intToString(i.iLigandId)), renderM(i.iLigandName)));

        var speciesCol =
          td(a0, textNode(speciesShortName(i.iLigandSpecies)));

        var actionCol =
          td(a0, textNode(i.iLigandAction));

        var affinityCol =
          td(a0, InteractionUtilities.displayAffinity(i.iLigandAffinity, false));

        var parameterCol =
          td(a0, textNode(i.iLigandAffinity.affinityUnits));

        var referenceCol =
          td(a0, Reference.renderCitationList(i.iLigandReferences, objectInfo.objectReferences));

        tr(class("info"),
          nameCol +*
          imgCols +*
          speciesCol +*
          actionCol +*
          affinityCol +*
          parameterCol +*
          referenceCol)
      }

      fun renderReceptorTable((tbl, label, commentsHeader, comments)) {
        if (DataTable.getTableData(tbl) == []) {
          MvuHTML.empty
        } else {
          dataBox(label, 1,
            a(name(label), h0) +*
            tr(a0, td(class("table_container") +@ style("border-style:solid solid none solid;"),
            DataTable.renderTable(tbl, renderRow)))) +*
          commentsBox(commentsHeader, comments)
        }
      }

      fun renderChannelTable((tbl, label, commentsHeader, comments)) {
        MvuHTML.empty # For now.
      }

      var si = objectInfo.objectSortedInteractions;
      var oc = objectInfo.objectComments;
      var receptorTables = [
        (si.agonists, "Agonists", "Agonist Comments", oc.agonistsComments),
        (si.antagonists, "Antagonists", "Antagonist Comments", oc.antagonistsComments),
        (si.allostericModulators, "Allosteric Modulators",
         "Allosteric Modulator Comments", oc.allostericModulatorsComments),
        (si.subunitSpecific, "Subunit-specific",
         "Subunit-specific Comments", MarkupEmpty)
      ];

      var channelTables = [
        (si.activators, "Activators", "Activator Comments", oc.activatorsComments),
        (si.inhibitors, "Inhibitors", "Inhibitor Comments", oc.inhibitorsComments),
        (si.channelBlockers, "Channel Blockers", "Channel Blocker Comments", oc.channelBlockersComments),
        (si.gatingInhibitors, "Gating Inhibitors",
         "Gating Inhibitor Comments", oc.gatingInhibitorsComments)
      ];

      MvuHTML.concatMap(renderReceptorTable, receptorTables) +*
      MvuHTML.concatMap(renderChannelTable, channelTables)

    };

    var immunoCommentsBox =
      commentsBox("Immunopharmacology Comments", comments.immunoComments);
    var malariaCommentsBox =
      commentsBox("Malaria Comments", comments.malariaComments);

    var transductionMechanismsBoxes = {
      var tms = objectInfo.objectTransductionMechanisms;
      if (tms == []) {
        MvuHTML.empty
      } else {
        var (primary, secondary) = partition(fun(t) { not(t.tSecondary) }, tms);
        fun renderTransduction(t) {
          fun renderMarkups(ms) {
            MvuHTML.concatMap(fun(m) { p(a0, renderM(m)) }, ms)
          }
          var commentsRow =
            if (Parser.markupEmpty(t.tComments)) { MvuHTML.empty } else {
              tr(a0,
                td(colSpan(2) +@ class("info"),
                  textNode("Comments: ") +*
                  renderM(t.tComments)))
            };
          var referencesRow =
            if (t.tReferences == []) { MvuHTML.empty } else {
              tr(a0,
                td(colSpan(2) +@ class("info"),
                  textNode("References: ") +*
                  Reference.renderCitationList(t.tReferences, objectInfo.objectReferences)))
            };

          tr(a0,
            td(class("info"),
              renderMarkups(t.tTransducers)) +*
            td(class("info"),
              renderMarkups(t.tEffectors))) +*
          commentsRow +*
          referencesRow
        }

        var primaryBox = if (primary == []) { MvuHTML.empty } else {
          dataBox("Primary Transduction Mechanisms", 2,
              MvuHTML.concatMap(renderTransduction, primary))
        };

        var secondaryBox = if (secondary == []) { MvuHTML.empty } else {
          dataBox("Secondary Transduction Mechanisms", 2,
              MvuHTML.concatMap(renderTransduction, secondary))
        };

        primaryBox +* secondaryBox
      }
    };

    fun renderDataBox(box) {
      fun renderDataRow(row) {

        fun renderDatum((k, v)) {
          tr(a0,
            td(class("key"), textNode(k)) +*
            td(class("value"), renderM(v)))
        }

        var renderedData = MvuHTML.concatMap(renderDatum, row.entryData);
        var referencesRow =
          if (row.entryReferences == []) {
            MvuHTML.empty
          } else {
            tr(a0,
              td(class("key"), textNode("References")) +*
              td(class("value"),
                Reference.renderCitationList(row.entryReferences,
                  objectInfo.objectReferences)))
          };

        tr(a0,
          td(class("info"),
            table_(class("inner_receptor_data_tables"),
              tr(a0,
                td(class("description"), renderM(row.entryComment))) +*
              tr(a0,
                td(a0,
                  table_(class("inner_receptor_data_tables"),
                    renderedData +* referencesRow))))))
      }

      var renderedRows = MvuHTML.concatMap(renderDataRow, box.boxRows);

      a(name(box.boxName), h0) +*
      table_(class("receptor_data_tables fullwidth"),
        thead(a0,
          tr(name("hotspot") +@ class("hotspot"),
            td(class("info category"), textNode(box.boxName)))) +*
        tbody(name("toggle"), renderedRows))
    }

    var tissueDistributionBox =
      renderDataBox(objectInfo.objectTissueDistribution);
    var functionalAssaysBox =
      renderDataBox(objectInfo.objectFunctionalAssays);
    var physiologicalFunctionsBox =
      renderDataBox(objectInfo.objectPhysiologicalFunctions);
    var physiologicalConsequencesBox =
      renderDataBox(objectInfo.objectPhysiologicalConsequences);
    var phenotypesBox = MvuHTML.empty;
    var generalCommentsBox =
      commentsBox("General Comments", comments.generalComments);
    var contributorsBox = MvuHTML.empty;

    var pdbStructureBox = {
      fun renderPDBRow(pdb) {

        fun renderPDBDataRow(propName, html) {
          tr(a0,
            td(class("key") +@ style("width:100px;"), textNode(propName)) +*
            td(class("value"), html))
        }
        var descRow =
          renderPDBDataRow("Description:", renderM(pdb.pdbLigandDescription));

        var pdbIDRow =
          renderPDBDataRow("PDB Id:",
              a(href("http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=" ^^ pdb.pdbCode) +@
                title("RCSB PDB: an information portal to biological macromolecular structures"),
                textNode(pdb.pdbCode)));

        var ligandRow =
          renderPDBDataRow("Ligand:",
              a(href("/ligandDisplay?ligandId=" ^^ intToString(pdb.pdbLigandId)),
                renderM(pdb.pdbLigandName)));

        var resolutionRow =
          renderPDBDataRow("Resolution:", textNode(floatToString(pdb.pdbResolution)));

        var speciesRow =
          renderPDBDataRow("Species:", textNode(speciesLongName(pdb.pdbSpeciesId)));

        var referencesRow =
          renderPDBDataRow("References:",
              Reference.renderCitationList(pdb.pdbReferences,
                objectInfo.objectReferences));

        tr(a0,
          td(class("info") +@ align("center") +@ valign("center"),
            a(style("color:white;") +@
              href("http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=" ^^ pdb.pdbCode) +@
              title("Image of receptor 3D structure from RCSB PDB") +@ target("_blank"),
            img(src("http://www.rcsb.org/pdb/images/" ^^ pdb.pdbCode ^^ "_bio_r_500.jpg") +@
              height("200") +@ width("200") +@ alt("Image of receptor 3D structure from RCSB PDB"), h0))) +*
          td(class("info") +@ valign("top"),
            table_(class("inner_receptor_data_tables"),
              descRow +*
              pdbIDRow +*
              ligandRow +*
              resolutionRow +*
              speciesRow +*
              referencesRow)))
      }

      var pdbRows = MvuHTML.concatMap(renderPDBRow, objectInfo.objectPDBData);

      if (objectInfo.objectPDBData == []) {
        MvuHTML.empty
      } else {
        a(name("PDBStructures"), h0) +*
        table_(class("receptor_data_tables fullwidth"),
          thead(a0,
            tr(name("hotspot") +@ class("hotspot"),
              td(class("info category") +@ colSpan(2),
                textNode("Selected 3D Structures")))) +*
          tbody(name("toggle"), pdbRows))
      }
    };


    var geneProteinInfoBox = {
      var gi = objectInfo.objectGeneProteinInfo;
      var headings = ["Species", "TM", "AA", "Chromosomal Location", "Gene Symbol",
          "Gene Name", "Reference"];
      fun renderHeading(h) { td(class("info heading"), textNode(h)) }
      var renderedHeadings = MvuHTML.concatMap(renderHeading, headings);

      fun renderRow(gpi) {
        fun renderData(val) {
          td(class("info centre"), val)
        }
        var data = [
          textNode(speciesLongName(gpi.gpiSpeciesID)),
          textNode(intToString(gpi.gpiTransmembraneDomains)),
          textNode(intToString(gpi.gpiAminoAcids)),
          textNode(gpi.gpiChromosomalLocation),
          textNode(gpi.gpiShortName),
          renderM(gpi.gpiName),
          Reference.renderCitationList(gpi.gpiReferences,
              objectInfo.objectReferences)
        ];
        tr(a0, MvuHTML.concatMap(renderData, data))
      }
      var renderedRows = MvuHTML.concatMap(renderRow, gi.giEntries);

      a(name("StructuralInfo"), h0) +*
      table_(class("receptor_data_tables fullwidth"),
        thead(a0,
          tr(name("hotspot") +@ class("hotspot"),
            td(class("info category") +@ colSpan(7),
              textNode("Gene and Protein Information")))) +*
        tbody(name("toggle"),
          tr(a0,
            td(class("info") +@ colSpan(7), renderM(gi.giComments))) +*
          tr(a0, renderedHeadings) +*
          renderedRows))
    };

    var cellTypeAssociationsBox = {
      fun renderCTA(cta) {
        var ct = cta.ctaImmunoCelltype;
        var cto = cta.ctaCellOntologyType;
        var cellTypeContent =
          a(href("/objectCelltypeAssocList?immCellType=" ^^
                intToString(ct.immunoCTID)), textNode(ct.immunoCTName));
        var cellOntologyContent =
          textNode(cto.cellOntologyName ^^ " (" ^^ cto.cellOntologyID ^^ ")");
        var referencesRow =
          if (cta.ctaReferences == []) { MvuHTML.empty } else {
            renderKeyVal(("References",
                Reference.renderCitationList(cta.ctaReferences,
                  objectInfo.objectReferences)))
          };
        var rows =
          [("Immuno Cell Type", cellTypeContent),
           ("Cell Ontology Term", cellOntologyContent),
           ("Comment", renderM(cta.ctaComments))];
        var renderedRows = MvuHTML.concat(map(renderKeyVal, rows) ++ [referencesRow]);
        tr(a0,
          td(class("info"),
            table_(class("inner_receptor_data_tables"), renderedRows)))
      }

      var renderedCTAs =
        MvuHTML.concatMap(renderCTA, objectInfo.objectCellTypeAssociations);

      a(name("Celltypes"), h0) +*
      table_(class("receptor_data_tables fullwidth"),
        tr(name("hotspot") +@ class("hotspot"),
          td(class("info category"), textNode("Cell Type Associations"))) +*
        renderedCTAs)
    };

   #<a name="Processes"></a>
   #<table class="receptor_data_tables fullwidth">
   #  <tr name="hotspot" class="hotspot">
   #    <td class="info category">Immuno Process Associations</td>
   #  </tr>
   #    <tr>
   #      <td class="info">
   #        <table class="inner_receptor_data_tables" style="width:70%;">
   #          <tr>
   #            <td class="key">Immuno Process:&nbsp;</td>
   #            <td class="value"><a href="ObjectImmProcessListForward?immprocess=3">Antigen presentation</a></td>
   #          </tr>
   #          <tr>
   #            <td class="key">GO Annotations:&nbsp;</td>
   #            <td class="value">
   #                Associated to 1 GO processes
   #            </td>
   #          </tr>
   #          <tr>
   #            <td></td>
   #            <td>
   #              <table id="go" class="tablesorter inner_receptor_data_tables">
   #                    <tr>
   #                      <td style="width:20%;">GO:0006909</td>
   #                      <td style="width:70%;">phagocytosis</td>
   #                      <td style="width:10%;">TAS</td>
   #                    </tr>
   #                    <tr>
   #                      <td style="width:20%;"><a href="" title="Toggle GO associations with IEA evidence" class="toggle"><div class="arrow"></div></a></td>
   #                      <td colspan="2" style="width:800%;"><i>click arrow to show/hide IEA associations</i></td>
   #                    </tr>
   #                    <tr class="tablesorter-childRow">
   #                      <td style="width:20%;">GO:0002548</td>
   #                      <td style="width:70%;">monocyte chemotaxis</td>
   #                      <td style="width:10%;">IEA</td>
   #                    </tr>
   #              </table>
   #            </td>
   #          </tr>
   #        </table>
   #      </td>
   #    </tr>

    var immunoProcessAssociationsBox = {
      fun renderProcess(proc) {
        var iProc = proc.ipImmunoProcess;
        var goProcCount = length(proc.ipGoProcesses);

        var (ieaProcs, otherProcs) =
          partition(fun(p) { p.goProcessEvidence == "IEA" }, proc.ipGoProcesses);

        var goAnnotationsCountRow = {
          var content = {
            var suffix =
              if (otherProcs == []) {
                textNode(", IEA only")
              } else { MvuHTML.empty };
            textNode("Associated to " ^^ intToString(goProcCount) ^^ " processes") +*
            suffix
          };
          renderKeyVal(("Go Annotations", content))
        };

        fun renderGoProcess(goProc) {
          tr(a0,
            td(style("width:20%;"), textNode(goProc.goProcessID)) +*
            td(style("width:70%;"), textNode(goProc.goProcessComment)) +*
            td(style("width:10%;"), textNode(goProc.goProcessEvidence)))
        }

        var goAnnotations = MvuHTML.concatMap(renderGoProcess, otherProcs);

        var toggleGoAnnotationsRow = {
          var clickAttr = onClick(fun() { ToggleShowIEA(proc.ipImmunoProcess.immunoProcessID) });
          var arrow = {
            var arrowClass = if (proc.ipShowIEA) { "arrow up" } else { "arrow" };
            div(class(arrowClass) +@ clickAttr, h0)
          };

          tr(a0,
            td(style("width:20%;"),
              a(title("Toggle GO associations with IEA evidence") +@ class("toggle"),
                arrow)) +*
            td(colSpan(2) +@ style("width:800%;font-style:italic;"),
                textNode("click arrow to show/hide IEA associations")))
        };

        var ieaAnnotations =
          if (proc.ipShowIEA) {
            MvuHTML.concatMap(renderGoProcess, ieaProcs)
          } else {
            MvuHTML.empty
          };

        tr(a0,
          td(class("info"),
            table_(class("inner_receptor_data_tables") +@ style("width:70%"),
              renderKeyVal(("Immuno Process",
                a(href("/immProcessList?immprocess=" ^^ intToString(iProc.immunoProcessID)),
                  textNode(iProc.immunoProcessName)))) +*
              goAnnotationsCountRow +*
              tr(a0,
                td(a0, h0) +*
                table_(id("go") +@ class("tablesorter inner_receptor_data_tables"),
                  goAnnotations +*
                  toggleGoAnnotationsRow +*
                  ieaAnnotations)))))
      }

      var procs = objectInfo.objectImmunoProcessAssociations;
      if (procs == []) {
        MvuHTML.empty
      } else {
        var renderedProcs = MvuHTML.concatMap(renderProcess, procs);
        a(name("Processes"), MvuHTML.empty) +*
        table_(class("receptor_data_tables fullwidth"),
          tr(name("hotspot") +@ class("hotspot"),
            td(class("info category"), textNode("Immuno Process Associations"))) +*
          renderedProcs)
      }
    };

    var dataBoxes =
      div(class("grid_16 alpha"),
        div(class("contentboxfullhelp"),
          div(class("data_tables_container"),
            geneProteinInfoBox +*
            synonymsBox +*
            dbLinksBox +*
            pdbStructureBox +*
            endogenousLigandsBox +*
            potencyOrderBox +*
            interactionsTables +*
            immunoCommentsBox +*
            malariaCommentsBox +*
            cellTypeAssociationsBox +*
            immunoProcessAssociationsBox +*
            transductionMechanismsBoxes +*
            tissueDistributionBox +*
            functionalAssaysBox +*
            physiologicalFunctionsBox +*
            physiologicalConsequencesBox +*
            phenotypesBox +*
            generalCommentsBox)));

    var referencesBox =
      Reference.renderReferencesBox(
          objectInfo.objectShowReferences,
          objectInfo.objectReferences,
          fun() { ToggleReferences });

    var contributorsBox =
      ToggleBox.showBox(objectInfo.objectContributors, ToggleContributors,
        Contributor.renderContributors);

    div(class("grid_12"),
        infoBox +*
        dataBoxes +*
        referencesBox +*
        contributorsBox)
  }

  switch(model) {
    case Just(objectInfo) -> viewModel(objectInfo)
    case Nothing -> textNode("Invalid object ID.")
  }
}

# TODO
sig updt : (Message, Model) ~%~> Model
fun updt(msg, model) {
  fun updtOI(objectInfo) {

    fun toggleIEA(procID) {
      var ipas = objectInfo.objectImmunoProcessAssociations;
      map(fun(x) { if (x.ipImmunoProcess.immunoProcessID == procID) {
            (x with ipShowIEA = not(x.ipShowIEA))
          } else {
            x
          }
        }, ipas)
    }

    switch(msg) {
      case ToggleReferences ->
        (objectInfo with
          objectShowReferences=not(objectInfo.objectShowReferences))
      case ToggleContributors ->
        (objectInfo with
          objectContributors = toggleBox(objectInfo.objectContributors))
      case ToggleShowIEA(procID) ->
        (objectInfo with
          objectImmunoProcessAssociations=toggleIEA(procID))
      case SortInteractionTable(tableTy, colName, dir) ->
        var osi = objectInfo.objectSortedInteractions;
        (objectInfo with
          objectSortedInteractions =
            switch(tableTy) {
              case AgonistsTable ->
                (osi with agonists = DataTable.updateSortStatus(osi.agonists, colName, dir))
              case AntagonistsTable ->
                (osi with antagonists = DataTable.updateSortStatus(osi.antagonists, colName, dir))
              case AllostericModulatorsTable ->
                (osi with allostericModulators =
                   DataTable.updateSortStatus(osi.allostericModulators, colName, dir))
              case ActivatorsTable ->
                (osi with activators = DataTable.updateSortStatus(osi.activators, colName, dir))
              case InhibitorsTable ->
                (osi with inhibitors = DataTable.updateSortStatus(osi.inhibitors, colName, dir))
              case ChannelBlockersTable ->
                (osi with channelBlockers =
                   DataTable.updateSortStatus(osi.channelBlockers, colName, dir))
              case GatingInhibitorsTable ->
                (osi with gatingInhibitors =
                   DataTable.updateSortStatus(osi.gatingInhibitors, colName, dir))
              case SubunitSpecificTable ->
                (osi with subunitSpecific =
                   DataTable.updateSortStatus(osi.subunitSpecific, colName, dir))
            })
      case _ -> objectInfo
    }
  }

  switch(model) {
    case Just(objectInfo) -> Just(updtOI(objectInfo))
    case Nothing -> Nothing
  }
}

fun mainPage() {
  var initialModel = getInitialModel();
  runSimple("vdom_placeholder", initialModel, view, updt);
  template("Object Display")
}
