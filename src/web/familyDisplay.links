open import Reference;
open import Mvu;
open import MvuHTML;
open import MvuAttrs;
open import MvuEvents;
open import Tables;
open import Template;
open import RenderMarkup;
open import Parser;
open import Utility;
open import InteractionUtilities;
open import Ligand;
open import Species;
open import ToggleBox;
open import Contributor;

typename ReferenceId = Int;
typename ReferenceNumber = Int;


typename ExternalRef = (
  refId: String,
  refSpeciesName: String,
  refUrl: String
);


typename Synonym = (synonymName: Markup, synonymOrder: Int, synonymReferences: [ReferenceId]);

var emptyER = (refId="", refSpeciesName="", refUrl="");

typename GeneRef = (geneName: Markup, geneSpeciesID: Int); # TODO: URL

typename ObjectSummary = (
   objectId: Int,
   objectNomenclature: Markup,
   objectSynonyms: [Synonym],
   objectGenes: [GeneRef],
   objectEnsemblRefs: [ExternalRef],
   objectUniprotRefs: [ExternalRef],
   objectPrincipalTransductions: [Markup],
   objectInteractions: [Interaction],
   # Need to sort in-memory, since `orderby` not supported w/ shredding
   objectDisplayOrder: Int
  );

typename ObjectBox =
  (objectSummary: ObjectSummary, objectBoxVisible: Bool);

# BUG (hacky workaround): Type arguments don't appear to be renamed
typename Reference = Reference;
typename Markup = Parser.Markup;

typename Model =
  Maybe((familyId: Int,
         familyName: String,
         familyType: String,
         overview: ContentBox(Markup),
         objects: ContentBox([ObjectBox]),
         comments: ContentBox(Markup),
         furtherReading: ContentBox([Reference]),
         showReferences: Bool,
         references: [(ReferenceId, (ReferenceNumber, Reference))],
         contributors: ContentBox(Contributors),
         ligandNames: [(LigandId, LigandName)],
         speciesMap: SpeciesMap
        ));

typename Message = [|
    ToggleOverview | ToggleObjects | ToggleComments
  | ToggleFurtherReading | ToggleReferences | ToggleContributors
  | SetAllVisibilities:Bool
  | ToggleObjectSummary:Int
|];

fun withModel(model, f) {
  switch(model) {
    case Just(model) -> Just(f(model))
    case Nothing -> Nothing
  }
}

fun setBoxVisibilities(visible, model) {
  fun sbv(box) { setBoxVisibility(box, visible) }

  (model with
    overview=sbv(model.overview),
    objects=sbv(model.objects),
    comments=sbv(model.comments),
    furtherReading=sbv(model.furtherReading),
    showReferences=visible,
    contributors=sbv(model.contributors))
}

fun toggleObject(objectBox, id) {
  var contents = boxContents(objectBox);

  var newContents =
    map(fun(objectBox) {
      if (objectBox.objectSummary.objectId == id) {
        (objectBox with objectBoxVisible = not(objectBox.objectBoxVisible))
      } else {
        objectBox
      }
    }, contents);
  setContents(objectBox, newContents)
}

fun updt(msg, model) {
  withModel(model, fun(model) {
      switch(msg) {
        case ToggleOverview ->
          (model with overview=toggleBox(model.overview))
        case ToggleObjects ->
          (model with objects=toggleBox(model.objects))
        case ToggleComments ->
          (model with comments=toggleBox(model.comments))
        case ToggleFurtherReading ->
          (model with furtherReading=toggleBox(model.furtherReading))
        case ToggleReferences ->
          (model with showReferences=not(model.showReferences))
        case ToggleContributors ->
          (model with contributors=toggleBox(model.contributors))
        case SetAllVisibilities(vis) -> setBoxVisibilities(vis, model)
        case ToggleObjectSummary(id) ->
          (model with objects=toggleObject(model.objects, id))
      }
  })
}

sig view : (Model) ~%~> HTML(Message)
fun view(model) {
  var a0 = MvuAttrs.empty;
  var h0 = MvuHTML.empty;

  fun viewModel(model) {
    fun renderM(markup) {
        RenderMarkup.renderMarkup(markup,
          model.references, model.ligandNames)
    }

    # headerBox: Header information for given family
    var headerBox =
      div(class("grid_16 alpha"),
        a(name("top"), h0) +*
        div(class("contentboxfull"),
          h2(style("margin-top: 0px;"), textNode(model.familyName)) +*
          div(class("textright"),
            p(style("font-weight:normal;font-size:90%;"),
              textNode("Unless otherwise stated all data on this page refer to the human proteins. ") +*
              textNode("Gene information is provided for human (Hs), mouse (Mm) and rat (Rn).")) +*
            div(style("text-align:right;padding: 0px 5px 5px 0x;"),
              button(onClick(fun() { SetAllVisibilities(true) }), textNode("Expand all sections")) +*
              button(onClick(fun() { SetAllVisibilities(false) }), textNode("Collapse all sections"))
            )
          )));

    fun displayOverview(overviewMarkup) {
      p(class("grac_text"), renderM(overviewMarkup))
    }

    fun displayObjects(boxes) {

      fun displayObjectBox(box) {
        var summary = box.objectSummary;
        var toggleMsg = ToggleObjectSummary(summary.objectId);
        var showHideLink =
          if(box.objectBoxVisible) {
            a(onClick(fun() { toggleMsg }),
              span(class("object_summary_link"), textNode("  Hide summary")))
          } else {
            a(onClick(fun() { toggleMsg }),
              small(class("object_summary_link"), textNode("  Show summary")))
          };

        fun mkRow(name, contents) {
          table_(class("grac_data_table fullwidth"),
            tr(a0,
              td(class("grac_category_simple"), textNode(name)) +*
              td(class("grac_info_simple"), contents)))
        }

        # In the case that an interaction is with a labelled ligand, it is
        # only classed as labelled. Similarly, if the interaction is endogenous,
        # it is only classed as endogenous.
        fun splitInteractions(interactions) {
          fun go(is, labelled, endogenous, selective, neither) {
            switch(is) {
              case [] -> (labelled, endogenous, selective, neither)
              case x :: is ->
              if (x.interactionLigand.labelled) {
                go(is, x :: labelled, endogenous, selective, neither)
              } else if (x.endogenous) {
                go(is, labelled, x :: endogenous, selective, neither)
              } else if (x.selectivity == "Selective") {
                go(is, labelled, endogenous, x :: selective, neither)
              } else {
                go(is, labelled, endogenous, selective, x :: neither)
              }
            }
          }

          var (labelled, endogenous, selective, neither) = go(interactions, [], [], [], []);
          (reverse(labelled), reverse(endogenous), reverse(selective), reverse(neither))
        }

        var allAgonists =
          filter(fun(i) { i.interactionType == "Agonist" }, summary.objectInteractions);
        var allAntagonists =
          filter(fun(i) { i.interactionType == "Antagonist" }, summary.objectInteractions);
        var allostericModulators =
          filter(fun(i) { i.interactionType == "Allosteric modulator" }, summary.objectInteractions);

        var (labelledAgonists, endogenousAgonists,
            selectiveAgonists, otherAgonists) = splitInteractions(allAgonists);
        var (labelledAntagonists, endogenousAntagonists,
            selectiveAntagonists, otherAntagonists) = splitInteractions(allAntagonists);

        var labelledLigands = labelledAgonists ++ labelledAntagonists;

        fun showInteraction(x) {
          var interactionActionNode =
            if (not(x.interactionAction == "Agonist"
                  || x.interactionAction == "Antagonist")) {
              textNode(" (" ^^ x.interactionAction ^^ ")")
            } else { MvuHTML.empty };
          var speciesName = resolveSpeciesLongName(x.speciesID, model.speciesMap);
          var speciesNode =
            if (speciesName <> "Human") {
              textNode(" - " ^^ speciesName)
            } else {
              MvuHTML.empty
            };

          var affinityNode = {
            InteractionUtilities.displayAffinity(x.affinity, true)
          };

          var citationsNode =
            textNode(" ") +*
            renderCitationList(x.references, model.references);

          a(href("ligandDisplay?ligandId=" ^^
              intToString(x.ligandID)),
              unescapedTextNode(x.interactionLigand.name)) +*
          interactionActionNode +*
          affinityNode +*
          citationsNode +*
          speciesNode
        }

        fun mkInteractionRow(interactionType, interactions) {
          if (listEmpty(interactions)) {
            MvuHTML.empty
          } else {
            var renderedInteractions =
              MvuHTML.concat(map(fun(i) { tr(MvuAttrs.empty,
                    td(class("grac_info_simple"), showInteraction(i))) }, interactions));
            var interactionTable =
              table_(class("grac_inner_table"), renderedInteractions);

            mkRow(interactionType, interactionTable)
          }
        }

        var ptRow =
          if (length(summary.objectPrincipalTransductions) > 0) {
              mkRow("Principal transduction",
                MvuHTML.concat(map(fun(x) { renderM(x) },
                  summary.objectPrincipalTransductions)))
          } else {
            MvuHTML.empty
          };



        fun showSummary() {
          if (box.objectBoxVisible) {
            var synonyms = sortBy(fun(syn) { syn.synonymOrder }, summary.objectSynonyms);
            var synonyms = map(fun(x) {
                var citationNode =
                  if (length(x.synonymReferences) > 0) {
                    textNode(" ") +* renderCitationList(x.synonymReferences,
                        model.references)
                  } else { MvuHTML.empty };
                [renderM(x.synonymName) +* citationNode]
            }, synonyms);
            var separatedSynonyms = MvuHTML.concat(join([textNode(" | ")], synonyms));
            var genes = map(fun(gene) {
                var name = gene.geneName;
                var id = gene.geneSpeciesID;
              [renderM(name) +* textNode("(" ^^ resolveSpeciesShortName(id, model.speciesMap) ^^ ")")]
              }, summary.objectGenes);
            var separatedGenes = MvuHTML.concat(join([textNode(", ")], genes));

            hr(class("divider_dashed"), MvuHTML.empty) +*
            mkRow("Target Id", textNode(intToString(summary.objectId))) +*
            mkRow("Nomenclature", renderM(summary.objectNomenclature)) +*
            mkRow("Previous and unofficial names", separatedSynonyms) +*
            mkRow("Genes", separatedGenes) +*
            ptRow +*
            mkInteractionRow("Endogenous agonists", endogenousAgonists) +*
            mkInteractionRow("Endogenous antagonists", endogenousAntagonists) +*
            mkInteractionRow("Agonists", otherAgonists) +*
            mkInteractionRow("Selective agonists", selectiveAgonists) +*
            mkInteractionRow("Antagonists", otherAntagonists) +*
            mkInteractionRow("Selective antagonists", selectiveAntagonists) +*
            mkInteractionRow("Allosteric modulators", allostericModulators) +*
            mkInteractionRow("Labelled ligands", labelledLigands)
          } else {
            MvuHTML.empty
          }
        }

        tr(a0,
          td(class("grac_info"),
            p(class("grac_heading split_para"),
              renderM(box.objectSummary.objectNomenclature) +*
              span(class("cgtp"), textNode(" C")) +*
              showHideLink +*
              span(class("split_para_right_text detailed_view_link"),
                a(href("objectDisplay?objectId=" ^^ intToString(summary.objectId)),
                  textNode("More detailed page") +*
                  img(attr("src", "/images/go.jpg"), MvuHTML.empty)))) +*
              showSummary()
            ))
      }

      div(class("data_tables_container"),
        table_(class("receptor_data_tables fullwidth"),
          tbody(a0,
            MvuHTML.concat(
              map(fun(x) { displayObjectBox(x) }, boxes)))))
    }

    fun displayComments(commentMarkup) {
      p(class("grac_text"), renderM(commentMarkup))
    }

    fun displayFurtherReading(refs) {
      p(a0, textNode("* Key further reading is highlighted with an asterisk")) +*
      MvuHTML.concat(map(fun(x) {
        var prefixNode = if(x.isKey) { textNode("* ") } else { MvuHTML.empty };
        renderReference(prefixNode, x)
      }, refs))
    }

    var referencesBox =
      Reference.renderReferencesBox(
          model.showReferences,
          model.references,
          fun() { ToggleReferences });

    # (tboxName: String,  tboxVisible: Bool, contents: a);
    headerBox +*
    showBox(model.overview, ToggleOverview, displayOverview) +*
    showBox(model.objects, ToggleObjects, displayObjects) +*
    showBox(model.comments, ToggleComments, displayComments) +*
    showBox(model.furtherReading, ToggleFurtherReading, displayFurtherReading) +*
    referencesBox +*
    showBox(model.contributors, ToggleContributors, displayContributors)
  }

  switch(model) {
    case Just(model) -> viewModel(model)
    case Nothing -> p(a0, textNode("Invalid family ID."))
  }
}

fun formatObjectName(dbName) {
  switch (dbName) {
    case "gpcr" -> "Receptors"
    case "nhr" -> "Receptors"
    case "other_protein" -> "Targets"
    case "grouping" -> "Targets" # I think we need to handle this differently
    case "ligand" -> "Ligands"
    case "other_ic" -> "Channels and Subunits"
    case "enzyme" -> "Enzymes"
    case "transporter" -> "Transporters"
    case "vgic" -> "Channels and Subunits"
    case "lgic" -> "Channels and Subunits"
    case "catalytic_receptor" -> "Receptors"
    case _ -> "Targets"
  }
}


sig getInitialModel : () ~%~> Model
fun getInitialModel() {

  fun getFamilyInfo(familyId) {
    # First, grab the basic information.
    var basicInfo =
      query nested {
        for (f <-- Tables.family)
          where (f.family_id == familyId)
          [(name = f.name, type = f.type,
              grac_texts =
                for (g <-- Tables.grac_family_text)
                  where (g.family_id == familyId)
                  [g])]
      };

    switch(basicInfo) {
      case [] -> Nothing
      case x ::_ ->
        var name = x.name;
        var type = x.type;
        var (overview, comments) =
          switch (x.grac_texts) {
            case [] -> ("", "")
            case y :: _ -> (y.overview, y.comments)
          };
        # At this point, we need to populate the rest of the data
        # (further reading, contributors, and interaction data).
        ### Further reading
        var furtherReading =
          query nested {
            for (fr <-- Tables.grac_further_reading)
              where (fr.family_id == familyId)
              for (ref <-- Tables.reference)
                where (ref.reference_id == fr.reference_id)
                [
                  (makeReference(ref.reference_id,
                     ref.type, ref.title, ref.article_title, ref.year,
                     ref.volume, ref.issue, ref.pages, ref.publisher,
                     ref.publisher_address, ref.editors, ref.pubmed_id,
                     ref.isbn, ref.authors, fr.key_ref))
                ]
          };
        var furtherReading =
          sortBy(fun(ref) { ref.authors }, furtherReading);

        ### Contributors
        fun getContributors(t) {
          query nested {
            for (contrib <-- Tables.contributor_copy)
              where (contrib.contributor_id == t.contributor_id)
              orderby (-(t.display_order))
              [(resultId=contrib.contributor_id,
                resultName=(contrib.first_names ^^ " " ^^ contrib.surname),
                resultAddress=contrib.address,
                resultRole=t.role)]
          }
        }

        var subcommitteeMembers =
          query nested {
            for (t <-- Tables.subcommittee)
              where (t.family_id == familyId)
              getContributors(t)
          };

        var additionalContributors =
          query nested {
            for (t <-- Tables.contributor2family)
              where (t.family_id == familyId)
              getContributors(t)
          };

        fun mkContributor(res) {
          (contribId=res.resultId,
            contribName=res.resultName,
            contribAddress=parseOrError(res.resultAddress),
            contribRole=res.resultRole)
        }

        var subcommitteeMembers = map(mkContributor, subcommitteeMembers);
        var additionalContributors = map(mkContributor, additionalContributors);

        var (contributors: Contributors) =
          (subcommittee=subcommitteeMembers, additional=additionalContributors);

        # Object summaries
        var objects =
         query nested {
            for (r2f <-- receptor2family)
              where (r2f.family_id == familyId)
              for (receptor <-- object)
                where (receptor.object_id == r2f.object_id)
                [
                   (id=receptor.object_id,
                    nomenclature=receptor.name,
                    synonyms=
                     for (s <-- Tables.synonym)
                       where (s.object_id == receptor.object_id && s.display)
                       [(name=s.synonym, order=s.display_order, refs=
                          for (sr <-- Tables.synonym_refs)
                          where (s.synonym_id == sr.synonym_id)
                          [sr.reference_id])],
                    genes=
                      for (g <-- structural_info)
                        where (g.object_id == receptor.object_id)
                        [ (g.gene_name, g.species_id) ],
                   ensemblRefs=[emptyER], # TODO
                   uniprotRefs=[emptyER], # TODO
                   principalTransductions=
                      for (tr <-- Tables.grac_transduction)
                        where (tr.object_id == receptor.object_id)
                        [tr.transduction],
                   interactions =
                     InteractionUtilities.interactionsForObject(receptor.object_id),
                   displayOrder=r2f.display_order)
                ]
         };

        # We can't run markup parsing from within a query, unfortunately,
        # so need to construct a new record with the parsed markup.
        # It's kind of a shame we need this boilerplate. I wonder whether
        # it would be possible to relax the LINQ query constraint s.t. "leaf"
        # queries needn't be tame, and we can do them in memory?
        var objects = map(fun(r) {
            var interactions =
              filter(fun(x) { x.fromGrac },
                  map(InteractionUtilities.makeInteraction, r.interactions));

            (
                objectId=r.id,
                objectNomenclature=parseOrError(r.nomenclature),
                objectSynonyms=
                  map(fun (s) { (synonymName=parseOrError(s.name),
                        synonymOrder=s.order, synonymReferences=s.refs) }, r.synonyms),
                objectGenes=
                  map(fun ((name, id)) { (geneName = parseOrError(name), geneSpeciesID = id) }, r.genes),
                objectEnsemblRefs=r.ensemblRefs,
                objectUniprotRefs=r.uniprotRefs,
                objectPrincipalTransductions=
                  map(parseOrError, r.principalTransductions),
                objectInteractions = interactions,
                objectDisplayOrder=r.displayOrder
            )
          }, objects);

        var objectReferences = listConcatMap(fun (object) {
            listConcatMap(fun (x) { x.references },
                object.objectInteractions) ++
            listConcatMap(fun (synonym) { synonym.synonymReferences },
                object.objectSynonyms)
        }, objects);

        var objectBoxes =
          map(fun (r) { (objectSummary=r, objectBoxVisible=false) },
            objects);

        # We need to parse the markup we get, and use it to
        # get the required information from the DB.
        var overviewMarkup = parseOrError(overview);
        var commentsMarkup = parseOrError(comments);
        var (oRefs, oLigands) = collectIds(overviewMarkup);
        var (cRefs, cLigands) = collectIds(commentsMarkup);
        var refs = uniquify(oRefs ++ cRefs ++ objectReferences);
        var ligands = uniquify(oLigands ++ cLigands);

        var references = queryReferences(refs);


        # References need to be numbered based on ordering.
        # This constructs a map from reference IDs to pairs of reference
        # numbers and references.
        var referenceData = mkReferenceData(references);
        var ligands = Ligand.queryLigands(ligands);

        # Species mapping is simple enough for us to just do in memory
        # and saves us the faff of doing joins.
        var speciesMap = Species.getSpeciesMap();
        var objectName = formatObjectName(type);

        Just((familyId=familyId, familyName=name, familyType=type,
           overview=mkTBox("Overview", true, overviewMarkup),
           objects=mkTBox(objectName, true, objectBoxes),
           comments=mkTBox("Comments", true, commentsMarkup),
           furtherReading=mkTBox("Further Reading", true, furtherReading),
           showReferences=true,
           references=referenceData,
           contributors=mkTBox("Contributors", true, contributors),
           ligandNames = ligands,
           speciesMap=speciesMap))
    }
  }

  switch(lookup("familyId", environment())) {
    case Just(id) -> getFamilyInfo(stringToInt(id))
    case Nothing -> Nothing
  }
}

fun mainPage() {
  var initialModel = getInitialModel();
  runSimple("vdom_placeholder", initialModel, view, updt);
  template("Family Display")
}
