open import Reference;
open import Mvu;
open import MvuHTML;
open import MvuAttrs;
open import MvuEvents;
open import Tables;
open import Template;
open import RenderMarkup;
open import Parser;
open import Utility;
open import InteractionUtilities;
open import Ligand;
open import Species;
open import ToggleBox;
open import Contributor;
open import Object;
open import DbLinks;

# TO DO

## For objects
# Endogenous substrates
# Exogenous substrates

## For ligands
# Ligand Id
# Name
# Common abbreviation
# Synonyms
# Complexes
# Subunits
# Genes
# PubChem CID
# UniProtKB AC


# DONE
# Target Id
# Genes
### Interactions
# Endogenous Ligands
# Ligands
# Sub/family-selective ligands
# Selective ligands
# Endogenous activators
# Activators
# Sub/family-selective activators
# Selective activators
# Endogenous inhibitors
# Inhibitors
# Sub/family-selective inhibitors
# Selective inhibitors
# Endogenous gating inhibitors
# Gating inhibitors
# Sub/family-selective gating inhibitors
# Selective gating inhibitors
# Endogenous agonists
# Agonists
# Sub/family-selective agonists
# Selective agonists
# Endogenous antagonists
# Antagonists
# Sub/family-selective antagonists
# Selective antagonists
# Endogenous channel blockers
# Channel blockers
# Sub/family-selective channel blockers
# Selective channel blockers
# Endogenous allosteric modulators
# Allosteric modulators
# Sub/family-selective allosteric modulators
# Whole organism assays
# Selective allosteric modulators
# Antibodies
# Sub/family-selective labelled ligands
# Labelled ligands
## Objects
# Common abbreviation
# Previous and unofficial names
# Principal Transduction (always show if a GPCR; show '-' if GPCR but unavailable)
# Bioparadigms SLC Tables
# PubChem CID
# UniProtKB AC
# Stoichiometry
# Functional characteristics
# Comments
# Products
# Cofactors
# Complexes
# Subunits
# Quaternary structure comments
# Accessory proteins
# Same entity ligands
# Rank potencies
# Reactions

typename ReferenceId = Int;
typename ReferenceNumber = Int;

typename ExternalRef = (
  refId: String,
  refSpeciesName: String,
  refUrl: String
);


typename Synonym = (synonymName: Markup, synonymOrder: Int, synonymReferences: [ReferenceId]);

var emptyER = (refId="", refSpeciesName="", refUrl="");

typename GeneRef = (geneName: Markup, geneSpeciesID: Int); # TODO: URL

typename ObjectComments = (
  generalComments: Markup,
  quaternaryStructureComments: Markup,
  functionalCharacteristics: Markup,
  stoichiometry: Markup
);

# There's probably a better biochemistry name for "product or cofactor"...
typename EnzymeReactionComponent = (
  ligandID: Int,
  ligandName: String,
  speciesID: Int,
  comments: Markup,
  references: [ReferenceID]
);

typename SubunitSummary =
  (id: Int, name: String, abbreviation: String, systematicName: String);

typename RankPotency =
  (description: String, rankPotency: Markup, speciesID: Int, references: [Int]);

typename Reaction =
  (ecNumber: String, reaction: Markup,
   specificReactions: [(description: String, reaction: Markup, references: [Int])]);

typename SubstrateSummary =
  (rawLigand: RawLigand, comments: Markup, standardProperty: String,
   standardValue: Float, speciesID: Int, references: [Int]);

typename ObjectSummary = (
   objectId: Int,
   rawObject: RawObject,
   objectType: ObjectType,
   objectSynonyms: [Synonym],
   objectGenes: [GeneRef],
   objectDBLinks: [DatabaseLink],
   objectPrincipalTransductions: [String],
   objectInteractions: [(String, [Interaction])], # (Type, Interactions)
   objectProducts: [EnzymeReactionComponent],
   objectCofactors: [EnzymeReactionComponent],
   objectSubunits: [SubunitSummary],
   objectComplexes: [SubunitSummary],
   objectComments: ObjectComments,
   objectSameEntityLigands: [(name: String, id: Int)],
   objectRankPotencies: [RankPotency],
   objectReactions: [Reaction],
   objectSubstrates: [SubstrateSummary],
   # Need to sort in-memory, since `orderby` not supported w/ shredding
   objectDisplayOrder: Int
  );

typename ObjectBox =
  (objectSummary: ObjectSummary, objectBoxVisible: Bool);

typename Model =
  Maybe((familyId: Int,
         familyName: String,
         familyType: String,
         overview: ContentBox(Markup),
         objects: ContentBox((objects: [ObjectBox], accessoryProteins: [ObjectBox])),
         comments: ContentBox(Markup),
         furtherReading: ContentBox([Reference]),
         showReferences: Bool,
         references: [(ReferenceId, (ReferenceNumber, Reference))],
         contributors: ContentBox(Contributors),
         ligandNames: [(LigandId, LigandName)],
         speciesMap: SpeciesMap
        ));

typename Message = [|
    ToggleOverview | ToggleObjects | ToggleComments
  | ToggleFurtherReading | ToggleReferences | ToggleContributors
  | SetAllVisibilities:Bool
  | ToggleObjectSummary:Int
|];

fun withModel(model, f) {
  switch(model) {
    case Just(model) -> Just(f(model))
    case Nothing -> Nothing
  }
}

fun setBoxVisibilities(visible, model) {
  fun sbv(box) { setBoxVisibility(box, visible) }

  (model with
    overview=sbv(model.overview),
    objects=sbv(model.objects),
    comments=sbv(model.comments),
    furtherReading=sbv(model.furtherReading),
    showReferences=visible,
    contributors=sbv(model.contributors))
}

fun toggleObject(objectBox, id) {
  var contents = boxContents(objectBox);

  fun toggle(xs) {
    map(fun(objectBox) {
      if (objectBox.objectSummary.objectId == id) {
        (objectBox with objectBoxVisible = not(objectBox.objectBoxVisible))
      } else {
        objectBox
      }
    }, xs)
  }

  var newContents = (objects = toggle(contents.objects),
      accessoryProteins = toggle(contents.accessoryProteins));
  setContents(objectBox, newContents)
}


sig updt : (Message, Model) ~%~> Model
fun updt(msg, model) {
  withModel(model, fun(model) {
      switch(msg) {
        case ToggleOverview ->
          (model with overview=toggleBox(model.overview))
        case ToggleObjects ->
          (model with objects=toggleBox(model.objects))
        case ToggleComments ->
          (model with comments=toggleBox(model.comments))
        case ToggleFurtherReading ->
          (model with furtherReading=toggleBox(model.furtherReading))
        case ToggleReferences ->
          (model with showReferences=not(model.showReferences))
        case ToggleContributors ->
          (model with contributors=toggleBox(model.contributors))
        case SetAllVisibilities(vis) -> setBoxVisibilities(vis, model)
        case ToggleObjectSummary(id) ->
          (model with objects=toggleObject(model.objects, id))
      }
  })
}

sig view : (Model) ~%~> HTML(Message)
fun view(model) {
  var a0 = MvuAttrs.empty;
  var h0 = MvuHTML.empty;

  fun viewModel(model) {
    fun renderM(markup) {
        RenderMarkup.renderMarkup(markup,
          model.references, model.ligandNames)
    }

    fun renderCitations(refs) {
      renderCitationList(refs, model.references)
    }

    fun speciesLongName(id) {
      resolveSpeciesLongName(id, model.speciesMap)
    }

    # headerBox: Header information for given family
    var headerBox =
      div(class("grid_16 alpha"),
        a(name("top"), h0) +*
        div(class("contentboxfull"),
          h2(style("margin-top: 0px;"), textNode(model.familyName)) +*
          div(class("textright"),
            p(style("font-weight:normal;font-size:90%;"),
              textNode("Unless otherwise stated all data on this page refer to the human proteins. ") +*
              textNode("Gene information is provided for human (Hs), mouse (Mm) and rat (Rn).")) +*
            div(style("text-align:right;padding: 0px 5px 5px 0x;"),
              button(onClick(fun() { SetAllVisibilities(true) }), textNode("Expand all sections")) +*
              button(onClick(fun() { SetAllVisibilities(false) }), textNode("Collapse all sections"))
            )
          )));

    fun displayOverview(overviewMarkup) {
      p(class("grac_text"), renderM(overviewMarkup))
    }

    fun displayObjects(boxes) {

      fun displayObjectBox(box) {
        var summary = box.objectSummary;
        var toggleMsg = ToggleObjectSummary(summary.objectId);
        var showHideLink =
          if(box.objectBoxVisible) {
            a(onClick(fun() { toggleMsg }),
              span(class("object_summary_link"), textNode("  Hide summary")))
          } else {
            a(onClick(fun() { toggleMsg }),
              small(class("object_summary_link"), textNode("  Show summary")))
          };

        fun mkRow(name, contents) {
          table_(class("grac_data_table fullwidth"),
            tr(a0,
              td(class("grac_category_simple"), textNode(name)) +*
              td(class("grac_info_simple"), contents)))
        }

        fun mkStrRowIfNonempty(name, str) {
          if (str <> "") {
            mkRow(name, unescapedTextNode(str))
          } else {
            MvuHTML.empty
          }
        }

        fun mkMarkupRowIfNonempty(name, m) {
          if (not(markupEmpty(m))) {
            mkRow(name, renderM(m))
          } else {
            MvuHTML.empty
          }
        }

        fun showInteraction(x) {
          var interactionActionNode =
            if (not(x.interactionAction == "Agonist"
                  || x.interactionAction == "Antagonist")) {
              textNode(" (" ^^ x.interactionAction ^^ ")")
            } else { MvuHTML.empty };
          var speciesName = resolveSpeciesLongName(x.speciesID, model.speciesMap);
          var speciesNode =
            if (speciesName <> "Human") {
              textNode(" - " ^^ speciesName)
            } else {
              MvuHTML.empty
            };

          var affinityNode = {
            InteractionUtilities.displayAffinity(x.affinity, true)
          };

          var citationsNode =
            textNode(" ") +*
            renderCitationList(x.references, model.references);

          a(href("ligandDisplay?ligandId=" ^^
              intToString(x.ligandID)),
              unescapedTextNode(x.interactionLigand.name)) +*
          interactionActionNode +*
          affinityNode +*
          citationsNode +*
          speciesNode
        }

        fun mkInteractionRow(interactionType, interactions) {
          if (listEmpty(interactions)) {
            MvuHTML.empty
          } else {
            var renderedInteractions =
              MvuHTML.concat(map(fun(i) { tr(MvuAttrs.empty,
                    td(class("grac_info_simple"), showInteraction(i))) }, interactions));
            var interactionTable =
              table_(class("grac_inner_table"), renderedInteractions);

            mkRow(interactionType, interactionTable)
          }
        }

        var ptRow =
          if (summary.objectType == GPCR) {
              var contents =
                if (length(summary.objectPrincipalTransductions) > 0) {
                  MvuHTML.concat(map(fun(x) { unescapedTextNode(x) },
                    summary.objectPrincipalTransductions))
                } else {
                  textNode("-")
                };
              mkRow("Principal transduction", contents)
          } else {
            MvuHTML.empty
          };

        var rpRows = {
          if (listEmpty(summary.objectRankPotencies)) {
            MvuHTML.empty
          } else {

            fun renderRP(x) {
              var sln = speciesLongName(x.speciesID);
              var descWithSpecies = 
                if (sln == "" || sln == "None" || sln == "Unknown" || sln == "Human") {
                  x.description
                } else {
                  x.description ^^ " (" ^^ sln ^^ ")"
                };
              var contents =
                renderM(x.rankPotency) +*
                textNode(" ") +*
                renderCitations(x.references);
              mkRow(descWithSpecies, contents)
            }

            MvuHTML.concatMap(renderRP, summary.objectRankPotencies)
          }
        };

        fun showSummary() {
          if (box.objectBoxVisible) {
            
            # Synonyms
            var synonymsRow = {
              if (listEmpty(summary.objectSynonyms)) {
                MvuHTML.empty
              } else {
                var synonyms = sortBy(fun(syn) { syn.synonymOrder }, summary.objectSynonyms);
                var synonyms = map(fun(x) {
                    var citationNode =
                      if (length(x.synonymReferences) > 0) {
                        textNode(" ") +* renderCitationList(x.synonymReferences,
                            model.references)
                      } else { MvuHTML.empty };
                    [renderM(x.synonymName) +* citationNode]
                }, synonyms);
                var separatedSynonyms = MvuHTML.concat(join([textNode(" | ")], synonyms));
                mkRow("Previous and unofficial names", separatedSynonyms)
              }
            };
              
            var genesRow = {
              if (listEmpty(summary.objectGenes)) {
                MvuHTML.empty
              } else {
                var genes = map(fun(gene) {
                    var name = gene.geneName;
                    var id = gene.geneSpeciesID;
                  [renderM(name) +* textNode(" (" ^^ resolveSpeciesShortName(id, model.speciesMap) ^^ ")")]
                  }, summary.objectGenes);
                var separatedGenes = MvuHTML.concat(join([textNode(", ")], genes));
                mkRow("Genes", separatedGenes)
              }
            };

            var qsc = summary.objectComments.quaternaryStructureComments;
            fun showSubunitSummary(name, xs, showComments) {
              if (listEmpty(xs)) {
                MvuHTML.empty
              } else {
                fun mkLink(x) {
                  var name =
                    if (x.systematicName == "") {
                      x.name
                    } else {
                      x.name ^^ " / " ^^ x.systematicName 
                    };

                  var abbrev =
                    if (x.abbreviation == "") {
                      unescapedTextNode(name)
                    } else {
                      unescapedTextNode(x.abbreviation ^^
                          "(" ^^ name ^^ ")")
                    };
                  [a(href("/objectDisplay?objectId=" ^^ intToString(x.id)), abbrev)]
                }
                var links = map(mkLink, xs);
                var joinedLinks = MvuHTML.concat(join([br(a0, h0)], links));
                var structureComments = {
                  if (not(markupEmpty(qsc)) && showComments) {
                    br(a0, h0) +* renderM(qsc)
                  } else {
                    MvuHTML.empty
                  }
                };
                mkRow(name, joinedLinks +* structureComments)
              }
            }

            # Only show structure comments as its own row if either the object has both
            # complexes and subunits, or has neither
            var structureCommentsRow = {
              if ((listEmpty(summary.objectComplexes) && listEmpty(summary.objectSubunits)) ||
                  (not(listEmpty(summary.objectComplexes)) && not(listEmpty(summary.objectSubunits))) &&
                  not(markupEmpty(qsc))) {
                mkRow("Structure comments", renderM(qsc))
              } else {
                MvuHTML.empty
              }
            };
            var subunitsRow =
              showSubunitSummary("Subunits",
                  summary.objectSubunits, listEmpty(summary.objectComplexes));
            var complexesRow = showSubunitSummary("Complexes",
                  summary.objectComplexes, listEmpty(summary.objectSubunits));

            var nomenclature = {
              var o = summary.rawObject;
              if (o.systematic_name <> "") {
                if (o.name == o.systematic_name) {
                  mkRow("Nomenclature", unescapedTextNode(o.name)) +*
                  mkRow("Systematic nomenclature", unescapedTextNode(o.systematic_name))
                } else {
                  mkRow("Systematic nomenclature", unescapedTextNode(o.systematic_name))
                }
              } else {
                mkRow("Nomenclature", unescapedTextNode(o.name))
              }
            };

            fun mkIDRow(dbName, dbID) {
              switch(filter(fun(x) { x.dbID == dbID }, summary.objectDBLinks)) {
                case [] -> MvuHTML.empty
                case x :: _ ->
                  var links = renderEntries(x, model.speciesMap);
                  mkRow(dbName, links)
              }
            }

            fun renderEnzymeComponents(name, ecs) {
              fun renderRow(x) {
                var ligandInfo =
                  a(href("/ligandDisplay?ligandId=" ^^ intToString(x.ligandID)),
                      textNode(x.ligandName));
                var speciesInfo = {
                  var species = resolveSpeciesLongName(x.speciesID,
                    model.speciesMap);
                  if (species <> "Human") {
                    textNode(species)
                  } else {
                    MvuHTML.empty
                  }
                };

                tr(a0,
                  td(class("grac_info_simple"),
                    ligandInfo +*
                    speciesInfo +*
                    renderCitationList(x.references, model.references)))
              }

              if (listEmpty(ecs)) {
                MvuHTML.empty
              } else {
                var renderedRows = MvuHTML.concatMap(renderRow, ecs);
                var tbl =
                  table_(class("grac_inner_table"), renderedRows);
                mkRow(name, tbl)
              }
            }

            var ensemblIDs = mkIDRow("Ensembl ID", 15);
            var uniprotIDs = mkIDRow("UniProtKB AC", 5);
            var plasmoIDs = mkIDRow("PlasmoDB", 64);
            var bitterIDs = mkIDRow("BitterDB", 54);
            var slcIDs = mkIDRow("Bioparadigms SLC Tables", 61);

            var interactionRows =
              MvuHTML.concatMap(fun((name, xs)) { mkInteractionRow(name, xs) },
                  summary.objectInteractions);

            var cofactorsRow = renderEnzymeComponents("Cofactors", summary.objectCofactors);
            var productsRow = renderEnzymeComponents("Products", summary.objectProducts);

            var sameLigandsRow = {
              var ligs = summary.objectSameEntityLigands;
              if (listEmpty(ligs)) {
                MvuHTML.empty
              } else {
                var ligLinks =
                  MvuHTML.concat(
                      join([textNode(", ")], map(fun(x) {
                        [a(href("/ligandDisplay?ligandId=" ^^ intToString(x.id)),
                            textNode(x.name))]
                        }, ligs)));
                tr(a0,
                    td(class("grac_info_simple") +@ colSpan(2),
                      textNode("This target is also described as a ligand entry: ")
                      +* ligLinks))
              }
            };

            var reactionsRow = {
              if (listEmpty(summary.objectReactions)) {
                MvuHTML.empty
              } else {
                fun renderReaction(r) {
                  fun renderSpecificReaction(sr) {
                    [tr(a0,
                        td(colSpan(2),
                          textNode(sr.description ^^ " ") +*
                          renderM(sr.reaction) +*
                          textNode(" ") +*
                          renderCitations(sr.references)))]
                  }

                  var specificReactions =
                    MvuHTML.concat(
                        join([br(a0, h0)],
                          map(renderSpecificReaction, r.specificReactions)));

                  var ec =
                    a(href("http://www.genome.jp/dbget-bin/www_bget?ec:" ^^ r.ecNumber),
                        textNode(r.ecNumber));
                  table_(style("margin:0px"),
                    tr(a0,
                      td(style("vertical-align:top;") +@ width("100px;"), ec) +*
                      td(a0, renderM(r.reaction)))
                    +* specificReactions)
                }

                var contents =
                  MvuHTML.concatMap(renderReaction, summary.objectReactions);
                mkRow("EC number", contents)
              }
            };

            hr(class("divider_dashed"), MvuHTML.empty) +*
            mkRow("Target Id", textNode(intToString(summary.objectId))) +*
            nomenclature +*
            mkStrRowIfNonempty("Common abbreviation", summary.rawObject.abbreviation) +*
            synonymsRow +*
            complexesRow +*
            subunitsRow +*
            structureCommentsRow +*
            genesRow +*
            ensemblIDs +*
            uniprotIDs +*
            plasmoIDs +*
            bitterIDs +*
            slcIDs +*
            reactionsRow +*
            rpRows +*
            ptRow +*
            productsRow +*
            cofactorsRow +*
            interactionRows +*
            mkMarkupRowIfNonempty("Stoichiometry", summary.objectComments.stoichiometry) +*
            mkMarkupRowIfNonempty("Functional characteristics", summary.objectComments.functionalCharacteristics) +*
            mkMarkupRowIfNonempty("Comment", summary.objectComments.generalComments) +*
            sameLigandsRow
          } else {
            MvuHTML.empty
          }
        }

        tr(a0,
          td(class("grac_info"),
            p(class("grac_heading split_para"),
              unescapedTextNode(box.objectSummary.rawObject.name) +*
              span(class("cgtp"), textNode(" C")) +*
              showHideLink +*
              span(class("split_para_right_text detailed_view_link"),
                a(href("objectDisplay?objectId=" ^^ intToString(summary.objectId)),
                  textNode("More detailed page") +*
                  img(attr("src", "/images/go.jpg"), MvuHTML.empty)))) +*
              showSummary()
            ))
      }

      var targets =
        MvuHTML.concatMap(fun(x) { displayObjectBox(x) }, boxes.objects);

      var aps = {
        if (listEmpty(boxes.accessoryProteins)) {
          MvuHTML.empty
        } else {
          var renderedAPs =
            MvuHTML.concatMap(fun(x) { displayObjectBox(x) }, boxes.accessoryProteins);

          h3(a0, textNode("Accessory proteins")) +*
          div(class("data_tables_container"),
            table_(class("receptor_data_tables fullwidth"),
              tbody(a0, renderedAPs)))
        }
      };

      div(class("data_tables_container"),
        table_(class("receptor_data_tables fullwidth"),
          tbody(a0,
            MvuHTML.concat(
              map(fun(x) { displayObjectBox(x) }, boxes.objects))))) +*
      aps
    }

    fun displayComments(commentMarkup) {
      p(class("grac_text"), renderM(commentMarkup))
    }

    fun displayFurtherReading(refs) {
      p(a0, textNode("* Key further reading is highlighted with an asterisk")) +*
      MvuHTML.concat(map(fun(x) {
        var prefixNode = if(x.isKey) { textNode("* ") } else { MvuHTML.empty };
        renderReference(prefixNode, x)
      }, refs))
    }

    var referencesBox =
      Reference.renderReferencesBox(
          model.showReferences,
          model.references,
          fun() { ToggleReferences });

    # (tboxName: String,  tboxVisible: Bool, contents: a);
    headerBox +*
    showBox(model.overview, ToggleOverview, displayOverview) +*
    showBox(model.objects, ToggleObjects, displayObjects) +*
    showBox(model.comments, ToggleComments, displayComments) +*
    showBox(model.furtherReading, ToggleFurtherReading, displayFurtherReading) +*
    referencesBox +*
    showBox(model.contributors, ToggleContributors, displayContributors)
  }

  switch(model) {
    case Just(model) -> viewModel(model)
    case Nothing -> p(a0, textNode("Invalid family ID."))
  }
}

fun formatObjectName(dbName) {
  switch (dbName) {
    case "gpcr" -> "Receptors"
    case "nhr" -> "Receptors"
    case "other_protein" -> "Targets"
    case "grouping" -> "Targets" # I think we need to handle this differently
    case "ligand" -> "Ligands"
    case "other_ic" -> "Channels and Subunits"
    case "enzyme" -> "Enzymes"
    case "transporter" -> "Transporters"
    case "vgic" -> "Channels and Subunits"
    case "lgic" -> "Channels and Subunits"
    case "catalytic_receptor" -> "Receptors"
    case _ -> "Targets"
  }
}


sig getInitialModel : () ~%~> Model
fun getInitialModel() {
  fun queryObjects(pred, displayOrder) {
    for (o <-- object)
      where (pred(o))
      [
         (id=o.object_id,
          =o,
          nomenclature=o.name,
          synonyms=
           for (s <-- Tables.synonym)
             where (s.object_id == o.object_id && s.display)
             [(name=s.synonym, order=s.display_order, refs=
                for (sr <-- Tables.synonym_refs)
                where (s.synonym_id == sr.synonym_id)
                [sr.reference_id])],
          genes=
            for (g <-- structural_info)
              where (g.object_id == o.object_id)
              [ (g.gene_name, g.species_id) ],
         dbLinks =
           for (dbl <-- Tables.database_link)
           where (dbl.object_id == o.object_id)
             [dbl],
         principalTransductions=
            for (tr <-- Tables.grac_transduction)
              where (tr.object_id == o.object_id)
              [tr.transduction],
         functionalCharacteristics =
           for (fc <-- Tables.grac_functional_characteristics)
             where (fc.object_id == o.object_id)
             [fc.functional_characteristics],
         stoichiometry =
           for (t <-- Tables.transporter)
             where (t.object_id == o.object_id)
              [t.grac_stoichiometry],
         products =
           for (p <-- Tables.product)
             where (p.object_id == o.object_id)
               for (l <-- Tables.ligand)
               where (l.ligand_id == p.ligand_id)
               [(x = p, =l,
                   refs =
                     for (r <-- Tables.product_refs)
                     where (r.product_id == p.product_id)
                       [r.reference_id])],
         cofactors =
           for (c <-- Tables.cofactor)
             where (c.object_id == o.object_id)
               for (l <-- Tables.ligand)
               where (l.ligand_id == c.ligand_id)
               [(x = c, =l,
                   refs =
                     for (r <-- Tables.cofactor_refs)
                     where (r.cofactor_id == c.cofactor_id)
                       [r.reference_id])],
         interactions =
           InteractionUtilities.interactionsForObject(o.object_id),
         =displayOrder,
         complexes =
           for (r2s <-- Tables.receptor2subunit)
           where (r2s.subunit_id == o.object_id)
             for (c <-- Tables.object)
             where (c.object_id == r2s.receptor_id)
               [(id = c.object_id, name = c.name,
                   abbreviation = c.abbreviation, systematicName = c.systematic_name)],
         subunits =
           for (r2s <-- Tables.receptor2subunit)
           where (r2s.receptor_id == o.object_id)
             for (c <-- Tables.object)
             where (c.object_id == r2s.subunit_id)
               [(id = c.object_id, name = c.name,
                   abbreviation = c.abbreviation, systematicName = c.systematic_name)],
         sameEntityLigands =
           for (tl <-- Tables.target_ligand_same_entity)
             where (tl.object_id == o.object_id)
             for (l <-- Tables.ligand)
             where (l.ligand_id == tl.ligand_id)
               [ (name = l.name, id = l.ligand_id) ],
         rankPotencies =
           for (glrp <-- Tables.grac_ligand_rank_potency)
             where (glrp.object_id == o.object_id)
             [(=glrp,
               refs =
                 for (r <-- Tables.grac_ligand_rank_potency_refs)
                 where (r.grac_ligand_rank_potency_id ==
                   glrp.grac_ligand_rank_potency_id)
                 [r.reference_id])
             ],
          reactions =
            for (o2r <-- Tables.object2reaction)
              where (o2r.object_id == o.object_id)
              for (r <-- Tables.reaction)
                where (r.reaction_id == o2r.reaction_id)
                [(=r,
                   srs =
                     for (sr <-- Tables.specific_reaction)
                     where (sr.reaction_id == r.reaction_id)
                     [(=sr,
                       refs =
                         for (srr <-- Tables.specific_reaction_refs)
                         where (srr.specific_reaction_id == sr.specific_reaction_id)
                         [srr.reference_id])])
                ],
          substrates =
            for (s <-- Tables.substrate)
              where (s.object_id == o.object_id)
              for (l <-- Tables.ligand)
              where (l.ligand_id == s.ligand_id)
                [(=s, =l,
                 refs =
                   for (r <-- Tables.substrate_refs)
                   where (r.substrate_id == s.substrate_id)
                   [r.reference_id])]
        )
      ]
  }

  fun getFamilyInfo(familyId) {
    # First, grab the basic information.
    var basicInfo =
      query nested {
        for (f <-- Tables.family)
          where (f.family_id == familyId)
          [(name = f.name, type = f.type,
              grac_texts =
                for (g <-- Tables.grac_family_text)
                  where (g.family_id == familyId)
                  [g])]
      };

    switch(basicInfo) {
      case [] -> Nothing
      case x ::_ ->
        var name = x.name;
        var type = x.type;
        var (overview, comments) =
          switch (x.grac_texts) {
            case [] -> ("", "")
            case y :: _ -> (y.overview, y.comments)
          };
        # At this point, we need to populate the rest of the data
        # (further reading, contributors, and interaction data).
        ### Further reading
        var furtherReading =
          query nested {
            for (fr <-- Tables.grac_further_reading)
              where (fr.family_id == familyId)
              for (ref <-- Tables.reference)
                where (ref.reference_id == fr.reference_id)
                [
                  (makeReference(ref.reference_id,
                     ref.type, ref.title, ref.article_title, ref.year,
                     ref.volume, ref.issue, ref.pages, ref.publisher,
                     ref.publisher_address, ref.editors, ref.pubmed_id,
                     ref.isbn, ref.authors, fr.key_ref))
                ]
          };
        var furtherReading =
          sortBy(fun(ref) { ref.authors }, furtherReading);

        ### Contributors
        fun getContributors(t) {
          query nested {
            for (contrib <-- Tables.contributor_copy)
              where (contrib.contributor_id == t.contributor_id)
              orderby (-(t.display_order))
              [(resultId=contrib.contributor_id,
                resultName=(contrib.first_names ^^ " " ^^ contrib.surname),
                resultAddress=contrib.address,
                resultRole=t.role)]
          }
        }

        var subcommitteeMembers =
          query nested {
            for (t <-- Tables.subcommittee)
              where (t.family_id == familyId)
              getContributors(t)
          };

        var additionalContributors =
          query nested {
            for (t <-- Tables.contributor2family)
              where (t.family_id == familyId)
              getContributors(t)
          };

        fun mkContributor(res) {
          (contribId=res.resultId,
            contribName=res.resultName,
            contribAddress=parseOrError(res.resultAddress),
            contribRole=res.resultRole)
        }

        var subcommitteeMembers = map(mkContributor, subcommitteeMembers);
        var additionalContributors = map(mkContributor, additionalContributors);

        var (contributors: Contributors) =
          (subcommittee=subcommitteeMembers, additional=additionalContributors);

        # Object summaries
        var objects = query nested {
          for (r2f <-- Tables.receptor2family)
            where (r2f.family_id == familyId)
            queryObjects(fun(o) { o.object_id == r2f.object_id }, r2f.display_order)
        };
         sig transformInteractions : (%) ~%~> [(String, [Interaction])]
         fun transformInteractions(rawInteractions) {
           # Logic taken fairly directly from the GtoPdb source

           # filterWholeOrganismInteractions: is whole organism assay
           fun isWholeOrganism(i) {
             i.wholeOrganismAssay
           }
           # filterInteractions: Type equal, not whole organism assay
           fun typeEquals(i, ty) {
             not(i.wholeOrganismAssay) && i.interactionType == ty
           }
           # getGracProbes: Labelled, selectivity null or not family selective,
           #   and not whole organism assay
           fun isGracProbe(i) {
             i.interactionLigand.labelled && i.selectivity <> "Family selective"
               && not(i.wholeOrganismAssay)
           }

           # getGracFamilySelectiveProbes: Labelled, selectivity is family
           #   selective, not whole organism assay
           fun isGracFamilySelectiveProbe(i) {
             i.interactionLigand.labelled && i.selectivity == "Family selective"
               && not(i.wholeOrganismAssay)
           }

           # filterGracInteractions: Type equal, not labelled, not whole org
           #   assay
           fun gracTypeEquals(i, ty) {
             i.interactionType == ty && not(i.interactionLigand.labelled) &&
               not(i.wholeOrganismAssay)
           }

           # filterGracNonSelectiveInteractions: Type equals, not labelled,
           #  selectivity empty or Not Determined or Non-selective and not
           #  endogenous and not whole organism assay
           fun gracNonSelective(i, ty) {
             i.interactionType == ty && not(i.interactionLigand.labelled) &&
               (i.selectivity == "" || i.selectivity == "Not Determined" ||
                i.selectivity == "Non-selective") && not(i.endogenous) &&
               not(i.wholeOrganismAssay)
           }

           # filterGracEndogenousInteractions: Type equals, not labelled,
           #  endogenous, not whole organism assay
           fun gracEndogenous(i, ty) {
             i.interactionType == ty && not(i.interactionLigand.labelled) &&
               i.endogenous && not(i.wholeOrganismAssay)
           }

           # filterGracSelectiveInteractions: Type equals, not labelled,
           #  selectivity is Selective or Isotope selectivity, not endogenous,
           #  not whole organism assay
           fun gracSelective(i, ty) {
             i.interactionType == ty && not(i.interactionLigand.labelled) &&
               (i.selectivity == "Selective" ||
                i.selectivity == "Isotope selectivity") &&
             not(i.endogenous) && not(i.wholeOrganismAssay)
           }

           # filterGracFamilySelectiveInteractions: Type equals, not labelled,
           #  selectivity is "Family selective", not endogenous, not whole
           #  organism assay
           fun gracFamilySelective(i, ty) {
             i.interactionType == ty && not(i.interactionLigand.labelled) &&
               i.selectivity == "Family selective" && not(i.endogenous) &&
               not(i.wholeOrganismAssay)
           }

           fold_right(fun(x, acc) {
              fun addToListMap(xs, name, toAdd) {
                switch(xs) {
                  case [] -> [(name, [toAdd])]
                  case (category_name, ys) :: xs ->
                    if (category_name == name) {
                      (category_name, toAdd :: ys) :: xs
                    } else {
                      (category_name, ys) :: addToListMap(xs, name, toAdd)
                    }
                }
              }
              fun add(name, toAdd) {
                addToListMap(acc, name, toAdd)
              }

              var x = InteractionUtilities.makeInteraction(x);
              if (not(x.fromGrac)) {
                acc
              # Endogenous Ligands
              } else if (gracEndogenous(x, "None")) {
                add("Endogenous ligands", x)
              # Ligands
              } else if (gracNonSelective(x, "None")) {
                add("Ligands", x)
              # Sub/family-selective ligands
              } else if (gracFamilySelective(x, "None")) {
                add("Sub/family-selective ligands", x)
              # Selective ligands
              } else if (gracSelective(x, "None")) {
                add("Selective ligands", x)
              # Endogenous activators
              } else if (gracEndogenous(x, "Activator")) {
                add("Endogenous activators", x)
              # Activators
              } else if (gracNonSelective(x, "Activator")) {
                add("Activators", x)
              # Sub/family-selective activators
              } else if (gracFamilySelective(x, "Activator")) {
                add("Sub/family-selective activators", x)
              # Selective activators
              } else if (gracSelective(x, "Activator")) {
                add("Selective activators", x)
              # Endogenous inhibitors
              } else if (gracEndogenous(x, "Inhibitor")) {
                add("Endogenous inhibitors", x)
              # Inhibitors
              } else if (gracNonSelective(x, "Inhibitor")) {
                add("Inhibitors", x)
              # Sub/family-selective inhibitors
              } else if (gracFamilySelective(x, "Inhibitor")) {
                add("Sub/family-selective inhibitors", x)
              # Selective inhibitors
              } else if (gracSelective(x, "Inhibitor")) {
                add("Selective inhibitors", x)
              # Endogenous gating inhibitors
              } else if (gracEndogenous(x, "Gating inhibitor")) {
                add("Endogenous gating inhibitors", x)
              # Gating gating inhibitors
              } else if (gracNonSelective(x, "Gating inhibitor")) {
                add("Gating inhibitors", x)
              # Sub/family-selective gating inhibitors
              } else if (gracFamilySelective(x, "Gating inhibitor")) {
                add("Sub/family-selective gating inhibitors", x)
              # Selective gating inhibitors
              } else if (gracSelective(x, "Gating inhibitor")) {
                add("Selective gating inhibitors", x)
              # Endogenous agonists
              } else if (gracEndogenous(x, "Agonist")) {
                add("Endogenous agonists", x)
              # Agonists
              } else if (gracNonSelective(x, "Agonist")) {
                add("Agonists", x)
              # Sub/family-selective agonists
              } else if (gracFamilySelective(x, "Agonist")) {
                add("Sub/family-selective agonists", x)
              # Selective agonists
              } else if (gracSelective(x, "Agonist")) {
                add("Selective agonists", x)
              # Endogenous antagonists
              } else if (gracEndogenous(x, "Antagonist")) {
                add("Endogenous antagonists", x)
              # Antagonists
              } else if (gracNonSelective(x, "Antagonist")) {
                add("Antagonists", x)
              # Sub/family-selective antagonists
              } else if (gracFamilySelective(x, "Antagonist")) {
                add("Sub/family-selective antagonists", x)
              # Selective antagonists
              } else if (gracSelective(x, "Antagonist")) {
                add("Selective antagonists", x)
              # Endogenous channel blockers
              } else if (gracEndogenous(x, "Channel blocker")) {
                add("Endogenous channel blockers", x)
              # Channel blockers
              } else if (gracNonSelective(x, "Channel blocker")) {
                add("Channel blockers", x)
              # Sub/family-selective channel blockers
              } else if (gracFamilySelective(x, "Channel blocker")) {
                add("Sub/family-selective channel blockers", x)
              # Selective channel blocker
              } else if (gracSelective(x, "Channel blocker")) {
                add("Selective channel blockers", x)
              # Endogenous allosteric modulators
              } else if (gracEndogenous(x, "Allosteric modulator")) {
                add("Endogenous allosteric modulators", x)
              # Allosteric modulators
              } else if (gracNonSelective(x, "Allosteric modulator")) {
                add("Allosteric modulators", x)
              # Sub/family-selective allosteric modulators
              } else if (gracFamilySelective(x, "Allosteric modulator")) {
                add("Sub/family-selective allosteric modulators", x)
              # Selective allosteric modulators
              } else if (gracSelective(x, "Allosteric modulator")) {
                add("Selective allosteric modulators", x)
              } else if (typeEquals(x, "Antibody")) {
                add("Antibodies", x)
              } else if (gracFamilySelective(x, "Allosteric modulator")) {
                add("Sub/family-selective allosteric modulators", x)
              } else if(isGracFamilySelectiveProbe(x)) {
                add("Sub/family-selective labelled ligands", x)
              } else if (isGracProbe(x)) {
                add("Labelled ligands", x)
              } else {
                acc
              }
           }, [], rawInteractions)
         }

         fun transformComments(o) {
           var generalComments = parseOrError(o.o.grac_comments);
           var quaternaryStructureComments = parseOrError(o.o.quaternary_structure_comments);
           var functionalCharacteristics =
             parseOrError(unwords(o.functionalCharacteristics));
           var stoichiometry = parseOrError(unwords(o.stoichiometry));
           var (refs, ligands) =
             collectAllIds([generalComments, quaternaryStructureComments,
               functionalCharacteristics, stoichiometry]);

           var comments = (=generalComments, =quaternaryStructureComments,
               =functionalCharacteristics, =stoichiometry);
           (comments, refs, ligands)
         }

         sig transformCofactors : (%) ~%~>
           ([EnzymeReactionComponent], [Int], [Int])
         fun transformCofactors(cs) {
           fold_right(fun(x, (cs, refs, ligands)) {
               var comments = parseOrError(x.x.comments);
               var (commentRefs, commentLigands) = collectIds(comments);
               var c =
                 (ligandID = x.l.ligand_id,
                  ligandName = x.l.name,
                  speciesID = x.x.species_id,
                  =comments,
                  references = x.refs);
               var cRefs = x.refs ++ commentRefs;
               (c :: cs, cRefs ++ refs, commentLigands ++ ligands)
           }, ([], [], []), cs)
         }

         sig transformProducts : (%) ~%~>
           ([EnzymeReactionComponent], [Int])
         fun transformProducts(ps) {
           fold_right(fun(x, (ps, refs)) {
               var p =
                 (ligandID = x.l.ligand_id,
                  ligandName = x.l.name,
                  speciesID = x.x.species_id,
                  comments = MarkupEmpty,
                  references = x.refs);
               (p :: ps, x.refs ++ refs)
           }, ([], []), ps)
         }

         sig transformRankPotencies : (%) ~%~>
           ([RankPotency], [Int], [Int])
         fun transformRankPotencies(rps) {
           fold_right(fun(x, (rps, refs, ligs)) {
             var rp = x.glrp;
             var description = rp.description;
             var rankPotency = parseOrError(rp.rank_potency);
             var (commentRefs, commentLigands) =
               collectIds(rankPotency);
             var res =
               (=description, =rankPotency, speciesID = rp.species_id,
              references = x.refs);
             (res :: rps, refs ++ x.refs ++ commentRefs, ligs ++ commentLigands)
           }, ([], [], []), rps)
         }

         sig transformReactions: (%) ~%~> ([Reaction], [Int], [Int])
         fun transformReactions(rs) {
           fun transformSpecificReactions(srs) {
             fold_right(fun(x, (srs, refs, ligs)) {
                 var reaction = parseOrError(x.sr.reaction);
                 var sr = (description = x.sr.description, =reaction,
                     references = x.refs);
                 var (commentRefs, commentLigs) = collectIds(reaction);
                 (sr :: srs, x.refs ++ commentRefs ++ refs, commentLigs ++ ligs)
             }, ([], [], []), srs)
           }

           fold_right(fun(x, (rs, refs, ligs)) {
               var reaction = parseOrError(x.r.reaction);
               var (rRefs, rLigs) = collectIds(reaction);
               var (srs, srRefs, srLigands) = transformSpecificReactions(x.srs);
               var reaction =
                 (ecNumber = x.r.ec_number, =reaction, specificReactions = srs);

               (reaction :: rs, srRefs ++ rRefs ++ refs, srLigands ++ rLigs ++ ligs)
           }, ([], [], []), rs)
         }

         sig transformSubstrates : (%) ~%~> ([SubstrateSummary], [Int], [Int])
         fun transformSubstrates(subs) {
           fold_right(fun(x, (subs, refs, ligands)) {
               var comments = parseOrError(x.s.comments);
               var (commentRefs, commentLigs) = collectIds(comments);
               var s =
                 (rawLigand = x.l, =comments, standardProperty = x.s.standard_property,
                  standardValue = x.s.standard_value, speciesID = x.s.species_id,
                  references = x.refs);
               (s :: subs, commentRefs ++ x.refs ++ refs, commentLigs ++ ligands)
           }, ([], [], []), subs)
         }

         # There are very few accessory proteins (10), so it's easier
         # to just get them into memory, and check membership.
         var apIDs =
           query nested {
             for (ap <-- Tables.accessory_protein)
               [ap.object_id]
           };

         sig transformObjects : (%) ~%~> ([ObjectSummary], [Int], [Int], [Int])
         fun transformObjects(os) {
           fold_right(fun(r, (os, refs, ligands, aps)) {

             var (objectSynonyms, synRefs) =
              fold_right(fun (s, (syns, synRefs)) {
                  var x =
                    (synonymName=parseOrError(s.name),
                     synonymOrder=s.order, synonymReferences=s.refs);
                  (x :: syns, s.refs ++ synRefs)
                  }, ([], []), r.synonyms);

             var (objectComments, commentRefs, commentLigands) =
               transformComments(r);

             var (objectCofactors, cofactorRefs, cofactorLigands) =
               transformCofactors(r.cofactors);

             var (objectProducts, productRefs) =
               transformProducts(r.products);

             var (objectRankPotencies, rpRefs, rpLigands) =
               transformRankPotencies(r.rankPotencies);

             var (objectReactions, rRefs, rLigands) =
               transformReactions(r.reactions);

             var (objectSubstrates, subsRefs, subsLigands) =
               transformSubstrates(r.substrates);

             var subunitAPs =
               filterMap(fun(x) { 
                   if (elem(x.id, apIDs)) {
                    Just(x.id)
                   } else {
                    Nothing
                   }}, r.subunits);

             var o =
               (objectId=r.id,
                objectType = Object.classifyObject(r.id),
                rawObject=r.o,
                =objectSynonyms,
                objectGenes=
                  map(fun ((name, id)) {
                    (geneName = parseOrError(name), geneSpeciesID = id)
                  }, r.genes),
                objectDBLinks = transformDatabaseLinks(r.dbLinks),
                objectPrincipalTransductions= r.principalTransductions,
                objectInteractions = transformInteractions(r.interactions),
                =objectComments,
                =objectCofactors,
                =objectProducts,
                objectSubunits = r.subunits,
                objectComplexes = r.complexes,
                =objectRankPotencies,
                objectSameEntityLigands = r.sameEntityLigands,
                =objectReactions,
                =objectSubstrates,
                objectDisplayOrder=r.displayOrder);

             var interactionRefs =
               listConcatMap(fun((_, xs)) {
                   listConcatMap(fun(x) { x.references }, xs)
                  }, o.objectInteractions);

             (o :: os,
                synRefs ++ interactionRefs ++ commentRefs ++ cofactorRefs ++
                productRefs ++ rpRefs ++ rRefs ++ subsRefs ++ refs,
              commentLigands ++ cofactorLigands ++ rpLigands ++ rLigands ++ 
              subsLigands ++ ligands,
              subunitAPs ++ aps)
           }, ([], [], [], []), os)
         }

        var (objects, objectReferences, objectLigands, objectAPs) =
          transformObjects(objects);

        var isAP = contains(objectAPs);
        var apObjs = query nested { queryObjects(fun(o) { isAP(o.object_id) }, (-1)) };
        var (relevantAPs, apReferences, apLigands, _) =
          transformObjects(apObjs);

        var objectBoxes =
          map(fun (r) { (objectSummary=r, objectBoxVisible=false) }, objects);
        var accessoryProteinBoxes =
          map(fun (r) { (objectSummary=r, objectBoxVisible=false) }, relevantAPs);

        # We need to parse the markup we get, and use it to
        # get the required information from the DB.
        var overviewMarkup = parseOrError(overview);
        var commentsMarkup = parseOrError(comments);
        var (oRefs, oLigands) = collectIds(overviewMarkup);
        var (cRefs, cLigands) = collectIds(commentsMarkup);
        var refs = uniquify(oRefs ++ cRefs ++ apReferences ++ objectReferences);
        var ligands = uniquify(oLigands ++ cLigands ++ apLigands ++ objectLigands);

        var references = queryReferences(refs);


        # References need to be numbered based on ordering.
        # This constructs a map from reference IDs to pairs of reference
        # numbers and references.
        var referenceData = mkReferenceData(references);
        var ligands = Ligand.queryLigands(ligands);

        # Species mapping is simple enough for us to just do in memory
        # and saves us the faff of doing joins.
        var speciesMap = Species.getSpeciesMap();
        var objectName = formatObjectName(type);

        Just((familyId=familyId, familyName=name, familyType=type,
           overview=mkTBox("Overview", true, overviewMarkup),
           objects=mkTBox(objectName, true,
             (objects = objectBoxes, accessoryProteins = accessoryProteinBoxes)),
           comments=mkTBox("Comments", true, commentsMarkup),
           furtherReading=mkTBox("Further Reading", true, furtherReading),
           showReferences=true,
           references=referenceData,
           contributors=mkTBox("Contributors", true, contributors),
           ligandNames = ligands,
           speciesMap=speciesMap))
    }
  }

  switch(lookup("familyId", environment())) {
    case Just(id) -> getFamilyInfo(stringToInt(id))
    case Nothing -> Nothing
  }
}

fun mainPage() {
  var initialModel = getInitialModel();
  runSimple("vdom_placeholder", initialModel, view, updt);
  template("Family Display")
}
