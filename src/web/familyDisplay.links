open import Reference;
open import Mvu;
open import MvuHTML;
open import MvuAttrs;
open import MvuEvents;
open import Tables;
open import Template;
open import RenderMarkup;
open import Parser;
open import Utility;
open import InteractionUtilities;
open import Ligand;
open import Species;
open import ToggleBox;
open import Contributor;
open import Object;
open import DbLinks;

# TO DO

## For objects
# Complexes
# Subunits
# Quaternary structure comments
# Bioparadigms SLC Tables
# Reactions
# Rank potencies
# Endogenous substrates
# Exogenous substrates
# Products
# Cofactors
# Stoichiometry
# Functional characteristics
# Comments
# Same entity ligands

## For ligands
# Ligand Id
# Name
# Common abbreviation
# Synonyms
# Complexes
# Subunits
# Genes
# PubChem CID
# UniProtKB AC


# DONE
# Target Id
# Genes
### Interactions
# Endogenous Ligands
# Ligands
# Sub/family-selective ligands
# Selective ligands
# Endogenous activators
# Activators
# Sub/family-selective activators
# Selective activators
# Endogenous inhibitors
# Inhibitors
# Sub/family-selective inhibitors
# Selective inhibitors
# Endogenous gating inhibitors
# Gating inhibitors
# Sub/family-selective gating inhibitors
# Selective gating inhibitors
# Endogenous agonists
# Agonists
# Sub/family-selective agonists
# Selective agonists
# Endogenous antagonists
# Antagonists
# Sub/family-selective antagonists
# Selective antagonists
# Endogenous channel blockers
# Channel blockers
# Sub/family-selective channel blockers
# Selective channel blockers
# Endogenous allosteric modulators
# Allosteric modulators
# Sub/family-selective allosteric modulators
# Whole organism assays
# Selective allosteric modulators
# Antibodies
# Sub/family-selective labelled ligands
# Labelled ligands
## Objects
# Common abbreviation
# Previous and unofficial names
# Principal Transduction (always show if a GPCR; show '-' if GPCR but unavailable)




typename ReferenceId = Int;
typename ReferenceNumber = Int;

typename ExternalRef = (
  refId: String,
  refSpeciesName: String,
  refUrl: String
);


typename Synonym = (synonymName: Markup, synonymOrder: Int, synonymReferences: [ReferenceId]);

var emptyER = (refId="", refSpeciesName="", refUrl="");

typename GeneRef = (geneName: Markup, geneSpeciesID: Int); # TODO: URL

typename ObjectSummary = (
   objectId: Int,
   rawObject: RawObject,
   objectType: ObjectType,
   objectSynonyms: [Synonym],
   objectGenes: [GeneRef],
   objectDBLinks: [DatabaseLink],
   objectPrincipalTransductions: [String],
   objectInteractions: [(String, [Interaction])], # (Type, Interactions)
   # Need to sort in-memory, since `orderby` not supported w/ shredding
   objectDisplayOrder: Int
  );

typename ObjectBox =
  (objectSummary: ObjectSummary, objectBoxVisible: Bool);

# BUG (hacky workaround): Type arguments don't appear to be renamed
typename Reference = Reference;
typename Markup = Parser.Markup;

typename Model =
  Maybe((familyId: Int,
         familyName: String,
         familyType: String,
         overview: ContentBox(Markup),
         objects: ContentBox([ObjectBox]),
         comments: ContentBox(Markup),
         furtherReading: ContentBox([Reference]),
         showReferences: Bool,
         references: [(ReferenceId, (ReferenceNumber, Reference))],
         contributors: ContentBox(Contributors),
         ligandNames: [(LigandId, LigandName)],
         speciesMap: SpeciesMap
        ));

typename Message = [|
    ToggleOverview | ToggleObjects | ToggleComments
  | ToggleFurtherReading | ToggleReferences | ToggleContributors
  | SetAllVisibilities:Bool
  | ToggleObjectSummary:Int
|];

fun withModel(model, f) {
  switch(model) {
    case Just(model) -> Just(f(model))
    case Nothing -> Nothing
  }
}

fun setBoxVisibilities(visible, model) {
  fun sbv(box) { setBoxVisibility(box, visible) }

  (model with
    overview=sbv(model.overview),
    objects=sbv(model.objects),
    comments=sbv(model.comments),
    furtherReading=sbv(model.furtherReading),
    showReferences=visible,
    contributors=sbv(model.contributors))
}

fun toggleObject(objectBox, id) {
  var contents = boxContents(objectBox);

  var newContents =
    map(fun(objectBox) {
      if (objectBox.objectSummary.objectId == id) {
        (objectBox with objectBoxVisible = not(objectBox.objectBoxVisible))
      } else {
        objectBox
      }
    }, contents);
  setContents(objectBox, newContents)
}

fun updt(msg, model) {
  withModel(model, fun(model) {
      switch(msg) {
        case ToggleOverview ->
          (model with overview=toggleBox(model.overview))
        case ToggleObjects ->
          (model with objects=toggleBox(model.objects))
        case ToggleComments ->
          (model with comments=toggleBox(model.comments))
        case ToggleFurtherReading ->
          (model with furtherReading=toggleBox(model.furtherReading))
        case ToggleReferences ->
          (model with showReferences=not(model.showReferences))
        case ToggleContributors ->
          (model with contributors=toggleBox(model.contributors))
        case SetAllVisibilities(vis) -> setBoxVisibilities(vis, model)
        case ToggleObjectSummary(id) ->
          (model with objects=toggleObject(model.objects, id))
      }
  })
}

sig view : (Model) ~%~> HTML(Message)
fun view(model) {
  var a0 = MvuAttrs.empty;
  var h0 = MvuHTML.empty;

  fun viewModel(model) {
    fun renderM(markup) {
        RenderMarkup.renderMarkup(markup,
          model.references, model.ligandNames)
    }

    # headerBox: Header information for given family
    var headerBox =
      div(class("grid_16 alpha"),
        a(name("top"), h0) +*
        div(class("contentboxfull"),
          h2(style("margin-top: 0px;"), textNode(model.familyName)) +*
          div(class("textright"),
            p(style("font-weight:normal;font-size:90%;"),
              textNode("Unless otherwise stated all data on this page refer to the human proteins. ") +*
              textNode("Gene information is provided for human (Hs), mouse (Mm) and rat (Rn).")) +*
            div(style("text-align:right;padding: 0px 5px 5px 0x;"),
              button(onClick(fun() { SetAllVisibilities(true) }), textNode("Expand all sections")) +*
              button(onClick(fun() { SetAllVisibilities(false) }), textNode("Collapse all sections"))
            )
          )));

    fun displayOverview(overviewMarkup) {
      p(class("grac_text"), renderM(overviewMarkup))
    }

    fun displayObjects(boxes) {

      fun displayObjectBox(box) {
        var summary = box.objectSummary;
        var toggleMsg = ToggleObjectSummary(summary.objectId);
        var showHideLink =
          if(box.objectBoxVisible) {
            a(onClick(fun() { toggleMsg }),
              span(class("object_summary_link"), textNode("  Hide summary")))
          } else {
            a(onClick(fun() { toggleMsg }),
              small(class("object_summary_link"), textNode("  Show summary")))
          };

        fun mkRow(name, contents) {
          table_(class("grac_data_table fullwidth"),
            tr(a0,
              td(class("grac_category_simple"), textNode(name)) +*
              td(class("grac_info_simple"), contents)))
        }

        fun mkStrRowIfNonempty(name, str) {
          if (str <> "") {
            mkRow(name, unescapedTextNode(str))
          } else {
            MvuHTML.empty
          }
        }

        fun showInteraction(x) {
          var interactionActionNode =
            if (not(x.interactionAction == "Agonist"
                  || x.interactionAction == "Antagonist")) {
              textNode(" (" ^^ x.interactionAction ^^ ")")
            } else { MvuHTML.empty };
          var speciesName = resolveSpeciesLongName(x.speciesID, model.speciesMap);
          var speciesNode =
            if (speciesName <> "Human") {
              textNode(" - " ^^ speciesName)
            } else {
              MvuHTML.empty
            };

          var affinityNode = {
            InteractionUtilities.displayAffinity(x.affinity, true)
          };

          var citationsNode =
            textNode(" ") +*
            renderCitationList(x.references, model.references);

          a(href("ligandDisplay?ligandId=" ^^
              intToString(x.ligandID)),
              unescapedTextNode(x.interactionLigand.name)) +*
          interactionActionNode +*
          affinityNode +*
          citationsNode +*
          speciesNode
        }

        fun mkInteractionRow(interactionType, interactions) {
          if (listEmpty(interactions)) {
            MvuHTML.empty
          } else {
            var renderedInteractions =
              MvuHTML.concat(map(fun(i) { tr(MvuAttrs.empty,
                    td(class("grac_info_simple"), showInteraction(i))) }, interactions));
            var interactionTable =
              table_(class("grac_inner_table"), renderedInteractions);

            mkRow(interactionType, interactionTable)
          }
        }

        var ptRow =
          if (summary.objectType == GPCR) {
              var contents =
                if (length(summary.objectPrincipalTransductions) > 0) {
                  MvuHTML.concat(map(fun(x) { unescapedTextNode(x) },
                    summary.objectPrincipalTransductions))
                } else {
                  textNode("-")
                };
              mkRow("Principal transduction", contents)
          } else {
            MvuHTML.empty
          };

        fun showSummary() {
          if (box.objectBoxVisible) {
            var synonyms = sortBy(fun(syn) { syn.synonymOrder }, summary.objectSynonyms);
            var synonyms = map(fun(x) {
                var citationNode =
                  if (length(x.synonymReferences) > 0) {
                    textNode(" ") +* renderCitationList(x.synonymReferences,
                        model.references)
                  } else { MvuHTML.empty };
                [renderM(x.synonymName) +* citationNode]
            }, synonyms);
            var separatedSynonyms = MvuHTML.concat(join([textNode(" | ")], synonyms));
            var genes = map(fun(gene) {
                var name = gene.geneName;
                var id = gene.geneSpeciesID;
              [renderM(name) +* textNode(" (" ^^ resolveSpeciesShortName(id, model.speciesMap) ^^ ")")]
              }, summary.objectGenes);
            var separatedGenes = MvuHTML.concat(join([textNode(", ")], genes));

            var nomenclature = {
              var o = summary.rawObject;
              if (o.systematic_name <> "") {
                if (o.name == o.systematic_name) {
                  mkRow("Nomenclature", unescapedTextNode(o.name)) +*
                  mkRow("Systematic nomenclature", unescapedTextNode(o.systematic_name))
                } else {
                  mkRow("Systematic nomenclature", unescapedTextNode(o.systematic_name))
                }
              } else {
                mkRow("Nomenclature", unescapedTextNode(o.name))
              }
            };

            fun mkIDRow(dbName, dbID) {
              switch(filter(fun(x) { x.dbID == dbID }, summary.objectDBLinks)) {
                case [] -> MvuHTML.empty
                case x :: _ ->
                  # <c:if test="${!empty object.uniprotIds}">
                  #     <tr>
                  #         <td class="grac_category_simple">UniProtKB AC</td>
                  #         <td class="grac_info_simple">
                  #           <%--  <c:choose>
                  #                 <c:when test="${!empty object.uniprotIds}">--%>
                  #                     <c:out value="${object.uniprotIds}" escapeXml="false"/>
                  #               <%--  </c:when>
                  #                 <c:otherwise>-</c:otherwise>
                  #             </c:choose>--%>
                  #         </td>
                  #     </tr>
                  # </c:if>

                  var links = renderEntries(x, model.speciesMap);
                  mkRow(dbName, links)
              }
            }

            var ensemblIDs = mkIDRow("Ensembl ID", 15);
            var uniprotIDs = mkIDRow("UniProtKB AC", 5);
            var plasmoIDs = mkIDRow("PlasmoDB", 64);
            var bitterIDs = mkIDRow("BitterDB", 54);

            var interactionRows =
              MvuHTML.concatMap(fun((name, xs)) { mkInteractionRow(name, xs) },
                  summary.objectInteractions);

            hr(class("divider_dashed"), MvuHTML.empty) +*
            mkRow("Target Id", textNode(intToString(summary.objectId))) +*
            nomenclature +*
            mkStrRowIfNonempty("Common abbreviation", summary.rawObject.abbreviation) +*
            mkRow("Previous and unofficial names", separatedSynonyms) +*
            mkRow("Genes", separatedGenes) +*
            ensemblIDs +*
            uniprotIDs +*
            plasmoIDs +*
            bitterIDs +*
            ptRow +*
            interactionRows
          } else {
            MvuHTML.empty
          }
        }

        tr(a0,
          td(class("grac_info"),
            p(class("grac_heading split_para"),
              unescapedTextNode(box.objectSummary.rawObject.name) +*
              span(class("cgtp"), textNode(" C")) +*
              showHideLink +*
              span(class("split_para_right_text detailed_view_link"),
                a(href("objectDisplay?objectId=" ^^ intToString(summary.objectId)),
                  textNode("More detailed page") +*
                  img(attr("src", "/images/go.jpg"), MvuHTML.empty)))) +*
              showSummary()
            ))
      }

      div(class("data_tables_container"),
        table_(class("receptor_data_tables fullwidth"),
          tbody(a0,
            MvuHTML.concat(
              map(fun(x) { displayObjectBox(x) }, boxes)))))
    }

    fun displayComments(commentMarkup) {
      p(class("grac_text"), renderM(commentMarkup))
    }

    fun displayFurtherReading(refs) {
      p(a0, textNode("* Key further reading is highlighted with an asterisk")) +*
      MvuHTML.concat(map(fun(x) {
        var prefixNode = if(x.isKey) { textNode("* ") } else { MvuHTML.empty };
        renderReference(prefixNode, x)
      }, refs))
    }

    var referencesBox =
      Reference.renderReferencesBox(
          model.showReferences,
          model.references,
          fun() { ToggleReferences });

    # (tboxName: String,  tboxVisible: Bool, contents: a);
    headerBox +*
    showBox(model.overview, ToggleOverview, displayOverview) +*
    showBox(model.objects, ToggleObjects, displayObjects) +*
    showBox(model.comments, ToggleComments, displayComments) +*
    showBox(model.furtherReading, ToggleFurtherReading, displayFurtherReading) +*
    referencesBox +*
    showBox(model.contributors, ToggleContributors, displayContributors)
  }

  switch(model) {
    case Just(model) -> viewModel(model)
    case Nothing -> p(a0, textNode("Invalid family ID."))
  }
}

fun formatObjectName(dbName) {
  switch (dbName) {
    case "gpcr" -> "Receptors"
    case "nhr" -> "Receptors"
    case "other_protein" -> "Targets"
    case "grouping" -> "Targets" # I think we need to handle this differently
    case "ligand" -> "Ligands"
    case "other_ic" -> "Channels and Subunits"
    case "enzyme" -> "Enzymes"
    case "transporter" -> "Transporters"
    case "vgic" -> "Channels and Subunits"
    case "lgic" -> "Channels and Subunits"
    case "catalytic_receptor" -> "Receptors"
    case _ -> "Targets"
  }
}


sig getInitialModel : () ~%~> Model
fun getInitialModel() {

  fun getFamilyInfo(familyId) {
    # First, grab the basic information.
    var basicInfo =
      query nested {
        for (f <-- Tables.family)
          where (f.family_id == familyId)
          [(name = f.name, type = f.type,
              grac_texts =
                for (g <-- Tables.grac_family_text)
                  where (g.family_id == familyId)
                  [g])]
      };

    switch(basicInfo) {
      case [] -> Nothing
      case x ::_ ->
        var name = x.name;
        var type = x.type;
        var (overview, comments) =
          switch (x.grac_texts) {
            case [] -> ("", "")
            case y :: _ -> (y.overview, y.comments)
          };
        # At this point, we need to populate the rest of the data
        # (further reading, contributors, and interaction data).
        ### Further reading
        var furtherReading =
          query nested {
            for (fr <-- Tables.grac_further_reading)
              where (fr.family_id == familyId)
              for (ref <-- Tables.reference)
                where (ref.reference_id == fr.reference_id)
                [
                  (makeReference(ref.reference_id,
                     ref.type, ref.title, ref.article_title, ref.year,
                     ref.volume, ref.issue, ref.pages, ref.publisher,
                     ref.publisher_address, ref.editors, ref.pubmed_id,
                     ref.isbn, ref.authors, fr.key_ref))
                ]
          };
        var furtherReading =
          sortBy(fun(ref) { ref.authors }, furtherReading);

        ### Contributors
        fun getContributors(t) {
          query nested {
            for (contrib <-- Tables.contributor_copy)
              where (contrib.contributor_id == t.contributor_id)
              orderby (-(t.display_order))
              [(resultId=contrib.contributor_id,
                resultName=(contrib.first_names ^^ " " ^^ contrib.surname),
                resultAddress=contrib.address,
                resultRole=t.role)]
          }
        }

        var subcommitteeMembers =
          query nested {
            for (t <-- Tables.subcommittee)
              where (t.family_id == familyId)
              getContributors(t)
          };

        var additionalContributors =
          query nested {
            for (t <-- Tables.contributor2family)
              where (t.family_id == familyId)
              getContributors(t)
          };

        fun mkContributor(res) {
          (contribId=res.resultId,
            contribName=res.resultName,
            contribAddress=parseOrError(res.resultAddress),
            contribRole=res.resultRole)
        }

        var subcommitteeMembers = map(mkContributor, subcommitteeMembers);
        var additionalContributors = map(mkContributor, additionalContributors);

        var (contributors: Contributors) =
          (subcommittee=subcommitteeMembers, additional=additionalContributors);

        # Object summaries
        var objects =
         query nested {
            for (r2f <-- receptor2family)
              where (r2f.family_id == familyId)
              for (o <-- object)
                where (o.object_id == r2f.object_id)
                [
                   (id=o.object_id,
                    =o,
                    nomenclature=o.name,
                    synonyms=
                     for (s <-- Tables.synonym)
                       where (s.object_id == o.object_id && s.display)
                       [(name=s.synonym, order=s.display_order, refs=
                          for (sr <-- Tables.synonym_refs)
                          where (s.synonym_id == sr.synonym_id)
                          [sr.reference_id])],
                    genes=
                      for (g <-- structural_info)
                        where (g.object_id == o.object_id)
                        [ (g.gene_name, g.species_id) ],
                   dbLinks =
                     for (dbl <-- Tables.database_link)
                     where (dbl.object_id == o.object_id)
                       [dbl],
                   principalTransductions=
                      for (tr <-- Tables.grac_transduction)
                        where (tr.object_id == o.object_id)
                        [tr.transduction],
                   interactions =
                     InteractionUtilities.interactionsForObject(o.object_id),
                   displayOrder=r2f.display_order)
                ]
         };

         sig transformInteractions : (%) ~%~> [(String, [Interaction])]
         fun transformInteractions(rawInteractions) {
           # Logic taken fairly directly from the GtoPdb source

           # filterWholeOrganismInteractions: is whole organism assay
           fun isWholeOrganism(i) {
             i.wholeOrganismAssay
           }
           # filterInteractions: Type equal, not whole organism assay
           fun typeEquals(i, ty) {
             not(i.wholeOrganismAssay) && i.interactionType == ty
           }
           # getGracProbes: Labelled, selectivity null or not family selective,
           #   and not whole organism assay
           fun isGracProbe(i) {
             i.interactionLigand.labelled && i.selectivity <> "Family selective"
               && not(i.wholeOrganismAssay)
           }

           # getGracFamilySelectiveProbes: Labelled, selectivity is family
           #   selective, not whole organism assay
           fun isGracFamilySelectiveProbe(i) {
             i.interactionLigand.labelled && i.selectivity == "Family selective"
               && not(i.wholeOrganismAssay)
           }

           # filterGracInteractions: Type equal, not labelled, not whole org
           #   assay
           fun gracTypeEquals(i, ty) {
             i.interactionType == ty && not(i.interactionLigand.labelled) &&
               not(i.wholeOrganismAssay)
           }

           # filterGracNonSelectiveInteractions: Type equals, not labelled,
           #  selectivity empty or Not Determined or Non-selective and not
           #  endogenous and not whole organism assay
           fun gracNonSelective(i, ty) {
             i.interactionType == ty && not(i.interactionLigand.labelled) &&
               (i.selectivity == "" || i.selectivity == "Not Determined" ||
                i.selectivity == "Non-selective") && not(i.endogenous) &&
               not(i.wholeOrganismAssay)
           }

           # filterGracEndogenousInteractions: Type equals, not labelled,
           #  endogenous, not whole organism assay
           fun gracEndogenous(i, ty) {
             i.interactionType == ty && not(i.interactionLigand.labelled) &&
               i.endogenous && not(i.wholeOrganismAssay)
           }

           # filterGracSelectiveInteractions: Type equals, not labelled,
           #  selectivity is Selective or Isotope selectivity, not endogenous,
           #  not whole organism assay
           fun gracSelective(i, ty) {
             i.interactionType == ty && not(i.interactionLigand.labelled) &&
               (i.selectivity == "Selective" ||
                i.selectivity == "Isotope selectivity") &&
             not(i.endogenous) && not(i.wholeOrganismAssay)
           }

           # filterGracFamilySelectiveInteractions: Type equals, not labelled,
           #  selectivity is "Family selective", not endogenous, not whole
           #  organism assay
           fun gracFamilySelective(i, ty) {
             i.interactionType == ty && not(i.interactionLigand.labelled) &&
               i.selectivity == "Family selective" && not(i.endogenous) &&
               not(i.wholeOrganismAssay)
           }

           fold_right(fun(x, acc) {
              fun addToListMap(xs, name, toAdd) {
                switch(xs) {
                  case [] -> [(name, [toAdd])]
                  case (category_name, ys) :: xs ->
                    if (category_name == name) {
                      (category_name, toAdd :: ys) :: xs
                    } else {
                      (category_name, ys) :: addToListMap(xs, name, toAdd)
                    }
                }
              }
              fun add(name, toAdd) {
                addToListMap(acc, name, toAdd)
              }

              var x = InteractionUtilities.makeInteraction(x);
              if (not(x.fromGrac)) {
                acc
              # Endogenous Ligands
              } else if (gracEndogenous(x, "None")) {
                add("Endogenous ligands", x)
              # Ligands
              } else if (gracNonSelective(x, "None")) {
                add("Ligands", x)
              # Sub/family-selective ligands
              } else if (gracFamilySelective(x, "None")) {
                add("Sub/family-selective ligands", x)
              # Selective ligands
              } else if (gracSelective(x, "None")) {
                add("Selective ligands", x)
              # Endogenous activators
              } else if (gracEndogenous(x, "Activator")) {
                add("Endogenous activators", x)
              # Activators
              } else if (gracNonSelective(x, "Activator")) {
                add("Activators", x)
              # Sub/family-selective activators
              } else if (gracFamilySelective(x, "Activator")) {
                add("Sub/family-selective activators", x)
              # Selective activators
              } else if (gracSelective(x, "Activator")) {
                add("Selective activators", x)
              # Endogenous inhibitors
              } else if (gracEndogenous(x, "Inhibitor")) {
                add("Endogenous inhibitors", x)
              # Inhibitors
              } else if (gracNonSelective(x, "Inhibitor")) {
                add("Inhibitors", x)
              # Sub/family-selective inhibitors
              } else if (gracFamilySelective(x, "Inhibitor")) {
                add("Sub/family-selective inhibitors", x)
              # Selective inhibitors
              } else if (gracSelective(x, "Inhibitor")) {
                add("Selective inhibitors", x)
              # Endogenous gating inhibitors
              } else if (gracEndogenous(x, "Gating inhibitor")) {
                add("Endogenous gating inhibitors", x)
              # Gating gating inhibitors
              } else if (gracNonSelective(x, "Gating inhibitor")) {
                add("Gating inhibitors", x)
              # Sub/family-selective gating inhibitors
              } else if (gracFamilySelective(x, "Gating inhibitor")) {
                add("Sub/family-selective gating inhibitors", x)
              # Selective gating inhibitors
              } else if (gracSelective(x, "Gating inhibitor")) {
                add("Selective gating inhibitors", x)
              # Endogenous agonists
              } else if (gracEndogenous(x, "Agonist")) {
                add("Endogenous agonists", x)
              # Agonists
              } else if (gracNonSelective(x, "Agonist")) {
                add("Agonists", x)
              # Sub/family-selective agonists
              } else if (gracFamilySelective(x, "Agonist")) {
                add("Sub/family-selective agonists", x)
              # Selective agonists
              } else if (gracSelective(x, "Agonist")) {
                add("Selective agonists", x)
              # Endogenous antagonists
              } else if (gracEndogenous(x, "Antagonist")) {
                add("Endogenous antagonists", x)
              # Antagonists
              } else if (gracNonSelective(x, "Antagonist")) {
                add("Antagonists", x)
              # Sub/family-selective antagonists
              } else if (gracFamilySelective(x, "Antagonist")) {
                add("Sub/family-selective antagonists", x)
              # Selective antagonists
              } else if (gracSelective(x, "Antagonist")) {
                add("Selective antagonists", x)
              # Endogenous channel blockers
              } else if (gracEndogenous(x, "Channel blocker")) {
                add("Endogenous channel blockers", x)
              # Channel blockers
              } else if (gracNonSelective(x, "Channel blocker")) {
                add("Channel blockers", x)
              # Sub/family-selective channel blockers
              } else if (gracFamilySelective(x, "Channel blocker")) {
                add("Sub/family-selective channel blockers", x)
              # Selective channel blocker
              } else if (gracSelective(x, "Channel blocker")) {
                add("Selective channel blockers", x)
              # Endogenous allosteric modulators
              } else if (gracEndogenous(x, "Allosteric modulator")) {
                add("Endogenous allosteric modulators", x)
              # Allosteric modulators
              } else if (gracNonSelective(x, "Allosteric modulator")) {
                add("Allosteric modulators", x)
              # Sub/family-selective allosteric modulators
              } else if (gracFamilySelective(x, "Allosteric modulator")) {
                add("Sub/family-selective allosteric modulators", x)
              # Selective allosteric modulators
              } else if (gracSelective(x, "Allosteric modulator")) {
                add("Selective allosteric modulators", x)
              } else if (typeEquals(x, "Antibody")) {
                add("Antibodies", x)
              } else if (gracFamilySelective(x, "Allosteric modulator")) {
                add("Sub/family-selective allosteric modulators", x)
              } else if(isGracFamilySelectiveProbe(x)) {
                add("Sub/family-selective labelled ligands", x)
              } else if (isGracProbe(x)) {
                add("Labelled ligands", x)
              } else {
                acc
              }
           }, [], rawInteractions)
         }

         # Rather silly to do the sorting during the render function!
         var objects = map(fun(r) {
            (
                objectId=r.id,
                objectType = Object.classifyObject(r.id),
                rawObject=r.o,
                objectSynonyms=
                  map(fun (s) { (synonymName=parseOrError(s.name),
                        synonymOrder=s.order, synonymReferences=s.refs) }, r.synonyms),
                objectGenes=
                  map(fun ((name, id)) { (geneName = parseOrError(name), geneSpeciesID = id) }, r.genes),
                objectDBLinks = transformDatabaseLinks(r.dbLinks),
                objectPrincipalTransductions= r.principalTransductions,
                objectInteractions = transformInteractions(r.interactions),
                objectDisplayOrder=r.displayOrder
            )
          }, objects);

        var objectReferences = listConcatMap(fun (object) {
            listConcatMap(fun((name, xs)) { 
                  listConcatMap(fun(y) { y.references }, xs)
                  }, object.objectInteractions) ++
            listConcatMap(fun (synonym) { synonym.synonymReferences },
                object.objectSynonyms)
        }, objects);

        var objectBoxes =
          map(fun (r) { (objectSummary=r, objectBoxVisible=false) },
            objects);

        # We need to parse the markup we get, and use it to
        # get the required information from the DB.
        var overviewMarkup = parseOrError(overview);
        var commentsMarkup = parseOrError(comments);
        var (oRefs, oLigands) = collectIds(overviewMarkup);
        var (cRefs, cLigands) = collectIds(commentsMarkup);
        var refs = uniquify(oRefs ++ cRefs ++ objectReferences);
        var ligands = uniquify(oLigands ++ cLigands);

        var references = queryReferences(refs);


        # References need to be numbered based on ordering.
        # This constructs a map from reference IDs to pairs of reference
        # numbers and references.
        var referenceData = mkReferenceData(references);
        var ligands = Ligand.queryLigands(ligands);

        # Species mapping is simple enough for us to just do in memory
        # and saves us the faff of doing joins.
        var speciesMap = Species.getSpeciesMap();
        var objectName = formatObjectName(type);

        Just((familyId=familyId, familyName=name, familyType=type,
           overview=mkTBox("Overview", true, overviewMarkup),
           objects=mkTBox(objectName, true, objectBoxes),
           comments=mkTBox("Comments", true, commentsMarkup),
           furtherReading=mkTBox("Further Reading", true, furtherReading),
           showReferences=true,
           references=referenceData,
           contributors=mkTBox("Contributors", true, contributors),
           ligandNames = ligands,
           speciesMap=speciesMap))
    }
  }

  switch(lookup("familyId", environment())) {
    case Just(id) -> getFamilyInfo(stringToInt(id))
    case Nothing -> Nothing
  }
}

fun mainPage() {
  var initialModel = getInitialModel();
  runSimple("vdom_placeholder", initialModel, view, updt);
  template("Family Display")
}
