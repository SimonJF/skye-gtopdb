# Detailed information about objects (i.e., ligand targets: receptors,
# ion channels, etc.)


### Done
# Gene and protein information
# Previous and unofficial names
# Database Links
# 3D structures
# Associated Proteins
# Primary regulators
# Enzyme reactions
# Substrates and Reaction Kinetics
# Products
# Cofactors
# Functional Characteristics
# Stoichiometry
# immuno comments
# immuno cell type assocs
# immuno process assocs
# immuno disease assocs
# malaria comments
# transduction mechanisms
# biologically significant variants
# general comments
# agonists
# antagonists
# tissue distribution
# functional assays
# physiological functions
# physiological consequences of altering (mutations)
# Ion selectivity and conductance
# Natural / endogenous ligands
# main co-regulators
# co-binding partners
# dna binding
# main target genes
# xenobiotics
## activators
## inhibitors
## gating inhibitors
## channel blockers
## allosteric modulators
## subunit-specific
## antibodies
## other binding ligands
# Quaternary structure
# Single channel conductance
# voltage dependence
# rank order lists
# whole organism assay data
# gene expression / pathophysiology
# expression datasets
# screening data

## Not done

# phenotypes, alleles, disease models
# clinically-relevant mutations

open import Parser;
open import RenderMarkup;
open import Reference;
open import DataTable;
open import Contributor;
open import InteractionUtilities;
open import Transduction;
open import Utility;
open import MvuHTML;
open import MvuAttrs;
open import MvuCommands;
import MvuSubscriptions;
open import Mvu;
open import Template;
open import Ligand;
open import Species;
open import ToggleBox;
open import AnnotationStatus;
open import DbLinks;
open import Object;
open import Tables;
open import SimpleTable;


## Data model

typename ObjectID = Int;

typename GPCRInfo = (class: Markup, ligand: String);

typename VGICInfo =
  (physiologicalIon: String, selectivityComments: Markup, voltageDependenceComments: Markup);

typename LGICInfo =
  (ligand: String, selectivityComments: Markup);

typename OtherICInfo = (selectivityComments: Markup);

typename TransporterInfo = (stoichiometry: Markup);

typename NHRInfo =
  (ligand: String, bindingPartnerComments: Markup, coregulatorComments: Markup,
   dnaBindingComments: Markup, targetGeneComments: Markup);

typename ObjectType = [|
  GPCR:GPCRInfo | VGIC:VGICInfo | LGIC:LGICInfo | OtherIC:OtherICInfo | Enzyme
  | CatalyticReceptor:DbCatalyticReceptor | Transporter:TransporterInfo | NHR:NHRInfo | Other
|];

typename Table = [|
  # Interaction Tables
    AgonistsTable         | AntagonistsTable | AllostericModulatorsTable
  | ActivatorsTable       | InhibitorsTable  | ChannelBlockersTable
  | GatingInhibitorsTable | SubunitSpecificTable
  | AntibodiesTable | OtherBindingLigandTable | WholeOrganismAssaysTable
  # Other Tables
  | SubstratesTable
  | CofactorsTable
|];

typename ColumnName = String;
typename ScreenID = Int;
typename ScreenTableName = String;

typename Message = [|
    NoOp
  | SortTable:(Table, ColumnName, SortDirection)
  | ToggleReferences | ToggleContributors | ToggleShowIEA:Int | ShowCharts
  | SortScreenTable:(ScreenID, ScreenTableName, ColumnName, SortDirection)
|];

typename Family = (familyId: Int, familyName: Markup);
typename AnnotationStatus = Int; # TODO: More meaningful datatype here
typename LigandID = Int;
typename SpeciesID = Int;
typename PDBID = String;
typename TissueName = String;

typename GeneProteinInfo = (
    gpiSpeciesID: Int,
    gpiSymbol: String,
    gpiShortName: String,
    gpiName: Markup,
    gpiTransmembraneDomains: Int,
    gpiAminoAcids: Int,
    gpiReferences: [ReferenceID],
    gpiChromosomalLocation: String
);

typename PDBData = (
    pdbCode: PDBID,
    pdbLigandId: Int,
    pdbLigandName: Markup,
    pdbLigandDescription: Markup,
    pdbSpeciesId: SpeciesID,
    pdbReferences: [ReferenceID],
    pdbResolution: Float
);

typename EndogenousLigandSummary =
  (elsName: Markup, elsSpeciesID: SpeciesID, elsLigandID: LigandID);

typename Phenotype = (
    phenoAllele: Markup,
    phenoComposition: Markup,
    phenoAccessions: Markup,
    phenoSpeciesID: SpeciesID,
    phenoPubmedID: String,
    phenoPhenotype: Markup
);

typename CellTypeAssociation = (
  ctaImmunoCelltype: (immunoCTID: Int, immunoCTName: String),
  ctaComments: Markup,
  ctaCellOntologyType: (cellOntologyName: String, cellOntologyID: String),
  ctaReferences: [ReferenceID]
);


typename ImmunoProcessAssociation = (
  ipImmunoProcess: (immunoProcessID: Int, immunoProcessName: String),
  ipShowIEA: Bool,
  ipGoProcesses: [
    (goProcessID: String,
     goProcessComment: String,
     goProcessEvidence: String)
  ],
  ipReferences: [ReferenceID]
);



typename InteractionInfo = (
  interaction: Interaction,
  parsedName: Markup,
  ligandSize: LigandSize,
  speciesShort: String
);

typename SortedInteractions = (
  agonists: SortableTable(InteractionInfo, Message),
  antagonists: SortableTable(InteractionInfo, Message),
  allostericModulators: SortableTable(InteractionInfo, Message),
  activators: SortableTable(InteractionInfo, Message),
  inhibitors: SortableTable(InteractionInfo, Message),
  channelBlockers: SortableTable(InteractionInfo, Message),
  gatingInhibitors: SortableTable(InteractionInfo, Message),
  antibodies: SortableTable(InteractionInfo, Message),
  other: SortableTable(InteractionInfo, Message),
  wholeOrganismAssays: SortableTable(InteractionInfo, Message),
  subunitSpecific: SortableTable(InteractionInfo, Message));

typename AssociatedProtein = (
  name: Markup,
  objectID : Maybe(Int),
  references : [ReferenceID],
  effect: Markup
);

typename SortedAssociatedProteins = (
  hpfSubunits: [AssociatedProtein],
  auxiliarySubunits: [AssociatedProtein],
  otherProteins: [AssociatedProtein],
  gProteins: [AssociatedProtein],
  interactingProteins: [AssociatedProtein]
);

typename SpecificReaction = (
  description: Markup,
  reaction: Markup,
  references: [ReferenceID]
);

typename EnzymeReaction = (
  ecNumber: String,
  reaction: Markup,
  specificReactions: [SpecificReaction]
);

typename Product = (
  name: Markup,
  ligandID: Int,
  endogenous: Bool,
  speciesName: String,
  references: [ReferenceID]
);

typename Cofactor = (
  name: Markup,
  ligandID: Int,
  speciesName: String,
  comments: Markup,
  references: [ReferenceID]
);

# TODO: This can be made into a DataTableBox.
typename Variant = (
    vId: Int,
    vType: String,
    vSpecies: SpeciesID,
    vDescription: Markup,
    vReferences: [ReferenceID]
);

typename ReceptorComments = (
  listComments: Markup,
  associatedProteinsComments: Markup,
  functionalAssayComments: Markup,
  tissueDistributionComments: Markup,
  functionsComments: Markup,
  alteredExpressionComments: Markup,
  expressionPathophysiologyComments: Markup,
  mutationsPathophysiologyComments: Markup,
  variantsComments: Markup,
  xenobioticExpressionComments: Markup,
  antibodyComments: Markup,
  agonistsComments: Markup,
  antagonistsComments: Markup,
  allostericModulatorsComments: Markup,
  activatorsComments: Markup,
  inhibitorsComments: Markup,
  channelBlockersComments: Markup,
  gatingInhibitorsComments: Markup,
  generalComments: Markup,
  immunoComments: Markup,
  malariaComments: Markup,
  functionalCharacteristicsComments: Markup
);

typename DataTableEntry = (
  entryComment: Markup,
  entryData: [(String, Markup)],
  entryReferences: [ReferenceID]
);

typename DataTableBox = (
    boxName: String,
    boxRows: [DataTableEntry]
);

typename Substrate = (
    name: Markup,
    ligandID: Int,
    endogenous: Bool,
    species: String,
    property: Markup,
    value: Float,
    units: Markup,
    standardProperty: Markup,
    standardValue: Float,
    assayDescription: Markup,
    assayConditions: Markup,
    comments: Markup,
    references: [ReferenceID]
);

typename URL = String;


typename SelectivitySummary =
  (speciesName: String, rankOrder: String, references: [ReferenceID]);

typename ConductanceInfo =
  (speciesName: String, data: Markup, references: [ReferenceID]);

typename SelectivityInfo =
  (summaries: [SelectivitySummary],
   singleChannelConductance: [ConductanceInfo],
   singleChannelCurrentRectification: [ConductanceInfo],
   macroscopicCurrentRectification: [ConductanceInfo],
   selectivityComments: Markup);


typename CoregulatorGene = (
  coregulatorGeneID: Int,
  primaryName: String,
  officialGeneID: String,
  otherNames: String,
  speciesName: String,
  nursaID: String,
  comments: Markup,
  geneLongName: String
);

typename Coregulator =
  (coregulatorID: Int,
   activity: Markup,
   specific: Bool,
   ligandDependent: Bool,
   af2Dependent: Bool,
   comments: Markup,
   gene: CoregulatorGene);

typename SubunitInfo = (id: Int, name: String, type: String);

typename QuaternaryStructure = (
  complexes: [SubunitInfo],
  subunits: [SubunitInfo],
  comments: Markup
);

typename ConductanceRange = (low: Float, high: Float, mostFrequent: Bool);

typename ConductanceState = (
  receptor: String,
  state1: ConductanceRange,
  state2: ConductanceRange,
  state3: ConductanceRange,
  state4: ConductanceRange,
  state5: ConductanceRange,
  state6: ConductanceRange,
  references: [ReferenceID]
);

typename ThreeValueRange =
  (low: Float, median: Float, high: Float);

typename TwoValueRange = (low: Float, high: Float);

typename VoltageDependenceRange =
  (vRange: ThreeValueRange, tRange: TwoValueRange, refs: [ReferenceID]);

typename VoltageDependence =
  (cellType: String,
   speciesID: SpeciesID,
   activationRange: VoltageDependenceRange,
   inactivationRange: VoltageDependenceRange,
   deactivationRange: VoltageDependenceRange,
   comments: Markup);

typename PotencyOrder =
  (description: Markup,
   potencyOrder: Markup,
   speciesID: SpeciesID,
   references: [ReferenceID]);

typename GeneExpression =
  (geneName: String,
   description: String,
   technique: String,
   speciesID: SpeciesID,
   baseline: Float,
   data: [(TissueName, Float)]);


typename ParsedScreenInteraction =
  (interaction: InteractionUtilities.ScreenInteraction,
   speciesShort: String,
   ligandSize: LigandSize);

typename Screen =
  (id: Int,
   name: String,
   description: String,
   url: String,
   affinityCutoff: Int,
   companyLogoFilename: String,
   technologyLogoFilename: String,
   references: [ReferenceID],
   data: [(String, SortableTable(ParsedScreenInteraction, Message))]);

typename Allele = (
    id: Int,
    composition: String,
    accessions: String,
    speciesID: Int,
    pubmedIDs: String,
    phenotypeID: String,
    phenotype: String
  );

typename ObjectInfo = (
    objectId: Int,
    objectType: ObjectType,
    objectName: Markup,
    objectSystematicName: Maybe(Markup),
    objectAbbreviation: Maybe(Markup),
    objectSynonyms: [Markup],
    objectFamily: Family,
    objectAnnotationStatus: AnnotationStatus,
    objectGeneProteinInfo:
      (giComments: Markup, giEntries: [GeneProteinInfo]),
    objectAssociatedProteins: SortedAssociatedProteins,
    objectEnzymeReactions: [EnzymeReaction],
    objectQuaternaryStructure: QuaternaryStructure,
    objectDatabaseLinks: [DatabaseLink],
    objectPDBData: [PDBData],
    objectEndogenousLigands: [EndogenousLigandSummary],
    objectPotencyOrder: [PotencyOrder],
    objectSortedInteractions: SortedInteractions,
    objectTransductionMechanisms: [TransductionMechanism],
    objectTissueDistribution: DataTableBox,
    objectCellTypeAssociations: [CellTypeAssociation],
    objectImmunoProcessAssociations: [ImmunoProcessAssociation],
    objectGeneExpression: [GeneExpression],
    objectFunctionalAssays: DataTableBox,
    objectPhysiologicalFunctions: DataTableBox,
    objectPhysiologicalConsequences: DataTableBox,
    objectDNABindings: DataTableBox,
    objectPhysiologicalConsequences: DataTableBox,
    objectExpressionPathophysiology: DataTableBox,
    objectVariants: [Variant],
    objectComments: ReceptorComments,
    objectShowReferences: Bool,
    objectReferences: [(ReferenceID, (ReferenceNumber, Reference.Reference))],
    objectLigandNames: [(LigandId, LigandName)],
    objectSpeciesMap: SpeciesMap,
    objectSubstrates: SortableTable(Substrate, Message),
    objectProducts: [Product],
    objectCofactors: SortableTable(Cofactor, Message),
    objectSelectivityInfo: SelectivityInfo,
    objectCoregulators: SimpleTable,
    objectBindingPartners: SimpleTable,
    objectTargetGenes: SimpleTable,
    objectXenobioticExpressions: DataTableBox,
    objectConductanceStates: [ConductanceState],
    objectVoltageDependence: [VoltageDependence],
    objectContributors: ContentBox([Contributor.Contributor]),
    objectScreens: [Screen],
    # objectAlleles: SortableTable(Allele, Message),
    chartsShown: Bool
);

## FFI Stuff

# Needed to ensure that virtual-dom is open
module Highcharts {
  alien javascript "/js/highcharts.js" {
    dummy : ();
  }
}

# Loads the "vdom.js" file, exposes runDom and updateDom.
module HighchartsWrapper {
  alien javascript "/js/highchartsWrapper.js" {
     renderChart : (GeneExpression, String) ~> ();
  }
}



typename Model = Maybe(ObjectInfo);

sig getInitialModel : () ~%~> Model
fun getInitialModel() {

  sig getObjectInfo : (Int) ~%~> Maybe(ObjectInfo)
  fun getObjectInfo(objectId) {
    var defaultRB =
      (object_id=objectId,
       list_comments="",
       associated_proteins_comments="",
       functional_assay_comments="",
       tissue_distribution_comments="",
       functions_comments="",
       altered_expression_comments="",
       expression_pathophysiology_comments="",
       mutations_pathophysiology_comments="",
       variants_comments="",
       xenobiotic_expression_comments="",
       antibody_comments="",
       agonists_comments="",
       antagonists_comments="",
       allosteric_modulators_comments="",
       activators_comments="",
       inhibitors_comments="",
       channel_blockers_comments="",
       gating_inhibitors_comments="");

    # Each object should have at most one `receptor_basic` entry.
    # If there aren't any, we need to (manually) create a dummy one.
    fun rbOrDefault(rbs) {
      switch(rbs) {
        case [] -> defaultRB
        case x :: _ -> x
      }
    }

    var raw = query {
      for (o <-- Tables.object)
        where (o.object_id == objectId)
        for (rb <-- Tables.receptor_basic)
          where (rb.object_id == objectId)
            [(id = objectId,
             name = o.name,
             abbreviation = o.abbreviation,
             systematicName = o.systematic_name,
             comments = o.comments,
             grac_comments = o.grac_comments,
             immuno_comments = o.gtip_comment,
             malaria_comments = o.gtmp_comment,
             quaternary_structure_comments = o.quaternary_structure_comments,
             associatedProteins =
               for (ap <-- Tables.associated_protein)
                 where (ap.object_id == objectId)
                 [(protein = ap,
                   assocObjects =
                     for (ao <-- Tables.object)
                       where (ao.object_id == ap.associated_object_id)
                       [ao],
                   refs =
                     for (r <-- Tables.associated_protein_refs)
                       where (r.associated_protein_id == ap.associated_protein_id)
                       [r.reference_id])],
             synonyms =
               for (s <-- Tables.synonym)
                 where (s.object_id == objectId && s.display)
                 [(synonym=s.synonym, order=s.display_order)],
             family =
               for (r2f <-- Tables.receptor2family)
                 where (r2f.object_id == o.object_id)
                   for (f <-- Tables.family)
                     where (f.family_id == r2f.family_id)
                     [(id=f.family_id, name=f.name)],
             enzymeReactions =
               for (o2r <-- Tables.object2reaction)
                 where (o2r.object_id == objectId)
                 for (r <-- Tables.reaction)
                   where (r.reaction_id == o2r.reaction_id)
                   [(reaction = r,
                     specificReactions =
                       for (sr <-- Tables.specific_reaction)
                         where (sr.reaction_id == r.reaction_id && sr.object_id == objectId)
                         [(sr = sr,
                           refs =
                             for (srr <-- Tables.specific_reaction_refs)
                               where (srr.specific_reaction_id == sr.specific_reaction_id)
                               [srr.reference_id])])],
             annotationStatus = o.annotation_status,
             generalComments = o.comments,
             geneInformation =
               for (si <-- Tables.structural_info)
                 where (si.object_id == objectId)
                 [(si=si,
                   expressionLevel =
                     for (el <-- Tables.expression_level)
                     where (el.structural_info_id == si.structural_info_id)
                       for (t <-- Tables.tissue)
                       where (t.tissue_id == el.tissue_id)
                         for (experiment <-- Tables.expression_experiment)
                         where (experiment.expression_experiment_id == el.expression_experiment_id)
                           [(=el, tissueName = t.name, =experiment)],
                   refs =
                     for (siRef <-- Tables.structural_info_refs)
                       where (siRef.structural_info_id == si.structural_info_id)
                       [siRef.reference_id])],
             databaseLinks =
               for (dbl <-- Tables.database_link)
                 where (dbl.object_id == objectId)
                   [dbl],
             pdbData =
               for (pdb <-- Tables.pdb_structure)
                 where (pdb.object_id == objectId)
                 for (l <-- Tables.ligand)
                   where (l.ligand_id == pdb.ligand_id)
                   [(pdb = pdb,
                     ligand = l,
                     refs =
                       for (pdbR <-- Tables.pdb_structure_refs)
                         where (pdbR.pdb_structure_id == pdb.pdb_structure_id)
                         [pdbR.reference_id])],
             potencyOrder =
               for (p <-- Tables.grac_ligand_rank_potency)
                 where (p.object_id == objectId)
                   [(=p,
                     refs =
                       for (r <-- Tables.grac_ligand_rank_potency_refs)
                       where (r.grac_ligand_rank_potency_id == p.grac_ligand_rank_potency_id)
                       [r.reference_id])],
             receptorBasic = rb,
             cellTypeAssociations =
               for (cta <-- Tables.celltype_assoc)
               where (cta.object_id == objectId)
                 for (ctac <-- Tables.celltype_assoc_colist)
                 where (ctac.celltype_assoc_id == cta.celltype_assoc_id)
                   for (ct <-- Tables.co_celltype)
                   where (ct.cellonto_id == ctac.cellonto_id)
                     for (immuno <-- Tables.immuno_celltype)
                     where (immuno.immuno_celltype_id == cta.immuno_celltype_id)
                     [( ctaComment = cta.comment,
                        cellType = ct,
                        immuno = immuno,
                        refs =
                          for (car <-- Tables.celltype_assoc_refs)
                          where (car.celltype_assoc_id == cta.celltype_assoc_id)
                          [car.reference_id]
                      )],
             immunoProcessAssociations =
               for (pa <-- Tables.process_assoc)
               where (pa.object_id == objectId)
                 for (gtip <-- Tables.gtip_process)
                 where (gtip.gtip_process_id == pa.gtip_process_id)
                   # Relevant immuno processes
                   [( gtipProc = gtip,
                      goProcs =
                        # FIXME: This doesn't quite work; we also need to do something with
                        # go_process_rel.
                        # GO immuno processes associated with relevant GTIP processes,
                        # where the GO processes are associated with the given object.
                        # (Just because a GO process is associated with a GTIP process,
                        # does not mean that it's relevant for a given object).
                        for (g2go <-- Tables.gtip2go_process)
                        where (g2go.gtip_process_id == gtip.gtip_process_id)
                          for (o2go <-- Tables.object2go_process)
                          where (o2go.object_id == objectId && o2go.go_process_id == g2go.go_process_id)
                            for (go <-- Tables.go_process)
                            where (go.go_process_id == o2go.go_process_id)
                            [(o2go = o2go, go = go)],
                      refs =
                        for (r <-- Tables.process_assoc_refs)
                        where (r.process_assoc_id == pa.process_assoc_id)
                        [r.reference_id])],
             interactions = InteractionUtilities.interactionsForObject(objectId),
             tissueDistribution =
               for (td <-- Tables.tissue_distribution)
                 where (td.object_id == objectId)
                   [(td = td,
                     refs =
                       for (r <-- Tables.tissue_distribution_refs)
                         where (r.tissue_distribution_id == td.tissue_distribution_id)
                         [r.reference_id])],
             expressionDataset = (), # FIXME: FILL ME IN
             functionalAssays =
               for (fa <-- Tables.functional_assay)
                 where (fa.object_id == objectId)
                   [(fa=fa, refs=
                       for (faRef <-- Tables.functional_assay_refs)
                         where (faRef.functional_assay_id == fa.functional_assay_id)
                         [faRef.reference_id])],
             physiologicalFunctions =
               for (pf <-- Tables.physiological_function)
                 where (pf.object_id == objectId)
                   [(pf = pf,
                     refs =
                       for (pfRef <-- Tables.physiological_function_refs)
                         where (pfRef.physiological_function_id == pf.physiological_function_id)
                         [pfRef.reference_id])],
             alteredExpressions =
               for (ae <-- Tables.altered_expression)
                 where (ae.object_id == objectId)
                   [(ae = ae,
                     refs =
                       for (aeRef <-- Tables.altered_expression_refs)
                         where (aeRef.altered_expression_id == ae.altered_expression_id)
                         [aeRef.reference_id])],
             alleles =
               for (strI <-- Tables.structural_info)
                 where (strI.object_id == objectId && strI.species_id == 2) # 2: Mouse
                 for (al <-- Tables.allele)
                   # The following isn't quite right as accessions is in fact a comma-separated
                   # list, and unfortunately regexes don't yet work in nested queries (sigh.)
                   # It's a reasonable approximation though so we should be OK until we get the bugfix.
                   where (al.accessions == strI.official_gene_id)
                   for (ot <-- Tables.ontology_term)
                     where (ot.ontology_id == al.ontology_id)
                     [(=strI, =al, =ot,
                       refs =
                        for (r <-- Tables.structural_info_refs)
                        where (r.structural_info_id == strI.structural_info_id)
                        [r.reference_id])],
             variants =
               for (v <-- Tables.variant)
                 where (v.object_id == objectId)
                   [(v=v,
                     refs =
                       for (vRef <-- Tables.variant_refs)
                         where (vRef.variant_id == v.variant_id)
                         [vRef.reference_id])],
             substrates =
               for (s <-- Tables.substrate)
                 where (s.object_id == objectId)
                   [(substrate = s,
                     ligand =
                       for (l <-- Tables.ligand)
                       where (l.ligand_id == s.ligand_id)
                       [l],
                     refs =
                       for (sr <-- Tables.substrate_refs)
                         where (sr.substrate_id == s.substrate_id)
                         [sr.reference_id])],
             contributors =
               for (c2o <-- Tables.contributor2object)
                 where (c2o.object_id == objectId)
                   for (c <-- Tables.contributor_copy)
                     where (c.contributor_id == c2o.contributor_id)
                     [(c = c, order=c2o.display_order)],
              functionalCharacteristics =
                for (gfc <-- Tables.grac_functional_characteristics)
                  where (gfc.object_id == objectId)
                  [gfc.functional_characteristics],
              cofactors =
                for (c <-- Tables.cofactor)
                  where (c.object_id == objectId)
                  [(cofactor = c,
                    ligand =
                      for (l <-- Tables.ligand)
                      where (l.ligand_id == c.ligand_id)
                      [l],
                    refs =
                      for (cr <-- Tables.cofactor_refs)
                      where (cr.cofactor_id == c.cofactor_id)
                      [cr.reference_id]
                    )],
              products =
                for (p <-- Tables.product)
                  where (p.object_id == objectId)
                  [(product = p,
                    ligand =
                      for (l <-- Tables.ligand)
                      where (l.ligand_id == p.ligand_id)
                      [l],
                    refs =
                      for (pr <-- Tables.product_refs)
                      where (pr.product_id == p.product_id)
                      [pr.reference_id])],
              conductance =
                for (c <-- Tables.conductance)
                  where (c.object_id == objectId)
                  [(conductance = c,
                    refs =
                      for (r <-- Tables.conductance_refs)
                      where (r.conductance_id == c.conductance_id)
                      [r.reference_id])],
              conductanceStates =
                for (cs <-- Tables.conductance_states)
                  where (cs.object_id == objectId)
                  [(=cs,
                    refs =
                      for (r <-- Tables.conductance_states_refs)
                      where (r.conductance_states_id == cs.conductance_states_id)
                        [r.reference_id])],
              selectivity =
                for (s <-- Tables.selectivity)
                  where (s.object_id == objectId)
                  [(selectivity = s,
                    refs =
                      for (r <-- Tables.selectivity_refs)
                      where (r.selectivity_id == s.selectivity_id)
                      [r.reference_id])],
              gpcr =
                for (gpcr <-- Tables.gpcr)
                  where (gpcr.object_id == objectId)
                  [gpcr],
              lgic =
                for (l <-- Tables.lgic)
                  where (l.object_id == objectId)
                  [l],
              vgic =
                for (v <-- Tables.vgic)
                  where (v.object_id == objectId)
                  [v],
              otherIC =
                for (oic <-- Tables.other_ic)
                  where (oic.object_id == objectId)
                  [oic],
              nhr =
                for (nhr <-- Tables.nhr)
                  where (nhr.object_id == objectId)
                  [nhr],
              enzyme =
                for (e <-- Tables.enzyme)
                  where (e.object_id == objectId)
                  [e],
              transporter =
                for (t <-- Tables.transporter)
                  where (t.object_id == objectId)
                  [t],
              catalytic_receptor =
                for (cr <-- Tables.catalytic_receptor)
                  where (cr.object_id == objectId)
                  [cr],
              coregulators =
                for (c <-- Tables.coregulator)
                where (c.object_id == objectId)
                  for (g <-- Tables.coregulator_gene)
                  where (g.coregulator_gene_id == c.coregulator_gene_id)
                  [ (coregulator = c,
                     gene = g,
                     refs =
                       for (r <-- coregulator_refs)
                       where (r.coregulator_id == c.coregulator_id)
                       [r.reference_id])],
              dnaBinding =
                for (dna <-- Tables.dna_binding)
                where (dna.object_id == objectId)
                  [(=dna,
                   refs =
                     for (r <-- Tables.dna_binding_refs)
                     where (r.dna_binding_id == dna.dna_binding_id)
                     [r.reference_id])],
              bindingPartners =
                for (bp <-- Tables.binding_partner)
                  where (bp.object_id == objectId)
                    [(=bp,
                      obj =
                        for (obj <-- Tables.object)
                        where (obj.object_id == bp.partner_object_id)
                        [obj],
                      refs =
                        for (r <-- Tables.binding_partner_refs)
                        where (r.binding_partner_id == bp.binding_partner_id)
                        [r.reference_id])],
              targetGenes =
                for (tg <-- Tables.target_gene)
                  where (tg.object_id == objectId)
                  [(=tg,
                    refs =
                      for (r <-- Tables.target_gene_refs)
                      where (r.target_gene_id == tg.target_gene_id)
                      [r.reference_id])],
              xenobiotics =
                for (xe <-- Tables.xenobiotic_expression)
                  where (xe.object_id == objectId)
                  [(=xe,
                    refs =
                      for (r <-- Tables.xenobiotic_expression_refs)
                      where (r.xenobiotic_expression_id == xe.xenobiotic_expression_id)
                      [r.reference_id])],
               subunits =
                 for (r2s <-- Tables.receptor2subunit)
                   where (r2s.receptor_id == objectId)
                     for (sub <-- Tables.object)
                     where (sub.object_id == r2s.subunit_id)
                       [(id = sub.object_id, name = sub.name, type = r2s.type)],
               receptors =
                 for (r2s <-- Tables.receptor2subunit)
                   where (r2s.subunit_id == objectId)
                     for (r <-- Tables.object)
                     where (r.object_id == r2s.receptor_id)
                       [(id = r.object_id, name = r.name, type = r2s.type)],
                voltageDependence =
                  for (vd <-- Tables.voltage_dependence)
                    where (vd.object_id == objectId)
                      [(=vd,
                        activationRefs =
                          for (ar <-- Tables.voltage_dep_activation_refs)
                          where (ar.voltage_dependence_id == vd.voltage_dependence_id)
                          [ar.reference_id],
                        deactivationRefs =
                          for (dr <-- Tables.voltage_dep_deactivation_refs)
                          where (dr.voltage_dependence_id == vd.voltage_dependence_id)
                          [dr.reference_id],
                        inactivationRefs =
                          for (ir <-- Tables.voltage_dep_inactivation_refs)
                          where (ir.voltage_dependence_id == vd.voltage_dependence_id)
                          [ir.reference_id])],
                expressionPathophysiology =
                  for (ep <-- Tables.expression_pathophysiology)
                    where (ep.object_id == objectId)
                    [(=ep,
                      refs =
                        for (r <-- Tables.expression_pathophysiology_refs)
                        where (r.expression_pathophysiology_id == ep.expression_pathophysiology_id)
                        [r.reference_id])],
                screens =
                  for (si <-- Tables.screen_interaction)
                    where (si.object_id == objectId)
                    for (l <-- Tables.ligand)
                    where (l.ligand_id == si.ligand_id)
                      for (scr <-- Tables.screen)
                      where (si.screen_id == scr.screen_id)
                        [(=si, ligand = l, screen =
                            (=scr,
                             refs =
                               for (sr <-- Tables.screen_refs)
                               where (sr.screen_id == scr.screen_id)
                               [sr.reference_id]))]
             )]
    };

    fun mkModel(raw) {
      var speciesMap = Species.getSpeciesMap();
      fun speciesShortName(speciesID) { resolveSpeciesShortName(speciesID, speciesMap) }
      fun speciesLongName(speciesID) { resolveSpeciesLongName(speciesID, speciesMap) }
      # OK, first parse interactions. Given the interactions field from the raw
      # data, this should get us a record of:
      # (agonists: [Interaction],
      #  antagonists: [Interaction],
      #  allostericModulators: [Interaction],
      #  activators: [Interaction],
      #  inhibitors: [Interaction],
      #  channelBlockers: [Interaction],
      #  gatingInhibitors: [Interaction],
      #  subunitSpecific: [Interaction],
      #  endogenous: [EndogenousLigandSummary],
      #  references: [ReferenceID])
      fun transformInteractions(rawInteractions) {
        var emptyResult =
          (agonists = [], antagonists = [], allostericModulators = [],
           activators = [], inhibitors = [], channelBlockers = [],
           gatingInhibitors = [], subunitSpecific = [], endogenous = [],
           antibodies = [], wholeOrganismAssays = [], other = [],
           references = []);

        fold_left(fun(acc, i) {
          # var i = x.interaction;
          # var l = x.ligand;
          # var refs = x.refs;
          var parsedName = parseOrError(i.interactionLigand.name);
          var parsed : InteractionInfo = (
            interaction = i,
            parsedName = parsedName,
            ligandSize = parseLigandSize(i.interactionLigand.type),
            speciesShort = speciesShortName(i.speciesID)
          );

          # TODO: Maybe make this less stringly-typed?
          var acc =
            if (i.interactionType == "Agonist") {
              (acc with agonists = ( parsed :: acc.agonists ))
            } else if (i.interactionType == "Antagonist") {
              (acc with antagonists = ( parsed :: acc.antagonists ))
            } else if (i.interactionType == "Allosteric modulator") {
              (acc with allostericModulators = ( parsed :: acc.allostericModulators ))
            } else if (i.interactionType == "Activator") {
              (acc with activators = ( parsed :: acc.activators ))
            } else if (i.interactionType == "Inhibitor") {
              (acc with inhibitors = ( parsed :: acc.inhibitors ))
            } else if (i.interactionType == "Channel blocker") {
              (acc with channelBlockers = ( parsed :: acc.channelBlockers ))
            } else if (i.interactionType == "Gating inhibitor") {
              (acc with gatingInhibitors = ( parsed :: acc.gatingInhibitors ))
            } else if (i.interactionType == "Subunit-specific") {
              (acc with subunitSpecific = ( parsed :: acc.subunitSpecific ))
            } else if (i.interactionType == "Antibody") {
              (acc with antibodies = ( parsed :: acc.antibodies ))
            } else if (i.wholeOrganismAssay) {
              (acc with wholeOrganismAssays = (parsed :: acc.wholeOrganismAssays))
            } else {
              (acc with other = ( parsed :: acc.other ))
            };

          var acc =
            if (i.endogenous) {
              var els =
                (elsName = parsedName,
                 elsSpeciesID = i.speciesID,
                 elsLigandID = i.ligandID);
              (acc with endogenous = els :: acc.endogenous)
            } else { acc };

          (acc with references = (i.references ++ acc.references))
        }, emptyResult, rawInteractions)
      }

      fun mkTables(parsedInteractions) {
        # Some interactions are curated by adding multiple data points in, rather
        # than curating a range directly in the DB.
        # In this case, we need to group them and calculate a range ourselves.
        fun groupAffinities(interactions) {
          # First, group the interactions
          var grouped =
            groupBy(fun(x) {
              (x.interaction.ligandID, x.interaction.speciesID,
               x.interaction.affinity.affinityUnits) }, interactions);
          # Reduce each group, and flatten.
          map(fun((_, group)) {
            # First, sort the group
            var group =
              cmpSort(fun(x, y) {
                  sortAffinity(x.interaction.affinity, y.interaction.affinity)
              }, group);

            # Next, take the extrema, and generate a new interaction range
            var first = hd(group);
            var final = last(group);
            if (first == final) {
              first
            } else {
              var min = {
                var affinity = first.interaction.affinity;
                if (affinity.affinityLow <> 0.0) {
                  affinity.affinityLow
                } else {
                  affinity.affinityMedian
                }
              };

              var max = {
                var affinity = final.interaction.affinity;
                if (affinity.affinityHigh <> 0.0) {
                  affinity.affinityHigh
                } else {
                  affinity.affinityMedian
                }
              };

              var firstAffinity = first.interaction.affinity;
              var newInteraction =
                (first.interaction with affinity =
                 (affinityUnits = firstAffinity.affinityUnits,
                  affinityLow = min, affinityHigh = max, affinityMedian = 0.0));

              (first with interaction = newInteraction)
            }
          }, grouped)
        }

        ## TODO: Probably could abstract this
        fun groupAffinityVoltages(interactions) {
            # First, group the interactions
            var grouped =
              groupBy(fun(x) {
                (x.interaction.ligandID, x.interaction.speciesID) }, interactions);
            map(fun((_, group)) {
              # First, sort the group
              var group =
                cmpSort(fun(x, y) {
                    sortAffinityVoltage(x.interaction.affinityVoltage, y.interaction.affinityVoltage)
                }, group);

              # Next, take the extrema, and generate a new interaction range
              var first = hd(group);
              var final = last(group);
              if (first == final) {
                first
              } else {
                var min = {
                  var affinity = first.interaction.affinityVoltage;
                  if (affinity.affinityVoltageLow <> 0.0) {
                    affinity.affinityVoltageLow
                  } else {
                    affinity.affinityVoltageMedian
                  }
                };

                var max = {
                  var affinity = final.interaction.affinityVoltage;
                  if (affinity.affinityVoltageHigh <> 0.0) {
                    affinity.affinityVoltageHigh
                  } else {
                    affinity.affinityVoltageMedian
                  }
                };

                var firstAffinity = first.interaction.affinityVoltage;
                var newInteraction =
                  (first.interaction with affinityVoltage =
                   (affinityVoltageLow = min, affinityVoltageHigh = max, affinityVoltageMedian = 0.0,
                    affinityPhysiologicalVoltage = firstAffinity.affinityPhysiologicalVoltage
                  ));

                (first with interaction = newInteraction)
              }
            }, grouped)
        }


        # Columns are slightly different based on the type of interaction.
        # Agonists / antagonists / channel blockers / allosteric modulators:
        #  ligand, data cols, species, action, affinity, parameter, references
        # Activators / Inhibitors / Gating inhibitors:
        #  ligand, data cols, species, action, affinity, parameter, holding voltage, reference

        fun mkStandardTable(tableTy, interactions) {
          var interactions = groupAffinities(interactions);
          var cols = [
            ("Ligand", ("", Sortable(fun(x, y) {
                simpleCmp(x.interaction.interactionLigand.name,
                    y.interaction.interactionLigand.name) }))),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("Sp.", ("keybox_header",
              Sortable(fun(x, y) { simpleCmp(x.speciesShort, y.speciesShort) }))),
            ("Action", ("action_header",
              Sortable(fun(x, y) { simpleCmp(x.interaction.interactionAction,
                  y.interaction.interactionAction) }))),
            ("Value", ("affinity_header", Sortable(fun(x, y) {
                InteractionUtilities.sortAffinity(x.interaction.affinity,
                    y.interaction.affinity)}))),
            ("Parameter", ("units_header", Sortable(fun(x, y) {
                simpleCmp(x.interaction.affinity.affinityUnits,
                          y.interaction.affinity.affinityUnits) }))),
            ("References", ("reference_header", Sortable(fun(x, y) { 0 })))
          ];
          fun sortMessage(colName, sortDir) { SortTable(tableTy, colName, sortDir) }
          DataTable.makeTable(cols, interactions, sortMessage)
        }

        fun mkActivatorTable(tableTy, interactions) {
          var interactions = groupAffinityVoltages(interactions);
          var cols = [
            ("Ligand", ("", Sortable(fun(x, y) {
                simpleCmp(x.interaction.interactionLigand.name,
                    y.interaction.interactionLigand.name) }))),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("Species", ("keybox_header",
              Sortable(fun(x, y) { simpleCmp(x.speciesShort, y.speciesShort) }))),
            ("Action", ("keybox_header",
              Sortable(fun(x, y) { simpleCmp(x.speciesShort, y.speciesShort) }))),
            ("Value", ("affinity_header", Sortable(fun(x, y) {
                InteractionUtilities.sortAffinity(x.interaction.affinity,
                    y.interaction.affinity)}))),
            ("Parameter", ("units_header", Sortable(fun(x, y) {
                simpleCmp(x.interaction.affinity.affinityUnits,
                          y.interaction.affinity.affinityUnits) }))),
            ("Concentration range (M)", ("affinity_header",
              Sortable(fun(x, y) {
                simpleCmp(x.interaction.concentrationRange, y.interaction.concentrationRange)
              }))),
            ("Holding voltage (mV)", ("affinity_header", Sortable(fun(x, y) {
                 InteractionUtilities.sortAffinityVoltage(x.interaction.affinityVoltage,
                     y.interaction.affinityVoltage)
              }))),
            ("References", ("reference_header", Sortable(fun(x, y) { 0 } )))
          ];

          fun sortMessage(colName, sortDir) { SortTable(tableTy, colName, sortDir) }
          DataTable.makeTable(cols, interactions, sortMessage)
        }

        fun mkAssayTable(interactions) {
          var interactions = groupAffinities(interactions);
          var cols = [
            ("Ligand", ("", Sortable(fun(x, y) {
                simpleCmp(x.interaction.interactionLigand.name,
                    y.interaction.interactionLigand.name) }))),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("Sp.", ("action_header",
              Sortable(fun(x, y) { simpleCmp(x.interaction.speciesID,
                  y.interaction.speciesID) }))),
            ("Assay description", ("assay_long_header header", Sortable(fun(x, y) {
                simpleCmp(x.interaction.assayDescription,
                    y.interaction.assayDescription) }))),
            ("Value", ("affinity_header", Sortable(fun(x, y) {
                InteractionUtilities.sortAffinity(x.interaction.affinity,
                    y.interaction.affinity)}))),
            ("Parameter", ("units_header", Sortable(fun(x, y) {
                simpleCmp(x.interaction.affinity.affinityUnits,
                          y.interaction.affinity.affinityUnits) }))),
            ("References", ("reference_header", Sortable(fun(x, y) { 0 })))
          ];
          fun sortMessage(colName, sortDir) { SortTable(WholeOrganismAssaysTable, colName, sortDir) }
          DataTable.makeTable(cols, interactions, sortMessage)
        }

        fun mkSubunitTable(interactions) {
          var interactions = groupAffinities(interactions);
          var cols = [
            ("Ligand", ("", Sortable(fun(x, y) {
                simpleCmp(x.interaction.interactionLigand.name,
                    y.interaction.interactionLigand.name) }))),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("Action", ("action_header",
              Sortable(fun(x, y) { simpleCmp(x.interaction.interactionAction,
                  y.interaction.interactionAction) }))),
            ("Subunit specificity", ("affinity_header", Sortable(fun(x, y) {
                simpleCmp(x.interaction.interactionActionComment,
                    y.interaction.interactionActionComment) }))),
            ("Concentration range (M)", ("units_header", Sortable(fun(x, y) {
                simpleCmp(x.interaction.affinity.affinityUnits,
                          y.interaction.affinity.affinityUnits) }))),
            ("References", ("reference_header", Sortable(fun(x, y) { 0 })))
          ];
          fun sortMessage(colName, sortDir) { SortTable(SubunitSpecificTable, colName, sortDir) }
          DataTable.makeTable(cols, interactions, sortMessage)
        }

        var res : SortedInteractions =
          (agonists = mkStandardTable(AgonistsTable, parsedInteractions.agonists),
         antagonists = mkStandardTable(AntagonistsTable, parsedInteractions.antagonists),
         allostericModulators =
           mkActivatorTable(AllostericModulatorsTable,
             parsedInteractions.allostericModulators),
         activators =
           mkActivatorTable(ActivatorsTable, parsedInteractions.activators),
         inhibitors =
           mkActivatorTable(InhibitorsTable, parsedInteractions.inhibitors),
         channelBlockers =
           mkActivatorTable(ChannelBlockersTable, parsedInteractions.channelBlockers),
         gatingInhibitors =
           mkActivatorTable(GatingInhibitorsTable, parsedInteractions.gatingInhibitors),
         subunitSpecific =
           mkSubunitTable(parsedInteractions.subunitSpecific),
         antibodies =
           mkActivatorTable(AntibodiesTable, parsedInteractions.antibodies),
         wholeOrganismAssays =
          mkAssayTable(parsedInteractions.wholeOrganismAssays),
         other =
           mkStandardTable(GatingInhibitorsTable, parsedInteractions.other)
           );
        res
      }

      fun transformAssociatedProteins(rawAPs) {
        fun transformAP(ap) {
          switch(ap.assocObjects) {
            case [] ->
              (name = parseOrError(ap.protein.name),
               objectID = Nothing,
               references = ap.refs,
               effect = parseOrError(ap.protein.effect))
            case obj :: _ ->
              (name = parseOrError(obj.name),
               objectID = Just(obj.object_id),
               references = ap.refs,
               effect = parseOrError(ap.protein.effect))
          }
        }

        var emptySorted =
          (hpfSubunits = [], auxiliarySubunits = [], otherProteins = [],
           gProteins = [], interactingProteins = []);

        fold_left(fun ((aps, refs), x) {
          var transformed = transformAP(x);
          var newSorted =
            if (x.protein.type == "Heteromeric Pore-forming Subunit") {
              (aps with hpfSubunits = transformed :: aps.hpfSubunits)
            } else if (x.protein.type == "Auxiliary Subunit") {
              (aps with auxiliarySubunits = transformed :: aps.auxiliarySubunits)
            } else if (x.protein.type == "G Protein") {
              (aps with gProteins = transformed :: aps.gProteins)
            } else if (x.protein.type == "Interacting Protein") {
              (aps with interactingProteins = transformed :: aps.interactingProteins)
            } else {
              (aps with otherProteins = transformed :: aps.otherProteins)
            };
          (newSorted, x.refs ++ refs)
        }, (emptySorted, []), rawAPs)
      }

      fun transformEnzymeReactions(rawERs) {
          fun transformSpecificReactions(srs) {
            fun transformSpecificReaction(sr) {
              var parsedDesc = parseOrError(sr.sr.description);
              var parsedReaction = parseOrError(sr.sr.reaction);
              var (refs, ligands) = collectAllIds([parsedDesc, parsedReaction]);
              ((description = parsedDesc, reaction = parsedReaction,
                references = sr.refs), refs ++ sr.refs, ligands)
            }

            fold_left(fun((srs, srRefs, srLigands), sr) {
                var (sr, refs, ligands) = transformSpecificReaction(sr);
                (sr :: srs, refs ++ srRefs, ligands ++ srLigands)
              }, ([], [], []), srs)
          }

          fold_left(fun ((reactions, refs, ligands), x) {
              var parsedReaction = parseOrError(x.reaction.reaction);
              var (rRefs, rLigands) = collectIds(parsedReaction);
              var (srs, srRefs, srLigands) = transformSpecificReactions(x.specificReactions);
              var er = (ecNumber = x.reaction.ec_number, reaction = parsedReaction, specificReactions = srs);
            (er :: reactions, rRefs ++ srRefs ++ refs, rLigands ++ srLigands ++ ligands)
          }, ([], [], []), rawERs)
      }

      fun transformPDBs(rawPDBs) {
        fun transformPDB(rawPDB) {
          var pdb = rawPDB.pdb;
          var ligand = rawPDB.ligand;
          var refs = rawPDB.refs;
          var res =
            (pdbCode = pdb.pdb_code,
             pdbLigandId = ligand.ligand_id,
             pdbLigandName = parseOrError(ligand.name),
             pdbLigandDescription = parseOrError(pdb.description),
             pdbSpeciesId = pdb.species_id,
             pdbReferences = [],
             pdbResolution = pdb.resolution);
          var (descriptionRefs, descriptionLigands) =
            RenderMarkup.collectIds(res.pdbLigandDescription);
          var allRefs = refs ++ descriptionRefs;
          ((res with pdbReferences = allRefs), allRefs, descriptionLigands)
        }

        var (pdbsRev, pdbRefs, pdbLigands) =
          fold_left(fun((pdbs, pdbRefs, pdbLigands), pdb) {
              var (pdb, refs, ligands) = transformPDB(pdb);
              (pdb :: pdbs, refs ++ pdbRefs, ligands ++ pdbLigands)
          }, ([], [], []), rawPDBs);
        (reverse(pdbsRev), pdbRefs, pdbLigands)
      }

      fun transformVariants(rawVs) {
        var (variantsRev, vRefs, vLigands) =
          fold_left(fun((variants, vRefs, vLigands), rawV) {
            var v = rawV.v;
            var desc = parseOrError(v.description);
            var (refIDs, ligandIDs) = collectIds(desc);
            var res =
              (vId = v.variant_id,
               vType = v.type,
               vSpecies = v.species_id,
               vDescription = desc,
               vReferences = rawV.refs
              );
            (res :: variants, refIDs ++ res.vReferences, ligandIDs)
          }, ([], [], []), rawVs);
        (reverse(variantsRev), vRefs, vLigands)
      }


      fun transformReceptorComments() {
        var rb = raw.receptorBasic;

        #transformReceptorComments(raw.receptorBasic, raw.comments,
        #    raw.immuno_comments, raw.malaria_comments, raw);
        fun fromList(xs) {
          switch(xs) {
            case [] -> MarkupEmpty
            case x :: _ -> parseOrError(x)
          }
        }

        var fcs = fromList(raw.functionalCharacteristics);

        var res = (
          listComments = parseOrError(rb.list_comments),
          associatedProteinsComments = parseOrError(rb.associated_proteins_comments),
          functionalAssayComments = parseOrError(rb.functional_assay_comments),
          tissueDistributionComments = parseOrError(rb.tissue_distribution_comments),
          functionsComments = parseOrError(rb.functions_comments),
          alteredExpressionComments = parseOrError(rb.altered_expression_comments),
          expressionPathophysiologyComments = parseOrError(rb.expression_pathophysiology_comments),
          mutationsPathophysiologyComments = parseOrError(rb.mutations_pathophysiology_comments),
          variantsComments = parseOrError(rb.variants_comments),
          xenobioticExpressionComments = parseOrError(rb.xenobiotic_expression_comments),
          antibodyComments = parseOrError(rb.antibody_comments),
          agonistsComments = parseOrError(rb.agonists_comments),
          antagonistsComments = parseOrError(rb.antagonists_comments),
          allostericModulatorsComments = parseOrError(rb.allosteric_modulators_comments),
          activatorsComments = parseOrError(rb.activators_comments),
          inhibitorsComments = parseOrError(rb.inhibitors_comments),
          channelBlockersComments = parseOrError(rb.channel_blockers_comments),
          gatingInhibitorsComments = parseOrError(rb.gating_inhibitors_comments),
          generalComments = parseOrError(raw.comments),
          immunoComments = parseOrError(raw.immuno_comments),
          malariaComments = parseOrError(raw.malaria_comments),
          functionalCharacteristicsComments = fcs
          );


        var (commentRefs, commentLigands) = collectAllIds(
          [res.listComments, res.associatedProteinsComments,
            res.functionalAssayComments, res.tissueDistributionComments,
            res.functionsComments, res.alteredExpressionComments,
            res.expressionPathophysiologyComments,
            res.mutationsPathophysiologyComments, res.variantsComments,
            res.xenobioticExpressionComments, res.antibodyComments,
            res.agonistsComments, res.antagonistsComments,
            res.allostericModulatorsComments, res.activatorsComments,
            res.inhibitorsComments, res.channelBlockersComments,
            res.gatingInhibitorsComments, res.generalComments,
            res.immunoComments, res.malariaComments,
            res.functionalCharacteristicsComments
          ]);
        (res, commentRefs, commentLigands)
      }

      fun transformSynonyms(synonyms) {
        map(fun(s) {parseOrError(s.synonym) },
            sortBy(fun(s) { s.order }, synonyms))
      }

      fun transformFamily(fs) {
        switch(fs) {
          case [] -> (familyId = (-1), familyName = MarkupEmpty)
          case f :: _ -> (familyId = f.id, familyName = parseOrError(f.name))
        }
      }

      fun transformGeneProteinInfo(gpcrComments, gis) {
        var (gisRev, giRefs) =
          fold_left(fun((gis_rev, refs), gi) {
            var references = gi.refs;
            var gi = gi.si;
            var res = (
              gpiSpeciesID = gi.species_id,
              gpiName = parseOrError(gi.gene_long_name),
              gpiSymbol = gi.official_gene_id,
              gpiShortName = gi.gene_name,
              gpiTransmembraneDomains = gi.transmembrane_domains,
              gpiAminoAcids = gi.amino_acids,
              gpiReferences = references,
              gpiChromosomalLocation = gi.genomic_location
            );
            (res :: gis_rev, references ++ refs)
          }, ([], []), gis);

        ((giComments = gpcrComments, giEntries = reverse(gisRev)),
           giRefs)
      }

      fun transformGeneExpression(gis) {
        # For each gene, check if there's any registered expression level
        # data. If so, then group the data by experiment.

        listConcatMap(fun(gene) {
            var el = gene.expressionLevel;
            var grouped = groupBy(fun(x) { x.experiment.expression_experiment_id}, el);

            # grouped: [(ExperimentID, [(el, tissueName, experiment)])]
            map(fun((_, xs)) {
              var experiment = hd(xs).experiment;

              var data = map(fun(x) { (x.tissueName, x.el.value) }, xs);

              (geneName = gene.si.gene_name,
               description = experiment.description,
               technique = experiment.technique,
               speciesID = experiment.species_id,
               baseline = experiment.baseline,
               =data)
            }, grouped)
        }, gis)
      }

      sig mkDataTableBox : (String, [DataTableEntry]) ~%~> DataTableBox
      fun mkDataTableBox(name, rows) {
        (boxName = name, boxRows = rows)
      }

      sig mkDataTableEntry : (Markup, [(String, Markup)], [ReferenceID]) ~%~> DataTableEntry
      fun mkDataTableEntry(comment, data, references) {
        (entryComment = comment, entryData = data, entryReferences = references)
      }

      sig transformDataTableBox : (String, (a) ~%~> DataTableEntry, [a]) ~>
        (DataTableBox, [ReferenceID], [LigandID])
      fun transformDataTableBox(boxName, getRow, data) {
        var (rows_rev, refs, ligands) =
          fold_left(fun((rows_rev, refs, ligands), x) {
            var row = getRow(x);
            var (rowRefs, rowLigands) =
              RenderMarkup.collectAllIds(map(second, row.entryData));
            (row :: rows_rev, rowRefs ++ row.entryReferences ++ refs,
               rowLigands ++ ligands)
          }, ([], [], []), data);
        var box = (boxName = boxName, boxRows = reverse(rows_rev));
        (box, refs, ligands)
      }

      fun transformFunctionalAssays(fas) {
        transformDataTableBox("Functional Assays",
          fun(fa) {
            var references = fa.refs;
            var fa = fa.fa;
            mkDataTableEntry(parseOrError(fa.description),
              [("Species", parseOrError(resolveSpeciesLongName(fa.species_id, speciesMap))),
               ("Tissue", parseOrError(fa.tissue)),
               ("Response measured", parseOrError(fa.response_measured))], references)
          }, fas)
      }

      fun transformPhysiologicalFunctions(pfs) {
        transformDataTableBox("Physiological Functions",
          fun(pf) {
            var references = pf.refs;
            var pf = pf.pf;
            mkDataTableEntry(parseOrError(pf.description),
              [("Species", parseOrError(resolveSpeciesLongName(pf.species_id, speciesMap))),
               ("Tissue", parseOrError(pf.tissue))], references)
          }, pfs)
      }

      fun transformExpressionPathophysiology(eps) {
        transformDataTableBox("Gene Expression and Pathophysiology",
          fun(ep) {
            var references = ep.refs;
            var ep = ep.ep;
            mkDataTableEntry(parseOrError(ep.change),
              [("Tissue or cell type", parseOrError(ep.tissue)),
               ("Pathophysiology", parseOrError(ep.pathophysiology)),
               ("Species", parseOrError(speciesLongName(ep.species_id))),
               ("Technique", parseOrError(ep.technique))], references)
          }, eps)
      }

      fun transformPhysiologicalConsequences(aes) {
        transformDataTableBox("Physiological Consequences of Altering Gene Expression",
          fun(ae) {
            var references = ae.refs;
            var ae = ae.ae;
            mkDataTableEntry(parseOrError(ae.description),
              [("Species", parseOrError(resolveSpeciesLongName(ae.species_id, speciesMap))),
               ("Tissue", parseOrError(ae.tissue)),
               ("Technique", parseOrError(ae.technique))], references)
          }, aes)
      }

      fun transformTissueDistribution(tds) {
        transformDataTableBox("Tissue Distribution",
          fun(td) {
            var references = td.refs;
            var td = td.td;
            mkDataTableEntry(parseOrError(td.tissues),
              [("Species", parseOrError(resolveSpeciesLongName(td.species_id, speciesMap))),
               ("Technique", parseOrError(td.technique))], references)
          }, tds)
      }

      fun transformDNABindingBox(dna) {
        transformDataTableBox("DNA Binding",
          fun(dna) {
            var references = dna.refs;
            var dna = dna.dna;
            mkDataTableEntry(MarkupEmpty,
                [("Structure", parseOrError(dna.structure)),
                 ("HRE core sequence", parseOrError(dna.sequence)),
                 ("Response element", parseOrError(dna.response_element))], references)
            }, dna)
      }

      fun transformXenobioticExpressions(comments, xes) {
        transformDataTableBox("Xenobiotics Influencing Gene Expression",
          fun(xe) {
            var references = xe.refs;
            var xe = xe.xe;
            mkDataTableEntry(comments,
              [("Species", parseOrError(resolveSpeciesLongName(xe.species_id, speciesMap))),
               ("Tissue", parseOrError(xe.tissue)),
               ("Technique", parseOrError(xe.technique))], references)
          }, xes)
      }

      fun transformDBLinks(dbls) {
        var baseLinks = transformDatabaseLinks(dbls);
        var extraLinks =
          listConcatMap(fun(dbl) {
            if (dbl.dbID == 15) {
              listConcatMap(fun((species, code, url)) {
                  if (speciesShortName(species) == "Hs") {
                    var dbURL = "http://www.proteinatlas.org/$PLACEHOLDER";
                    var url = replacePlaceholder(dbURL, code);
                    [(dbID = (-1), # hack
                      dbName = "Human Protein Atlas",
                      dbURL = dbURL,
                      dbSpecialist = false,
                      dbPrefix = "",
                      dbEntries = [(species, code, url)])]
                  } else {
                    []
                  }
              }, dbl.dbEntries)
            } else if (dbl.dbID == 3) {
              var dbURL = "https://www.genome.jp/dbget-bin/www_bget?$PLACEHOLDER";
              var entries = map(fun((species, code, url)) {
                var speciesShort = speciesShortName(species);
                var codePrefix =
                  if (speciesShort == "Hs") { "hsa:" }
                  else if (speciesShort == "Mm") { "mmu:" }
                  else if (speciesShort == "Rn") { "rno:" }
                  else { "" };
                var code = codePrefix ^^ code;
                var url = replacePlaceholder(dbURL, code);
                (species, code, url)
              }, dbl.dbEntries);
              [(dbID = (-1), # Hack
               dbName = "Kegg Gene",
               dbURL = dbURL,
               dbSpecialist = false,
               dbPrefix = "",
               dbEntries = entries)]
            } else {
              []
            }
          }, baseLinks);
        baseLinks ++ extraLinks
      }

      fun transformContributors(cs) {
        var sorted = sortBy(fun(c) { c.order }, cs);
        mkTBox("Contributors", false, map(
          fun(c) {
            var c = c.c;
            mkContributor(c.contributor_id, c.first_names ^^ " " ^^ c.surname,
                parseOrError(c.address), "")
          }, sorted))
      }

      fun transformCellTypeAssociations(ctas) {
        var (ctasRev, ctaRefs, ctaLigands) =
          fold_left(fun((ctasRev, ctaRefs, ctaLigands), x) {
            var comment = parseOrError(x.ctaComment);
            var cellType =
              (cellOntologyID = x.cellType.cellonto_id,
               cellOntologyName = x.cellType.name);
            var immuno =
              (immunoCTID = x.immuno.immuno_celltype_id, immunoCTName = x.immuno.term);
            var (commentRefs, commentLigands) = collectIds(comment);
            var allRefs = commentRefs ++ x.refs;
            var res =
              (ctaImmunoCelltype = immuno,
               ctaComments = comment,
               ctaCellOntologyType = cellType,
               ctaReferences = x.refs);
            (res :: ctasRev, allRefs ++ ctaRefs, commentLigands ++ ctaLigands)
          }, ([], [], []), ctas);
        (reverse(ctasRev), ctaRefs, ctaLigands)
      }

      fun transformImmunoProcessAssociations(ipas) {
        var (ipasRev, ipaRefs) =
          fold_left(fun((ipasRev, ipaRefs), x) {
            var goProcs =
              map(fun(g) {
                  (goProcessID = g.go.go_id,
                   goProcessComment = g.go.term,
                   goProcessEvidence = g.o2go.go_evidence)
              }, x.goProcs);
            (
             (ipImmunoProcess =
              (immunoProcessID = x.gtipProc.gtip_process_id,
               immunoProcessName = x.gtipProc.term),
             ipShowIEA = false,
             ipGoProcesses = goProcs,
             ipReferences = x.refs
            ) :: ipasRev, x.refs ++ ipaRefs)
          }, ([], []), ipas);
        (reverse(ipasRev), ipaRefs)
      }

      fun ligandOrDefault(projectF, def, ligands) {
        switch(ligands) {
          case [] -> def
          case x :: _ -> projectF(x)
        }
      }

      fun transformSubstrates(rawSubstrates) {

        fun transformSubstrate(s) {
          var sub = s.substrate;
          #sig ligandOrDefault : forall a. ((Tables.RawLigand) ~%~> a, a) ~%~> a

          var name =
            parseOrError(ligandOrDefault(fun(l) { l.name }, sub.name, s.ligand));

          var ligandID =
            ligandOrDefault(fun(l) { l.ligand_id }, (-1), s.ligand);

          var parsedProperty = parseOrError(sub.property);
          var parsedStandardProperty = parseOrError(sub.standard_property);
          var parsedAssayDescription = parseOrError(sub.assay_description);
          var parsedAssayConditions = parseOrError(sub.assay_conditions);
          var parsedComments = parseOrError(sub.comments);

          var (refs, ligands) =
            collectAllIds([parsedProperty, parsedStandardProperty,
                parsedAssayDescription, parsedAssayConditions, parsedComments]);

          var transformedSubstrate =
            (name = name,
             ligandID = ligandID,
             endogenous = sub.endogenous,
             species = speciesShortName(sub.species_id),
             property = parsedProperty,
             value = sub.value,
             units = parseOrError(sub.units),
             standardProperty = parsedStandardProperty,
             standardValue = sub.standard_value,
             assayDescription = parsedAssayDescription,
             assayConditions = parsedAssayConditions,
             comments = parsedComments,
             references = s.refs);
          (transformedSubstrate, refs ++ s.refs, ligands)
        }

        var (transformedSubstrates, substrateRefs, substrateLigands) =
          fold_left(fun((subs, refs, ligands), s) {
            var (sub, sRefs, sLigands) = transformSubstrate(s);
            (sub :: subs, sRefs ++ refs, sLigands ++ ligands)
          }, ([], [], []), rawSubstrates);

        var tbl = {
          var cols = [
            ("Substrate", ("substrate_header header", Sortable(fun(x, y) {
                markupCmp(x.name, y.name) }))),
            ("", ("", NotSortable)),
            ("Sp.", ("keybox_header",
              Sortable(fun(x, y) { simpleCmp(x.species, y.species) }))),
            ("Property", ("units_header header",
              Sortable(fun(x, y) { markupCmp(x.property, y.property) }))),
            ("Value", ("units_header header sorter-decimals", Sortable(fun(x, y) {
              simpleCmp(x.value, y.value)}))),
            ("Units", ("units_header", Sortable(fun(x, y) {
                simpleCmp(x.units,
                          y.units) }))),
            ("Standard property", ("units_header header sorter-decimals", Sortable(fun(x, y) {
              markupCmp(x.standardProperty, y.standardProperty)}))),
            ("Standard value", ("units_header header sorter-decimals", Sortable(fun(x, y) {
              simpleCmp(x.standardValue, y.standardValue)}))),
            ("Assay description", ("assay_header header", Sortable(fun(x, y) {
              markupCmp(x.assayDescription, y.assayDescription)}))),
            ("Assay conditions", ("assay_header header", Sortable(fun(x, y) {
              markupCmp(x.assayConditions, y.assayConditions)}))),
            ("Comments", ("assay_header header", Sortable(fun(x, y) {
              markupCmp(x.comments, y.comments)}))),
            ("References", ("reference_header", Sortable(fun(x, y) { 0 })))
          ];
          fun sortMessage(colName, sortDir) { SortTable(SubstratesTable, colName, sortDir) }
          DataTable.makeTable(cols, transformedSubstrates, sortMessage)
        };

        (tbl, substrateRefs, substrateLigands)
      }

      fun transformProducts(rawProducts) {

        fun transformProduct(p) {
          var prod = p.product;
          var name =
            parseOrError(ligandOrDefault(fun(l) { l.name }, prod.name, p.ligand));
          var ligandID =
            ligandOrDefault(fun(l) { l.ligand_id }, (-1), p.ligand);

          ((name = name,
           ligandID = ligandID,
           speciesName = speciesLongName(prod.species_id),
           endogenous = prod.endogenous,
           references = p.refs), p.refs)
        }

        fold_left(fun((prods, refs), p) {
            var (prod, pRefs) = transformProduct(p);
            (prod :: prods, pRefs ++ refs)
        }, ([], []), rawProducts)
      }

      fun transformCofactors(rawCofactors) {
        fun transformCofactor(c) {
          var co = c.cofactor;
          var name =
            parseOrError(ligandOrDefault(fun(l) { l.name }, co.name, c.ligand));
          var ligandID =
            ligandOrDefault(fun(l) { l.ligand_id }, (-1), c.ligand);
          var comments = parseOrError(co.comments);
          var (cRefs, cLigands) = collectIds(comments);
          var refs = c.refs;
          ((name = name, ligandID = ligandID,
           speciesName = speciesLongName(co.species_id),
           comments = comments,
           references = refs), refs ++ cRefs, cLigands)
        }

        var (data, refs, ligands) =
          fold_left(fun((acc, refs, ligands), x) {
            var (c, cRefs, cLigands) = transformCofactor(x);
            (c :: acc, cRefs ++ refs, cLigands ++ ligands)
          }, ([], [], []), rawCofactors);

        var cols = [
            ("Cofactor", ("", Sortable(fun(x, y) {
                markupCmp(x.name, y.name) }))),
            ("Species", ("keybox_header header",
              Sortable(fun(x, y) { simpleCmp(x.speciesName, y.speciesName) }))),
            ("Comments", ("keybox_header header",
              Sortable(fun(x, y) { markupCmp(x.comments, y.comments) }))),
            ("References", ("reference_header header",
              Sortable(fun(x, y) { 0 })))
          ];
          fun sortMessage(colName, sortDir) { SortTable(CofactorsTable, colName, sortDir) }
          (DataTable.makeTable(cols, data, sortMessage), refs, ligands)
      }

      fun generateSelectivityInfo(selectivityData, conductanceInfo, selectivityComments) {
        var (selectivitySummaries, summaryReferences) = {
          # We begin by grouping by species
          var groups = groupBy(fun(x) { x.selectivity.species_id }, selectivityData);
          # For each group, we sort the selectivity in descending order,
          # and insert symbols to generate the rank order string.
          fun comparator(x, y) {
            var cmpX = Utility.getAverage(x.selectivity.conductance_high,
                x.selectivity.conductance_median, x.selectivity.conductance_low);
            var cmpY = Utility.getAverage(y.selectivity.conductance_high,
                y.selectivity.conductance_median, y.selectivity.conductance_low);
            Utility.simpleCmp(cmpX, cmpY)
          }

          fun generateRankOrder(xs) {
            var xs = cmpSort(comparator, xs);
            var (_, acc) =
              fold_right(fun(x, (prev, acc)) {
                var xVal =
                  Utility.getAverage(x.selectivity.conductance_high,
                      x.selectivity.conductance_median, x.selectivity.conductance_low);
                switch(prev) {
                  case Just(prev) ->
                    if (prev == xVal) {
                      (Just(xVal), acc ^^ " = " ^^ x.selectivity.ion)
                    } else {
                      (Just(xVal), acc ^^ " > " ^^ x.selectivity.ion)
                    }
                  case Nothing -> (Just(xVal), x.selectivity.ion)
                }
              }, (Nothing, ""), xs);
            acc
          }

          fun getReferences(xs) {
            listConcatMap(fun(x) { x.refs }, xs)
          }

          fun generateSelectivitySummary((speciesID, xs)) {
            (speciesName = speciesLongName(speciesID),
             rankOrder = generateRankOrder(xs),
             references = getReferences(xs))
          }

          var summaries = map(generateSelectivitySummary, groups);
          var references = listConcatMap(fun(x) { x.references }, summaries);
          (summaries, references)
        };

        var ((scConductance, scRectification, mRectification), conductanceRefs, conductanceLigands) = {
          fun makeConductanceInfo(speciesName, data, references) {
            (=speciesName, =data, =references)
          }

          fun transformConductanceInfo(xs) {
            fun parseMarkup(str) {
              var markup = parseOrError(str);
              var (mRefs, mLigands) = collectIds(markup);
              (markup, mRefs, mLigands)
            }

            fun go(xs, (scConductance, scRectification, mRectification, refs, ligands)) {
              switch (xs) {
                case [] -> (scConductance, scRectification, mRectification, refs, ligands)
                case x :: xs ->
                  if (x.conductance.overall_channel_conductance <> "") {
                    var (m, rs, ls) =
                      parseMarkup(x.conductance.overall_channel_conductance);
                    var refs = x.refs ++ rs ++ refs;
                    var y =
                      makeConductanceInfo(speciesLongName(x.conductance.species_id),
                          m, x.refs);
                    go(xs, (y :: scConductance, scRectification, mRectification, refs, ls ++ ligands))
                  } else if (x.conductance.single_channel_current_rectification <> "") {
                    var (m, rs, ls) =
                      parseMarkup(x.conductance.single_channel_current_rectification);
                    var refs = x.refs ++ rs ++ refs;
                    var y =
                      makeConductanceInfo(speciesLongName(x.conductance.species_id),
                          m, x.refs);
                    go(xs, (scConductance, y :: scRectification, mRectification, refs, ls ++ ligands))
                  } else if (x.conductance.macroscopic_current_rectification <> "") {
                    var (m, rs, ls) =
                      parseMarkup(x.conductance.macroscopic_current_rectification);
                    var refs = x.refs ++ rs ++ refs;
                    var y =
                      makeConductanceInfo(speciesLongName(x.conductance.species_id),
                          m, x.refs);
                    go(xs, (scConductance, scRectification, y :: mRectification, refs, ls ++ ligands))
                  } else {
                    go(xs, (scConductance, scRectification, mRectification, x.refs ++ refs, ligands))
                  }
              }
            }

            go(xs, ([], [], [], [], []))
          }

          var (scConductance, scRectification, mRectification, refs, ligands) =
            transformConductanceInfo(conductanceInfo);

          ((scConductance, scRectification, mRectification), refs, ligands)
        };

        var selInfo =
          (summaries = selectivitySummaries,
           singleChannelConductance = scConductance,
           singleChannelCurrentRectification = scRectification,
           macroscopicCurrentRectification = mRectification,
           =selectivityComments);
        (selInfo, conductanceRefs ++ summaryReferences,
         conductanceLigands)

      }


      sig transformObjectType : () ~%~> (ObjectType, [ReferenceID], [LigandID])
      fun transformObjectType() {
        fun nonempty(x) { not(listEmpty(x)) }

        if (nonempty(raw.gpcr)) {
          var rawGPCR = hd(raw.gpcr);
          var class = parseOrError(rawGPCR.class);
          var (refs, ligands) = collectIds(class);
          (GPCR((=class, ligand = rawGPCR.ligand)), refs, ligands)
        } else if (nonempty(raw.vgic)) {
          var rawVGIC = hd(raw.vgic);
          var selectivityComments = parseOrError(rawVGIC.selectivity_comments);
          var voltageDependenceComments = parseOrError(rawVGIC.voltage_dependence_comments);
          var (refs, ligands) = collectAllIds([selectivityComments, voltageDependenceComments]);
          (VGIC((physiologicalIon = rawVGIC.physiological_ion, =selectivityComments, =voltageDependenceComments)),
           refs, ligands)
        } else if (nonempty(raw.lgic)) {
          var rawLGIC = hd(raw.lgic);
          var selectivityComments = parseOrError(rawLGIC.selectivity_comments);
          var (refs, ligands) = collectIds(selectivityComments);
          (LGIC((ligand=rawLGIC.ligand, =selectivityComments)), refs, ligands)
        } else if (nonempty(raw.otherIC)) {
          var rawIC = hd(raw.otherIC);
          var selectivityComments = parseOrError(rawIC.selectivity_comments);
          var (refs, ligands) = collectIds(selectivityComments);
          (OtherIC((=selectivityComments)), refs, ligands)
        } else if (nonempty(raw.enzyme)) {
          (Enzyme, [], [])
        } else if (nonempty(raw.catalytic_receptor)) {
          (CatalyticReceptor(hd(raw.catalytic_receptor)), [], [])
        } else if (nonempty(raw.transporter)) {
          var stoichiometry = parseOrError((hd(raw.transporter)).grac_stoichiometry);
          var (refs, ligands) = collectIds(stoichiometry);
          (Transporter((=stoichiometry)), refs, ligands)
        } else if (nonempty(raw.nhr)) {
          var rawNHR = hd(raw.nhr);
          var bindingPartnerComments = parseOrError(rawNHR.binding_partner_comments);
          var coregulatorComments = parseOrError(rawNHR.coregulator_comments);
          var dnaBindingComments = parseOrError(rawNHR.dna_binding_comments);
          var targetGeneComments = parseOrError(rawNHR.target_gene_comments);
          var (refs, ligands) = collectAllIds([bindingPartnerComments, coregulatorComments,
              dnaBindingComments, targetGeneComments]);
          var res =
            (ligand = rawNHR.ligand, =bindingPartnerComments, =coregulatorComments,
             =dnaBindingComments, =targetGeneComments);
          (NHR(res), refs, ligands)
        } else {
          (Other, [], [])
        }
      }

      sig transformCoregulators : (ObjectType, %) ~%~> (SimpleTable, [Int], [Int])
      fun transformCoregulators(objectType, coregs) {
        var comments =
          switch (objectType) {
            case NHR(x) ->
              if (x.coregulatorComments <> MarkupEmpty) {
                Just(x.coregulatorComments)
              } else {
                Nothing
              }
            case _ -> Nothing
          };

        fun b2s(b) { if (b) { "Yes" } else { "No" } }

        var data =
          map(fun(x) {
              var c = x.coregulator;
              [StringData(x.gene.primary_name), StringData(c.activity), StringData(b2s(c.specific)),
               StringData(b2s(c.specific)),
               StringData(b2s(c.af2_dependent)), StringData(c.comments), References(x.refs)]
          }, coregs);

        transformTable("Main Co-regulators",
            ["Name", "Activity", "Specific", "Ligand dependent",
             "AF2-dependent", "Comments", "References"],
            data, comments)
      }

      sig transformBindingPartners : (ObjectType, %) ~%~> (SimpleTable, [Int], [Int])
      fun transformBindingPartners(objectType, bps) {
        var comments =
          switch (objectType) {
            case NHR(x) ->
              if (x.bindingPartnerComments <> MarkupEmpty) {
                Just(x.bindingPartnerComments)
              } else {
                Nothing
              }
            case _ -> Nothing
          };

        var data =
          map(fun(x) {
              var bp = x.bp;

              var name =
                switch(x.obj) {
                  case [] -> StringData(bp.name)
                  case o :: _ ->
                    LinkData((text = o.name,
                      url = ("/objectDisplay?objectId=" ^^ intToString(o.object_id))))
                };

              [name, StringData(bp.interaction), StringData(bp.effect),
               References(x.refs)]
          }, bps);

        transformTable("Co-binding partners",
            ["Name", "Interaction", "Effect", "References"],
            data, comments)
      }

      sig transformTargetGenes : (ObjectType, %) ~%~> (SimpleTable, [Int], [Int])
      fun transformTargetGenes(objectType, tgs) {
        var comments =
          switch (objectType) {
            case NHR(x) ->
              if (x.targetGeneComments <> MarkupEmpty) {
                Just(x.targetGeneComments)
              } else {
                Nothing
              }
            case _ -> Nothing
          };

        var data =
          map(fun(x) {
              var tg = x.tg;
              var name =
                LinkData((url =
                  "https://www.genenames.org/data/gene-symbol-report/#!/hgnc_id/HGNC:" ^^
                    tg.official_gene_id, text = tg.description));

              [name, StringData(speciesLongName(tg.species_id)),
                StringData(tg.effect), StringData(tg.technique),
                StringData(tg.comments), References(x.refs)]
          }, tgs);

        transformTable("Main Target Genes",
            ["Name", "Species", "Effect", "Technique", "Comments", "References"],
            data, comments)
      }

      fun transformQuaternaryStructure(comments, receptors, subunits) {
        var markup = parseOrError(comments);
        var (refs, ligands) = collectIds(markup);
        var res = (complexes = receptors, =subunits, comments = markup);
        (res, refs, ligands)
      }


      fun transformConductanceStates(states) {
        fun transform(state) {
          var cs = state.cs;
          # Bit of a hack. Most frequent states are a comma-separated list.
          # As this list will only contain numbers 1-6, we can just pass in
          # the character and check whether it's a member of the exploded
          # list, rather than doing any splitting or anything more complex.
          fun isMostFrequent(x) {
            listElem(x, explode(cs.most_frequent_state))
          }

          fun mkRange(low, high, chr) {
            (=low, =high, mostFrequent = isMostFrequent(chr))
          }

          var state1 = mkRange(cs.state1_low, cs.state1_high, '1');
          var state2 = mkRange(cs.state2_low, cs.state2_high, '2');
          var state3 = mkRange(cs.state3_low, cs.state3_high, '3');
          var state4 = mkRange(cs.state4_low, cs.state4_high, '4');
          var state5 = mkRange(cs.state5_low, cs.state5_high, '5');
          var state6 = mkRange(cs.state6_low, cs.state6_high, '6');
          (receptor = cs.receptor, =state1, =state2, =state3, =state4,
           =state5, =state6, references = state.refs)
        }

        fold_left(fun((states, refs), x) {
            var res = transform(x);
            (res :: states, res.references ++ refs)
        }, ([], []), states)
      }

      fun transformVoltageDependence(vds) {
        fun mkRange(low, median, high) {
          (=low, =median, =high)
        }

        fun mkTwoValRange(low, high) {
          (=low, =high)
        }

        fun mkVDRange(vLow, vMedian, vHigh, tLow, tHigh, refs) {
          var vRange = mkRange(vLow, vMedian, vHigh);
          var tRange = mkTwoValRange(tLow, tHigh);
          (=vRange, =tRange, =refs)
        }

        fun transformVD(vdInfo) {
          var vd = vdInfo.vd;
          var markup = parseOrError(vd.comments);
          var (refs, ligands) = collectIds(markup);
          var activationRange =
            mkVDRange(vd.activation_v_low, vd.activation_v_median, vd.activation_v_high,
                vd.activation_t_low, vd.activation_t_high, vdInfo.activationRefs);
          var inactivationRange =
            mkVDRange(vd.inactivation_v_low, vd.inactivation_v_median, vd.inactivation_v_high,
                vd.inactivation_t_low, vd.inactivation_t_high, vdInfo.inactivationRefs);
          var deactivationRange =
            mkVDRange(vd.deactivation_v_low, vd.deactivation_v_median, vd.deactivation_v_high,
                vd.deactivation_t_low, vd.deactivation_t_high, vdInfo.deactivationRefs);
          var allRefs : [Int] = refs ++ vdInfo.activationRefs ++
            vdInfo.inactivationRefs ++ vdInfo.deactivationRefs;

          ((cellType = vd.cell_type, speciesID = vd.species_id,
           =activationRange, =inactivationRange, =deactivationRange, comments = markup),
           allRefs, ligands)
        }

        fold_left(fun((transformedVDs, refs, ligands), vd) {
            var (res, vdRefs, vdLigands) = transformVD(vd);
            (res :: transformedVDs, vdRefs ++ refs, vdLigands ++ ligands)
        }, ([], [], []), vds)
      }


      fun transformPotencyOrders(pos) {
        fun transformPO(po) {
          var p = po.p;
          var description = parseOrError(p.description);
          var potencyOrder = parseOrError(p.rank_potency);
          var references = po.refs;
          var (refs, ligands) =
            collectAllIds([description, potencyOrder]);
          var res =
            (=description, =potencyOrder, speciesID = p.species_id, =references);
          (res, references ++ refs, ligands)
        }

        fold_left(fun((pos, refs, ligands), x) {
            var (res, poRefs, poLigands) = transformPO(x);
            (res :: pos, refs ++ poRefs, ligands ++ poLigands)
        }, ([], [], []), pos)
      }

      fun transformScreens(screens) {
        fun mkScreenTable(screenID, targetName, interactions) {
          var cols = [
            ("Ligand", ("", Sortable(fun(x, y) {
                simpleCmp(x.interaction.interactionLigand.name,
                    y.interaction.interactionLigand.name) }))),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("", ("", NotSortable)), ("", ("", NotSortable)),
            ("Sp.", ("keybox_header",
              Sortable(fun(x, y) { simpleCmp(x.speciesShort, y.speciesShort) }))),
            ("Type", ("action_header",
              Sortable(fun(x, y) { simpleCmp(x.interaction.interactionAction,
                  y.interaction.interactionAction) }))),
            ("Action", ("action_header",
              Sortable(fun(x, y) { simpleCmp(x.interaction.interactionAction,
                  y.interaction.interactionAction) }))),
            ("Value", ("affinity_header", Sortable(fun(x, y) {
                InteractionUtilities.sortAffinity(x.interaction.affinity,
                    y.interaction.affinity)}))),
            ("Parameter", ("units_header", Sortable(fun(x, y) {
                simpleCmp(x.interaction.affinity.affinityUnits,
                          y.interaction.affinity.affinityUnits) })))
          ];
          fun sortMessage(colName, sortDir) { SortScreenTable(screenID, targetName, colName, sortDir) }
          DataTable.makeTable(cols, interactions, sortMessage)
        }

        # First, we want to group by the individual screen interactions by screen ID
        var grouped = groupBy(fun(x) { x.si.screen_id }, screens);
        # Transform each group into a screen
        fold_left(fun((acc, refs), (_, group)) {
            var scr = hd(group).screen.scr;
            var scrRefs = hd(group).screen.refs;
            var interactions : [ParsedScreenInteraction] =
              map(fun(x) {
                (interaction = InteractionUtilities.makeScreenInteraction(x),
                 ligandSize = parseLigandSize(x.ligand.type),
                 speciesShort = speciesShortName(x.si.species_id))
              }, group);
            # Now need to group by action comment
            var groupedInteractions =
              groupBy(fun(x) { x.interaction.interactionActionComment }, interactions);
            var data = map(fun((name, interactions)) {
                (name, mkScreenTable(scr.screen_id, name, interactions))
              }, groupedInteractions);
            var res =
              (id = scr.screen_id, name = scr.name, description = scr.description,
               url = scr.url, affinityCutoff = scr.affinity_cut_off_nm,
               companyLogoFilename = scr.company_logo_filename,
               technologyLogoFilename = scr.technology_logo_filename,
               references = refs,
               =data);
            (res :: acc, scrRefs ++ refs)
        }, ([], []), grouped)
      }

      # typename Allele = (
      #     id: Int,
      #     composition: String,
      #     accessions: String,
      #     pubmedIDs: String,
      #     phenotypeID: String,
      #     phenotype: String
      #   );
      fun transformAlleles(rawAlleles) {

        var alleles =
          map(fun(x) {
            (id = x.al.allele_id,
             composition = x.al.allelic_composition,
             accessions = x.al.accessions,
             pubmedIDs = x.al.pubmed_ids,
             phenotypeID = x.ot.term_id,
             phenotype = x.ot.term)
          }, rawAlleles);

        ()

      }

      var (screens, scrRefs) = transformScreens(raw.screens);

      var ges : [GeneExpression] = transformGeneExpression(raw.geneInformation);

      var (pos, poRefs, poLigands) = transformPotencyOrders(raw.potencyOrder);

      var (vds, vdRefs, vdLigands) = transformVoltageDependence(raw.voltageDependence);

      var (cs, csRefs) = transformConductanceStates(raw.conductanceStates);

      var (qs, qsRefs, qsLigands) =
        transformQuaternaryStructure(raw.quaternary_structure_comments,
            raw.receptors, raw.subunits);

      var (dnaBindings, dnaRefs, dnaLigands) =
        transformDNABindingBox(raw.dnaBinding);

      var (objectType, otRefs, otLigands) =
        transformObjectType();

      var (coregs, crRefs, crLigands) =
        transformCoregulators(objectType, raw.coregulators);

      var dbLinks = transformDBLinks(raw.databaseLinks);

      var (variants, variantRefs, variantLigands) =
        transformVariants(raw.variants);

      var (associatedProteins, associatedProteinRefs) =
        transformAssociatedProteins(raw.associatedProteins);

      var (pdbData, pdbRefs, pdbLigands) = transformPDBs(raw.pdbData);

      var (enzymeReactions, enzymeRefs, enzymeLigands) =
        transformEnzymeReactions(raw.enzymeReactions);

      var interactions =
        transformInteractions(
            map(InteractionUtilities.makeInteraction, raw.interactions));
      var endogenousLigands = interactions.endogenous;

      var sortedInteractions = mkTables(interactions);
      var interactionRefs = interactions.references;

      var (transductions, transductionRefs, transductionLigands) =
        Transduction.transductionsForObject(objectId);

      var (functionalAssays, faRefs, faLigands) =
        transformFunctionalAssays(raw.functionalAssays);

      var (physiologicalFunctions, pfRefs, pfLigands) =
        transformPhysiologicalFunctions(raw.physiologicalFunctions);

      var (expressionPathophysiology, epRefs, epLigands) =
        transformExpressionPathophysiology(raw.expressionPathophysiology);

      var (physiologicalConsequences, pcRefs, pcLigands) =
        transformPhysiologicalConsequences(raw.alteredExpressions);

      var (tissueDistribution, tdRefs, tdLigands) =
        transformTissueDistribution(raw.tissueDistribution);

      var gpcrComments = switch(objectType) {
        case GPCR(x) -> x.class
        case _ -> MarkupEmpty
      };
      var (geneProteinInfo, gpiRefs) =
        transformGeneProteinInfo(gpcrComments, raw.geneInformation);

      var (cellTypeAssociations, ctaRefs, ctaLigands) =
        transformCellTypeAssociations(raw.cellTypeAssociations);

      var (immunoProcessAssociations, ipaRefs) =
        transformImmunoProcessAssociations(raw.immunoProcessAssociations);

      # TODO: A few more comment fields (grac_comments, structural_info_comments, quanternary_structure_comments)
      # still to be handled
      var (receptorComments, commentRefs, commentLigands) =
        transformReceptorComments();

      var (substrateTbl, substrateRefs, substrateLigands) =
        transformSubstrates(raw.substrates);

      var (products, productRefs) = transformProducts(raw.products);
      var (cofactors, cofactorRefs, cofactorLigands) =
        transformCofactors(raw.cofactors);

      var (xenobiotics, xeRefs, xeLigands) =
        transformXenobioticExpressions(receptorComments.xenobioticExpressionComments, raw.xenobiotics);

      var selectivityComments =
        switch(objectType) {
          case VGIC(x) -> x.selectivityComments
          case LGIC(x) -> x.selectivityComments
          case OtherIC(x) -> x.selectivityComments
          case _ -> MarkupEmpty
        };

      var (selectivityInfo, siRefs, siLigands) =
        generateSelectivityInfo(raw.selectivity,
            raw.conductance, selectivityComments);

      var (coregulators, coregRefs, coregLigands) =
        transformCoregulators(objectType, raw.coregulators);

      var (bindingPartners, bpRefs, bpLigands) =
        transformBindingPartners(objectType, raw.bindingPartners);

      var (targetGenes, tgRefs, tgLigands) =
        transformTargetGenes(objectType, raw.targetGenes);


      var refIDs =
        uniquify(
          otRefs ++
          variantRefs ++
          interactionRefs ++
          pdbRefs ++
          transductionRefs ++
          faRefs ++
          pfRefs ++
          pcRefs ++
          gpiRefs ++
          tdRefs ++
          ctaRefs ++
          ipaRefs ++
          associatedProteinRefs ++
          enzymeRefs ++
          substrateRefs ++
          productRefs ++
          cofactorRefs ++
          siRefs ++
          coregRefs ++
          dnaRefs ++
          bpRefs ++
          tgRefs ++
          xeRefs ++
          qsRefs ++
          csRefs ++
          vdRefs ++
          poRefs ++
          epRefs ++
          scrRefs ++
          commentRefs);

      var ligandIDs =
        uniquify(
          otLigands ++
          variantLigands ++
          pdbLigands ++
          transductionLigands ++
          faLigands ++
          pfLigands ++
          pcLigands ++
          tdLigands ++
          ctaLigands ++
          enzymeLigands ++
          substrateLigands ++
          cofactorLigands ++
          siLigands ++
          coregLigands ++
          dnaLigands ++
          bpLigands ++
          tgLigands ++
          xeLigands ++
          qsLigands ++
          vdLigands ++
          poLigands ++
          epLigands ++
          commentLigands);

      var ligandNames = Ligand.queryLigands(ligandIDs);

      var refs = Reference.mkReferenceData(Reference.queryReferences(refIDs));
      fun parseIfNonempty(str) {
        if (str == "") {
          Nothing
        } else {
          Just(parseOrError(str))
        }
      }

      var systematicName = parseIfNonempty(raw.systematicName);
      var abbreviation = parseIfNonempty(raw.abbreviation);

      (=objectId,
       =objectType,
       objectName = parseOrError(raw.name),
       objectSystematicName = systematicName,
       objectAbbreviation = abbreviation,
       objectSynonyms = transformSynonyms(raw.synonyms),
       objectFamily = transformFamily(raw.family),
       objectGeneProteinInfo = geneProteinInfo,
       objectDatabaseLinks = dbLinks,
       objectAnnotationStatus = raw.annotationStatus,
       objectEnzymeReactions = enzymeReactions,
       objectPDBData = pdbData,
       objectEndogenousLigands = endogenousLigands,
       objectSortedInteractions = sortedInteractions,
       objectTransductionMechanisms = transductions,
       objectVariants = variants,
       objectComments = receptorComments,
       objectLigandNames = ligandNames,
       objectShowReferences = false,
       objectReferences = refs,
       objectFunctionalAssays = functionalAssays,
       objectPhysiologicalFunctions = physiologicalFunctions,
       objectExpressionPathophysiology = expressionPathophysiology,
       objectPhysiologicalConsequences = physiologicalConsequences,
       objectTissueDistribution = tissueDistribution,
       objectCellTypeAssociations = cellTypeAssociations,
       objectImmunoProcessAssociations = immunoProcessAssociations,
       objectGeneExpression = ges,
       objectAssociatedProteins = associatedProteins,
       objectSpeciesMap = speciesMap,
       objectSubstrates = substrateTbl,
       objectProducts = products,
       objectCofactors = cofactors,
       objectSelectivityInfo = selectivityInfo,
       objectCoregulators = coregulators,
       objectDNABindings = dnaBindings,
       objectBindingPartners = bindingPartners,
       objectTargetGenes = targetGenes,
       objectXenobioticExpressions = xenobiotics,
       objectQuaternaryStructure = qs,
       objectContributors = transformContributors(raw.contributors),
       objectVoltageDependence = vds,
       objectPotencyOrder = pos,
       objectConductanceStates = cs,
       objectScreens = screens,
       chartsShown = false)
    }

    switch(raw) {
      case [] -> Nothing
      case x :: _ -> Just(mkModel(x))
    }
  }

  switch(lookup("objectId", environment())) {
    case Just(id) -> getObjectInfo(stringToInt(id))
    case Nothing -> Nothing
  }
}

sig view : (Model) ~%~> HTML(Message)
fun view(model) {
  sig viewModel : (ObjectInfo) ~%~> HTML(Message)
  fun viewModel(objectInfo) {
    var a0 = MvuAttrs.empty;
    var h0 = MvuHTML.empty;

    fun speciesLongName(speciesId) {
      Species.resolveSpeciesLongName(speciesId, objectInfo.objectSpeciesMap)
    }

    fun speciesShortName(speciesId) {
      Species.resolveSpeciesShortName(speciesId, objectInfo.objectSpeciesMap)
    }

    sig renderM : (Markup) ~%~> HTML(Message)
    fun renderM(m) {
      RenderMarkup.renderMarkup(m,
          objectInfo.objectReferences,
          objectInfo.objectLigandNames)
    }

    fun renderKeyVal((key, val)) {
      tr(a0,
        td(class("key"), textNode(key ^^ ":")) +*
        td(class("value"), val))
    }

    fun renderCitations(refs) {
      Reference.renderCitationList(uniquify(refs), objectInfo.objectReferences)
    }

    fun renderIfJust(heading, x) {
      switch(x) {
        case Just(markup) ->
          p(a0,
            b(a0, textNode(heading ^^ ": ")) +*
            renderM(markup))
        case Nothing -> MvuHTML.empty
      }
    }

    #sig renderTwoValRange : (TwoValueRange) ~%~> HTML(Message)
    fun renderTwoValRange(range) {
      if (range.low == 0.0 && range.high == 0.0) {
        textNode("-")
      } else if (range.low <> 0.0 && range.high <> 0.0) {
        textNode(floatToString(range.low) ^^ " - " ^^ floatToString(range.high))
      } else if (range.low <> 0.0) {
        textNode(floatToString(range.low))
      } else {
        textNode(floatToString(range.high))
      }
    }

    fun renderThreeValRange(range) {
      if (range.low == 0.0 && range.median == 0.0 && range.high == 0.0) {
        textNode("-")
      } else if (range.median <> 0.0) {
        textNode(floatToString(range.median))
      } else if (range.low <> 0.0 && range.high <> 0.0) {
        textNode(floatToString(range.low) ^^ " - " ^^ floatToString(range.high))
      } else if (range.low <> 0.0) {
        textNode(floatToString(range.low))
      } else {
        textNode(floatToString(range.high))
      }
    }

    var sysNomenclature =
      renderIfJust("Systematic Nomenclature", objectInfo.objectSystematicName);
    var abbrev =
      renderIfJust("Abbreviation", objectInfo.objectAbbreviation);

    var infoBox = {
    div(class("grid_16 alpha"),
      a(name("top"), MvuHTML.empty) +*
      h4(a0, renderM(objectInfo.objectName)) +*
      div(class("contentboxfullhelp"),
        div(class("textmiddle"),
          p(a0, b(a0, textNode("Target id: ")) +*
            textNode(intToString(objectInfo.objectId))) +*
          p(a0,
            b(a0, textNode("Nomenclature: ")) +*
            renderM(objectInfo.objectName)) +*
          sysNomenclature +*
          abbrev +*
          p(a0,
            b(a0, textNode("Family: ")) +*
            a(href("/familyDisplay?familyId=" ^^ intToString(objectInfo.objectFamily.familyId)),
              renderM(objectInfo.objectFamily.familyName))) +*
          p(a0,
            b(a0, textNode("Annotation status: ")) +*
            renderAnnotationStatus(objectInfo.objectAnnotationStatus)))))
    };


    fun dataBox(header, cols, contents) {
      var cs = if (cols == 1) { MvuAttrs.empty } else { colSpan(cols) };
      table_(class("receptor_data_tables fullwidth"),
        thead(a0,
          tr(name("hotspot") +@ class("hotspot"),
            td(class("info category") +@ cs,
              textNode(header)))) +*
        tbody(name("toggle"), contents))
    }

    fun commentsBox(header, markup) {
      if (Parser.markupEmpty(markup)) {
        MvuHTML.empty
      } else {
        dataBox(header, 1,
          tr(a0,
          td(class("info"),
            renderM(markup))))
      }
    }

    var comments = objectInfo.objectComments;

    var qsBox = {
      var qs = objectInfo.objectQuaternaryStructure;
      if (not(
        listEmpty(qs.complexes) &&
        listEmpty(qs.subunits) &&
        markupEmpty(qs.comments))) {

        # Complexes
        var complexes =
          if (not(listEmpty(qs.complexes))) {
            fun renderComplex(c) {
              tr(a0,
                td(class("info"),
                  a(href("/objectDisplay?objectId=" ^^ intToString(c.id)), unescapedTextNode(c.name))))
            }

            var renderedComplexes = MvuHTML.concatMap(renderComplex, qs.complexes);

            tr(a0,
              td(class("info category"), textNode("Quaternary Structure: Complexes"))) +*
            renderedComplexes
          } else {
            MvuHTML.empty
          };

        # Subunits
        var subunits =
          if (not(listEmpty(qs.subunits))) {
            fun renderSubunit(c) {
              var type =
                if (c.type <> "") {
                  unescapedTextNode(" (" ^^ c.type ^^ ")")
                } else {
                  MvuHTML.empty
                };
              tr(a0,
                td(class("info"),
                  a(href("/objectDisplay?objectId=" ^^ intToString(c.id)),
                    unescapedTextNode(c.name)) +* type))
            }

            var renderedSubunits = MvuHTML.concatMap(renderSubunit, qs.subunits);

            tr(a0,
              td(class("info category"), textNode("Quaternary Structure: Subunits"))) +*
            renderedSubunits
          } else {
            MvuHTML.empty
          };

        # Comments
        var comments =
          if (not(markupEmpty(qs.comments))) {
            tr(a0,
              td(class("info category"), textNode("Quaternary Structure Comments"))) +*
            tr(a0,
              td(class("info"), renderM(qs.comments)))
          } else {
            MvuHTML.empty
          };

        a(name("QuaternaryStructure"), h0) +*
        table_(class("receptor_data_tables fullwidth"),
          complexes +*
          subunits +*
          comments)

      } else {
        MvuHTML.empty
      }
    };

    var synonymsBox = {
      if (objectInfo.objectSynonyms == []) { MvuHTML.empty } else {
        var renderedSynonyms = map(fun(m) { [renderM(m)] }, objectInfo.objectSynonyms);
        var separatedSynonyms = MvuHTML.concat(join([textNode(" | ")], renderedSynonyms));
        var row = tr(a0, td(class("info"), separatedSynonyms));
        dataBox("Previous and Unofficial Names", 1, row)
      }
    };

    var dbLinksBox =
      renderDatabaseLinks(objectInfo.objectDatabaseLinks, objectInfo.objectSpeciesMap);
    var endogenousLigandsBox = {
      fun renderSummary(els) {
        tr(class("info"),
            td(a0,
              a(href("/ligandDisplay?ligandId=" ^^ intToString(els.elsLigandID)),
                renderM(els.elsName))))
      }

      if (not(listEmpty(objectInfo.objectEndogenousLigands))) {
        var renderedSummaries =
          MvuHTML.concatMap(renderSummary, objectInfo.objectEndogenousLigands);

        a(name("Endogenous"), h0) +*
        table_(class("receptor_data_tables fullwidth"),
          thead(a0,
            tr(a0,
              td(class("info category"), textNode("Natural/Endogenous Ligands")))) +*
          tbody(a0,
            renderedSummaries +*
            tr(class("info"),
              td(a0,
                b(a0, textNode("Comments: ")) +*
                renderM(objectInfo.objectComments.listComments)))))
      } else {
        MvuHTML.empty
      }
    };

    var potencyOrderBox = {
      fun renderPO(po) {
        var species = {
          var speciesName = speciesLongName(po.speciesID);
          if (speciesName <> "None" && speciesName <> "Unknown") {
            textNode(" (" ^^ speciesName ^^ ")")
          } else {
            MvuHTML.empty
          }
        };


        tr(a0,
          td(class("info category"),
            renderM(po.description) +* species)) +*
        tr(class("info"),
          td(a0,
            renderM(po.potencyOrder) +* textNode(" ") +*
            renderCitations(po.references)))
      }

      if (not(listEmpty(objectInfo.objectPotencyOrder))) {
        table_(class("receptor_data_tables fullwidth"),
          MvuHTML.concatMap(renderPO, objectInfo.objectPotencyOrder))
      } else {
        MvuHTML.empty
      }
    };

    var interactionsTables = {
      fun renderImgCols(x) {
        var i = x.interaction;

        var sizeCol = ligandSizeCol(x.ligandSize);
        var approvedCol = boolImage(("/images/approved.png", i.interactionLigand.approved, "Approved ligand"));
        var primaryCol = boolImage(("/images/primary.png", i.primaryTarget, "Primary interaction"));
        var selectiveCol =
          boolCol(i.selective,
            a(href("/ligandInteractions?ligandId=" ^^
                intToString(i.ligandID) ^^ "&speciesId=" ^^ intToString(i.speciesID)), h0) +*
            img(src("/images/select.gif") +@ alt("Click here for species-specific selectivity table"), h0));
        var endogenousCol =
          boolImage(("/images/endogenous.gif", i.endogenous,
                "Ligand is endogenous in the given species"));
        var labelled = boolImage(("/images/probe.png", i.interactionLigand.labelled, "Ligand is labelled"));
        var radioactive = boolImage(("/images/rad.gif", i.interactionLigand.radioactive, "Ligand is radioactive"));
        # FIXME: We need to include the information about PDB structures here. I think the best way of doing this
        # is likely to have some sort of "ligand summary" that can be loaded easily from the interactions rather
        # than using the whole table.
        var hasPDB =
          boolImage(("/images/protein_structure_icon.png", false, "Ligand has a PDB structure"));
        var immuno =
          boolImage(("/images/immuno_ligand.png", i.interactionLigand.in_gtip, "Immunopharmacology Ligand"));

        MvuHTML.concat([sizeCol, approvedCol, primaryCol, selectiveCol, endogenousCol,
            labelled, radioactive, hasPDB, immuno])
      }

      fun renderReceptorTable((tbl, label, commentsHeader, comments)) {
        if (DataTable.getTableData(tbl) == []) {
          MvuHTML.empty
        } else {

          fun renderRow(x) {
            var x : InteractionInfo = x;
            var i = x.interaction;
            var imgCols = renderImgCols(x);

            var nameCol =
              td(a0,
                a(href("/ligandDisplay?ligandId=" ^^ intToString(i.ligandID)), renderM(x.parsedName)));
            var speciesCol =
              td(a0, textNode(x.speciesShort));
            var actionCol =
              td(a0, textNode(i.interactionAction));
            var affinityCol =
              td(a0, InteractionUtilities.displayAffinity(i.affinity, false));
            var parameterCol =
              td(a0, textNode(i.affinity.affinityUnits));
            var referenceCol =
              td(a0, Reference.renderCitationList(i.references, objectInfo.objectReferences));
            tr(class("info"),
              nameCol +*
              imgCols +*
              speciesCol +*
              actionCol +*
              affinityCol +*
              parameterCol +*
              referenceCol)
          }

          dataBox(label, 1,
            a(name(label), h0) +*
            tr(a0, td(class("table_container") +@ style("border-style:solid solid none solid;"),
            DataTable.renderTable(tbl, renderRow)))) +*
          commentsBox(commentsHeader, comments)
        }
      }

      fun renderICTable((tbl, label, commentsHeader, comments)) {
        if (DataTable.getTableData(tbl) == []) {
          MvuHTML.empty
        } else {

          fun renderRow(x) {
            var x : InteractionInfo = x;
            var i = x.interaction;
            var imgCols = renderImgCols(x);

            var nameCol =
              td(a0,
                a(href("/ligandDisplay?ligandId=" ^^ intToString(i.ligandID)), renderM(x.parsedName)));
            var speciesCol =
              td(a0, textNode(x.speciesShort));
            var actionCol =
              td(a0, textNode(i.interactionAction));
            var valueCol =
              td(a0, InteractionUtilities.displayAffinity(i.affinity, false));
            var parameterCol =
              td(a0, textNode(i.affinity.affinityUnits));
            var concentrationCol =
              td(a0, textNode(i.concentrationRange));
            var affinityVoltageCol =
              td(a0, InteractionUtilities.displayAffinityVoltage(i.affinityVoltage));
            var referenceCol =
              td(a0, Reference.renderCitationList(i.references, objectInfo.objectReferences));

            tr(class("info"),
              nameCol +*
              imgCols +*
              speciesCol +*
              actionCol +*
              valueCol +*
              parameterCol +*
              concentrationCol +*
              affinityVoltageCol +*
              referenceCol)
          }

          dataBox(label, 1,
            a(name(label), h0) +*
            tr(a0, td(class("table_container") +@ style("border-style:solid solid none solid;"),
            DataTable.renderTable(tbl, renderRow)))) +*
          commentsBox(commentsHeader, comments)
        }
      }

      var subunitTable = {
        var tbl = objectInfo.objectSortedInteractions.subunitSpecific;
        if (DataTable.getTableData(tbl) == []) {
          MvuHTML.empty
        } else {

          fun renderRow(x) {
            var x : InteractionInfo = x;
            var i = x.interaction;
            var imgCols = renderImgCols(x);
            var nameCol =
              td(a0,
                a(href("/ligandDisplay?ligandId=" ^^ intToString(i.ligandID)), renderM(x.parsedName)));
            var actionCol =
              td(a0, textNode(i.interactionAction));
            var specificityCol =
              td(a0, unescapedTextNode(i.interactionActionComment));
            var concentrationCol =
              td(a0, textNode(i.concentrationRange));
            var referenceCol =
              td(a0, Reference.renderCitationList(i.references, objectInfo.objectReferences));

            tr(class("info"),
              nameCol +*
              imgCols +*
              actionCol +*
              specificityCol +*
              concentrationCol +*
              referenceCol)
          }

          dataBox("Subunit-specific Pharmacological Agents at Recombinant Receptors", 1,
            a(name("SubunitSpecific"), h0) +*
            tr(a0, td(class("table_container") +@ style("border-style:solid solid none solid;"),
            DataTable.renderTable(tbl, renderRow))))
        }
      };

      var wholeOrganismAssayTable = {
        var tbl = objectInfo.objectSortedInteractions.wholeOrganismAssays;
        if (DataTable.getTableData(tbl) == []) {
          MvuHTML.empty
        } else {

          fun renderRow(x) {
            var x : InteractionInfo = x;
            var i = x.interaction;
            var imgCols = renderImgCols(x);

            var nameCol =
              td(a0,
                a(href("/ligandDisplay?ligandId=" ^^ intToString(i.ligandID)), renderM(x.parsedName)));
            var speciesCol =
              td(a0, textNode(x.speciesShort));
            var assayDescriptionCol =
              td(a0, unescapedTextNode(i.assayDescription));
            var affinityCol =
              td(a0, InteractionUtilities.displayAffinity(i.affinity, false));
            var parameterCol =
              td(a0, textNode(i.affinity.affinityUnits));
            var referenceCol =
              td(a0, Reference.renderCitationList(i.references, objectInfo.objectReferences));
            tr(class("info"),
              nameCol +*
              imgCols +*
              speciesCol +*
              assayDescriptionCol +*
              affinityCol +*
              parameterCol +*
              referenceCol)
          }

          dataBox("Whole Organism Assay Data Linked to This Target", 1,
            a(name("WholeOrganismAssays"), h0) +*
            tr(a0, td(class("table_container") +@ style("border-style:solid solid none solid;"),
            DataTable.renderTable(tbl, renderRow))))
        }
      };

      var si = objectInfo.objectSortedInteractions;
      var oc = objectInfo.objectComments;
      var receptorTables = [
        (si.agonists, "Agonists", "Agonist Comments", oc.agonistsComments),
        (si.antagonists, "Antagonists", "Antagonist Comments", oc.antagonistsComments),
        (si.antibodies, "Antibodies", "Antibody Comments", oc.antibodyComments),
        (si.other, "Other Binding Ligands", "", MarkupEmpty)
        #(si.subunitSpecific, "Subunit-specific",
        # "Subunit-specific Comments", MarkupEmpty)
      ];

      var channelTables = [
        (si.activators, "Activators", "Activator Comments", oc.activatorsComments),
        (si.inhibitors, "Inhibitors", "Inhibitor Comments", oc.inhibitorsComments),
        (si.channelBlockers, "Channel Blockers", "Channel Blocker Comments", oc.channelBlockersComments),
        (si.allostericModulators, "Allosteric Modulators",
           "Allosteric Modulator Comments", oc.allostericModulatorsComments),
        (si.gatingInhibitors, "Gating Inhibitors",
         "Gating Inhibitor Comments", oc.gatingInhibitorsComments)
      ];

      MvuHTML.concatMap(renderReceptorTable, receptorTables) +*
      MvuHTML.concatMap(renderICTable, channelTables) +*
      wholeOrganismAssayTable +*
      subunitTable

    };

    var screens = {
      fun renderScreen(screen) {

        var contents = {
          if (not(screen.description == "" && screen.url == "" && listEmpty(screen.references) &&
              screen.companyLogoFilename == "" && screen.technologyLogoFilename == "")) {

            var logosEmpty = not(screen.companyLogoFilename == "" && screen.technologyLogoFilename == "");
            fun logoIfNonempty(url) {
              if (url <> "") {
                img(src("/images/" ^^ url), h0)
              } else {
                MvuHTML.empty
              }
            }

            var colCount =
              if (logosEmpty) { 2 } else { 3 };
            var tdAttrs =
              if (logosEmpty) {
                colSpan(3)
              } else {
                style("border-style: solid none solid solid;") +@ colSpan(2)
              };
            var url =
              if (screen.url <> "") {
                p(style("font-size:small;"), a(href(screen.url), textNode(screen.url)))
              } else {
                MvuHTML.empty
              };

            var refs = p(a0, renderCitations(screen.references));

            var screenInfo =
              td(class("table_instructions") +@ tdAttrs,
                 p(a0, unescapedTextNode(screen.description)) +*
                 url +*
                 refs);

            var logoInfo =
              if (not(logosEmpty)) {
                td(class("not(table_instructions") +@
                    style("text-align:right; border-style: solid solid solid none;"),
                  logoIfNonempty(screen.companyLogoFilename) +*
                  logoIfNonempty(screen.technologyLogoFilename))
              } else {
                MvuHTML.empty
              };

            var tables = {
              fun renderRow(row) {
                # Ligand, size, approved, selective, endogenous, radioactive,
                # has PDB, immuno, species, type, action, value, parameter
                var i = row.interaction;
                var sizeCol = ligandSizeCol(row.ligandSize);
                var approvedCol = boolImage(("/images/approved.png", i.interactionLigand.approved, "Approved ligand"));
                var selectiveCol =
                  boolCol(false, # I think this is false by default
                    a(href("/ligandInteractions?ligandId=" ^^
                        intToString(i.ligandID) ^^ "&speciesId=" ^^ intToString(i.speciesID)), h0) +*
                    img(src("/images/select.gif") +@ alt("Click here for species-specific selectivity table"), h0));
                var endogenousCol =
                  boolImage(("/images/endogenous.gif", i.endogenous,
                        "Ligand is endogenous in the given species"));
                var labelled = boolImage(("/images/probe.png", i.interactionLigand.labelled, "Ligand is labelled"));
                var radioactive = boolImage(("/images/rad.gif", i.interactionLigand.radioactive, "Ligand is radioactive"));
                var hasPDB =
                  boolImage(("/images/protein_structure_icon.png", false, "Ligand has a PDB structure"));
                var immuno =
                  boolImage(("/images/immuno_ligand.png", i.interactionLigand.in_gtip, "Immunopharmacology Ligand"));


                var ligandName = a(href("/ligandDisplay?ligandId=" ^^ intToString(i.interactionLigand.ligand_id)),
                    unescapedTextNode(i.interactionLigand.name));
                var species = td(a0, textNode(row.speciesShort));
                var interactionType = td(a0, textNode(i.interactionType));
                var action = td(a0, textNode(i.interactionAction));
                var value = td(a0, displayAffinity(i.affinity, false));
                var parameter = td(a0, textNode(i.affinity.affinityUnits));

                tr(class("info"),
                  ligandName +* sizeCol +* approvedCol +* selectiveCol +* endogenousCol +*
                    labelled +* radioactive +* hasPDB +* immuno +* species +* interactionType +*
                    action +* value +* parameter)
              }

              fun renderScreenTable((name, tbl)) {
                var assayName = {
                  var interaction = hd(getTableData(tbl));
                  if (interaction.interaction.assayURL <> "") {
                    a(href(interaction.interaction.assayURL), unescapedTextNode(name))
                  } else {
                    unescapedTextNode(name)
                  }
                };

                var heading =
                  tr(class("info heading"),
                    th(class("info category embedded_link") +@ colSpan(3) +@ style("padding:8px"),
                      MvuHTML.i(a0, textNode("Target used in screen: ")) +* assayName));
                var tbl =
                  tr(a0,
                    td(class("table_container") +@ style("border-style:solid solid none solid;") +@ colSpan(3),
                      DataTable.renderTable(tbl, renderRow)));
                heading +* tbl
              }
              MvuHTML.concatMap(renderScreenTable, screen.data)
            };

            tr(a0, screenInfo +* logoInfo) +*
            tr(a0, tables)

          } else {
            MvuHTML.empty
          }
        };
        dataBox(screen.name, 3, contents)
      }

      MvuHTML.concatMap(renderScreen, objectInfo.objectScreens)
    };

    var immunoCommentsBox =
      commentsBox("Immunopharmacology Comments", comments.immunoComments);
    var malariaCommentsBox =
      commentsBox("Malaria Comments", comments.malariaComments);

    var transductionMechanismsBoxes = {
      var tms = objectInfo.objectTransductionMechanisms;
      if (tms == []) {
        MvuHTML.empty
      } else {
        var (primary, secondary) = partition(fun(t) { not(t.tSecondary) }, tms);
        fun renderTransduction(t) {
          fun renderMarkups(ms) {
            MvuHTML.concatMap(fun(m) { p(a0, renderM(m)) }, ms)
          }
          var commentsRow =
            if (Parser.markupEmpty(t.tComments)) { MvuHTML.empty } else {
              tr(a0,
                td(colSpan(2) +@ class("info"),
                  textNode("Comments: ") +*
                  renderM(t.tComments)))
            };
          var referencesRow =
            if (t.tReferences == []) { MvuHTML.empty } else {
              tr(a0,
                td(colSpan(2) +@ class("info"),
                  textNode("References: ") +*
                  Reference.renderCitationList(t.tReferences, objectInfo.objectReferences)))
            };

          tr(a0,
            td(class("info"),
              renderMarkups(t.tTransducers)) +*
            td(class("info"),
              renderMarkups(t.tEffectors))) +*
          commentsRow +*
          referencesRow
        }

        var primaryBox = if (primary == []) { MvuHTML.empty } else {
          dataBox("Primary Transduction Mechanisms", 2,
              MvuHTML.concatMap(renderTransduction, primary))
        };

        var secondaryBox = if (secondary == []) { MvuHTML.empty } else {
          dataBox("Secondary Transduction Mechanisms", 2,
              MvuHTML.concatMap(renderTransduction, secondary))
        };

        primaryBox +* secondaryBox
      }
    };

    fun renderDataBox(box) {
      fun renderDataRow(row) {

        fun renderDatum((k, v)) {
          tr(a0,
            td(class("key"), textNode(k)) +*
            td(class("value"), renderM(v)))
        }

        var renderedData = MvuHTML.concatMap(renderDatum, row.entryData);
        var referencesRow =
          if (row.entryReferences == []) {
            MvuHTML.empty
          } else {
            tr(a0,
              td(class("key"), textNode("References")) +*
              td(class("value"),
                Reference.renderCitationList(row.entryReferences,
                  objectInfo.objectReferences)))
          };

        tr(a0,
          td(class("info"),
            table_(class("inner_receptor_data_tables"),
              tr(a0,
                td(class("description"), renderM(row.entryComment))) +*
              tr(a0,
                td(a0,
                  table_(class("inner_receptor_data_tables"),
                    renderedData +* referencesRow))))))
      }

      var renderedRows = MvuHTML.concatMap(renderDataRow, box.boxRows);

      if (not(listEmpty(box.boxRows))) {
        a(name(box.boxName), h0) +*
          table_(class("receptor_data_tables fullwidth"),
            thead(a0,
              tr(name("hotspot") +@ class("hotspot"),
                td(class("info category"), textNode(box.boxName)))) +*
            tbody(name("toggle"), renderedRows))
      } else {
        MvuHTML.empty
      }

    }

    var dnaBindingsBox =
      renderDataBox(objectInfo.objectDNABindings);
    var dnaComments =
      switch (objectInfo.objectType) {
        case NHR(x) ->
          commentsBox("DNA Binding Comments", x.dnaBindingComments)
        case _ -> MvuHTML.empty
      };

    var coregulatorsBox =
      renderSimpleTable(objectInfo.objectCoregulators,
          objectInfo.objectReferences, objectInfo.objectLigandNames);

    var bindingPartnersBox =
      renderSimpleTable(objectInfo.objectBindingPartners,
          objectInfo.objectReferences, objectInfo.objectLigandNames);

    var targetGenesBox =
      renderSimpleTable(objectInfo.objectTargetGenes,
          objectInfo.objectReferences, objectInfo.objectLigandNames);

    var tissueDistributionBox =
      renderDataBox(objectInfo.objectTissueDistribution);

    var expressionDatasetsBox = {
      var charts =
        MvuHTML.concat(
          mapi(fun(x, i) {
            htmlWidget("div",
              [("id", "chart" ^^ intToString(i)),
               ("style", "width: 910px; height: 400px; margin-top:10px;")])
          }, objectInfo.objectGeneExpression));

        var showChartsLink =
       #if (objectInfo.chartsShown) {
       #  MvuHTML.empty
       #} else {
          p(a0,
            a(href("javascript:void(0)") +@ onClick(fun() { ShowCharts }),
                  textNode("Show charts")));
       # };

      var description =
        p(style("text-align:left;margin-top:10px;"),
            unescapedTextNode("Log average relative transcript abundance " ^^
              "in mouse tissues measured by qPCR from Regard, J.B., Sato, " ^^
              "I.T., and Coughlin, S.R. (2008). Anatomical profiling of " ^^
              "G protein-coupled receptor expression. <i>Cell</i>, <b>135</b>(3): 561-71."));

      var content =
        tr(a0,
          td(class("info"),
            table_(class("inner_receptor_data_tables"),
              tr(a0,
                td(class("description"), showChartsLink +* description +*
                div(a0, charts))))));

      dataBox("Expression Datasets", 1, content)
    };

    var functionalAssaysBox =
      renderDataBox(objectInfo.objectFunctionalAssays);
    var physiologicalFunctionsBox =
      renderDataBox(objectInfo.objectPhysiologicalFunctions);
    var physiologicalConsequencesBox =
      renderDataBox(objectInfo.objectPhysiologicalConsequences);
    var xenobioticsBox =
      renderDataBox(objectInfo.objectXenobioticExpressions);

    var expressionPathophysiologyBox =
      renderDataBox(objectInfo.objectExpressionPathophysiology);

    var expressionPathophysiologyComments =
      commentsBox("Gene Expression and Pathophysiology Comments",
          objectInfo.objectComments.expressionPathophysiologyComments);


    var phenotypesBox = MvuHTML.empty;
    var generalCommentsBox =
      commentsBox("General Comments", comments.generalComments);
    var contributorsBox = MvuHTML.empty;

    var pdbStructureBox = {
      fun renderPDBRow(pdb) {

        fun renderPDBDataRow(propName, html) {
          tr(a0,
            td(class("key") +@ style("width:100px;"), textNode(propName)) +*
            td(class("value"), html))
        }
        var descRow =
          renderPDBDataRow("Description:", renderM(pdb.pdbLigandDescription));

        var pdbIDRow =
          renderPDBDataRow("PDB Id:",
              a(href("http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=" ^^ pdb.pdbCode) +@
                title("RCSB PDB: an information portal to biological macromolecular structures"),
                textNode(pdb.pdbCode)));

        var ligandRow =
          renderPDBDataRow("Ligand:",
              a(href("/ligandDisplay?ligandId=" ^^ intToString(pdb.pdbLigandId)),
                renderM(pdb.pdbLigandName)));

        var resolutionRow =
          renderPDBDataRow("Resolution:", textNode(floatToString(pdb.pdbResolution)));

        var speciesRow =
          renderPDBDataRow("Species:", textNode(speciesLongName(pdb.pdbSpeciesId)));

        var referencesRow =
          renderPDBDataRow("References:",
              Reference.renderCitationList(pdb.pdbReferences,
                objectInfo.objectReferences));

        tr(a0,
          td(class("info") +@ align("center") +@ valign("center"),
            a(style("color:white;") +@
              href("http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=" ^^ pdb.pdbCode) +@
              title("Image of receptor 3D structure from RCSB PDB") +@ target("_blank"),
            img(src("http://www.rcsb.org/pdb/images/" ^^ pdb.pdbCode ^^ "_bio_r_500.jpg") +@
              height("200") +@ width("200") +@ alt("Image of receptor 3D structure from RCSB PDB"), h0))) +*
          td(class("info") +@ valign("top"),
            table_(class("inner_receptor_data_tables"),
              descRow +*
              pdbIDRow +*
              ligandRow +*
              resolutionRow +*
              speciesRow +*
              referencesRow)))
      }

      var pdbRows = MvuHTML.concatMap(renderPDBRow, objectInfo.objectPDBData);

      if (objectInfo.objectPDBData == []) {
        MvuHTML.empty
      } else {
        a(name("PDBStructures"), h0) +*
        table_(class("receptor_data_tables fullwidth"),
          thead(a0,
            tr(name("hotspot") +@ class("hotspot"),
              td(class("info category") +@ colSpan(2),
                textNode("Selected 3D Structures")))) +*
          tbody(name("toggle"), pdbRows))
      }
    };


    var geneProteinInfoBox = {
      var gi = objectInfo.objectGeneProteinInfo;
      var headings = ["Species", "TM", "AA", "Chromosomal Location", "Gene Symbol",
          "Gene Name", "Reference"];
      fun renderHeading(h) { td(class("info heading"), textNode(h)) }
      var renderedHeadings = MvuHTML.concatMap(renderHeading, headings);

      fun renderRow(gpi) {
        fun renderData(val) {
          td(class("info centre"), val)
        }
        var data = [
          textNode(speciesLongName(gpi.gpiSpeciesID)),
          textNode(intToString(gpi.gpiTransmembraneDomains)),
          textNode(intToString(gpi.gpiAminoAcids)),
          textNode(gpi.gpiChromosomalLocation),
          textNode(gpi.gpiShortName),
          renderM(gpi.gpiName),
          Reference.renderCitationList(gpi.gpiReferences,
              objectInfo.objectReferences)
        ];
        tr(a0, MvuHTML.concatMap(renderData, data))
      }
      var renderedRows = MvuHTML.concatMap(renderRow, gi.giEntries);

      a(name("StructuralInfo"), h0) +*
      table_(class("receptor_data_tables fullwidth"),
        thead(a0,
          tr(name("hotspot") +@ class("hotspot"),
            td(class("info category") +@ colSpan(7),
              textNode("Gene and Protein Information")))) +*
        tbody(name("toggle"),
          tr(a0,
            td(class("info") +@ colSpan(7), renderM(gi.giComments))) +*
          tr(a0, renderedHeadings) +*
          renderedRows))
    };

    var cellTypeAssociationsBox = {
      fun renderCTA(cta) {
        var ct = cta.ctaImmunoCelltype;
        var cto = cta.ctaCellOntologyType;
        var cellTypeContent =
          a(href("/objectCelltypeAssocList?immCellType=" ^^
                intToString(ct.immunoCTID)), textNode(ct.immunoCTName));
        var cellOntologyContent =
          textNode(cto.cellOntologyName ^^ " (" ^^ cto.cellOntologyID ^^ ")");
        var referencesRow =
          if (cta.ctaReferences == []) { MvuHTML.empty } else {
            renderKeyVal(("References",
                Reference.renderCitationList(cta.ctaReferences,
                  objectInfo.objectReferences)))
          };
        var rows =
          [("Immuno Cell Type", cellTypeContent),
           ("Cell Ontology Term", cellOntologyContent),
           ("Comment", renderM(cta.ctaComments))];
        var renderedRows = MvuHTML.concat(map(renderKeyVal, rows) ++ [referencesRow]);
        tr(a0,
          td(class("info"),
            table_(class("inner_receptor_data_tables"), renderedRows)))
      }

      var renderedCTAs =
        MvuHTML.concatMap(renderCTA, objectInfo.objectCellTypeAssociations);

      if (not(listEmpty(objectInfo.objectCellTypeAssociations))) {
        a(name("Celltypes"), h0) +*
        table_(class("receptor_data_tables fullwidth"),
          tr(name("hotspot") +@ class("hotspot"),
            td(class("info category"), textNode("Cell Type Associations"))) +*
          renderedCTAs)
      } else {
        MvuHTML.empty
      }
    };

    var immunoProcessAssociationsBox = {
      fun renderProcess(proc) {
        var iProc = proc.ipImmunoProcess;
        var goProcCount = length(proc.ipGoProcesses);

        var (ieaProcs, otherProcs) =
          partition(fun(p) { p.goProcessEvidence == "IEA" }, proc.ipGoProcesses);

        var goAnnotationsCountRow = {
          var content = {
            var suffix =
              if (otherProcs == []) {
                textNode(", IEA only")
              } else { MvuHTML.empty };
            textNode("Associated to " ^^ intToString(goProcCount) ^^ " processes") +*
            suffix
          };
          renderKeyVal(("Go Annotations", content))
        };

        fun renderGoProcess(goProc) {
          tr(a0,
            td(style("width:20%;"), textNode(goProc.goProcessID)) +*
            td(style("width:70%;"), textNode(goProc.goProcessComment)) +*
            td(style("width:10%;"), textNode(goProc.goProcessEvidence)))
        }

        var goAnnotations = MvuHTML.concatMap(renderGoProcess, otherProcs);

        var toggleGoAnnotationsRow = {
          var clickAttr = onClick(fun() { ToggleShowIEA(proc.ipImmunoProcess.immunoProcessID) });
          var arrow = {
            var arrowClass = if (proc.ipShowIEA) { "arrow up" } else { "arrow" };
            div(class(arrowClass) +@ clickAttr, h0)
          };

          tr(a0,
            td(style("width:20%;"),
              a(title("Toggle GO associations with IEA evidence") +@ class("toggle"),
                arrow)) +*
            td(colSpan(2) +@ style("width:800%;font-style:italic;"),
                textNode("click arrow to show/hide IEA associations")))
        };

        var ieaAnnotations =
          if (proc.ipShowIEA) {
            MvuHTML.concatMap(renderGoProcess, ieaProcs)
          } else {
            MvuHTML.empty
          };

        tr(a0,
          td(class("info"),
            table_(class("inner_receptor_data_tables") +@ style("width:70%"),
              renderKeyVal(("Immuno Process",
                a(href("/immProcessList?immprocess=" ^^ intToString(iProc.immunoProcessID)),
                  textNode(iProc.immunoProcessName)))) +*
              goAnnotationsCountRow +*
              tr(a0,
                td(a0, h0) +*
                table_(id("go") +@ class("tablesorter inner_receptor_data_tables"),
                  goAnnotations +*
                  toggleGoAnnotationsRow +*
                  ieaAnnotations)))))
      }

      var procs = objectInfo.objectImmunoProcessAssociations;
      if (procs == []) {
        MvuHTML.empty
      } else {
        var renderedProcs = MvuHTML.concatMap(renderProcess, procs);
        a(name("Processes"), MvuHTML.empty) +*
        table_(class("receptor_data_tables fullwidth"),
          tr(name("hotspot") +@ class("hotspot"),
            td(class("info category"), textNode("Immuno Process Associations"))) +*
          renderedProcs)
      }
    };

    var associatedProteinsBox = {
      var oaps = objectInfo.objectAssociatedProteins;
      var comments = objectInfo.objectComments.associatedProteinsComments;

      if (not(markupEmpty(comments) &&
              listEmpty(oaps.hpfSubunits) &&
              listEmpty(oaps.auxiliarySubunits) &&
              listEmpty(oaps.otherProteins) &&
              listEmpty(oaps.gProteins) &&
              listEmpty(oaps.interactingProteins))) {

        var comments = commentsBox("Associated Protein Comments", comments);


        var renderedTables = {
          fun renderRowsIfNonempty(data, showEffect) {
            var cols = if (showEffect) { 3 } else { 2 };
            fun renderRow(ap) {
              var effect =
                if (showEffect) {
                  td(class("info"), renderM(ap.effect))
                } else {
                  MvuHTML.empty
                };

              var name =
                switch(ap.objectID) {
                  case Just(id) ->
                    a(href("/objectDisplay?objectId=" ^^ intToString(id)), renderM(ap.name))
                  case Nothing -> renderM(ap.name)
                };
              tr(a0,
                td(class("info"), name) +*
                effect +*
                td(class("info"), Reference.renderCitationList(ap.references, objectInfo.objectReferences)))
            }

            if (listEmpty(data)) {
              tr(a0,
                td(class("info") +@ colSpan(cols), textNode("Not determined")))
            } else {
              MvuHTML.concatMap(renderRow, data)
            }
          }

          fun renderICTable(title, alignment, data) {
            var renderedRows = renderRowsIfNonempty(data, false);
            td(align(alignment) +@ valign("top") +@ class("info"),
              table_(align("center") +@ class("receptor_data_tables")
                +@ style("margin:0px;min-width:100%;"),
                colgroup(a0,
                  col(style("min-width:50%"), h0) +*
                  col(style("min-width:50%"), h0)) +*
                thead(a0,
                  tr(a0,
                    td(class("info category") +@ colSpan(2), textNode(title)))) +*
                tbody(a0,
                  tr(a0,
                    td(class("info heading"), textNode("Name")) +*
                    td(class("info heading"), textNode("References"))) +*
                  renderedRows)))

          }
          var tables = {

            var isIC = switch (objectInfo.objectType) {
              case VGIC(_) -> true
              case LGIC(_) -> true
              case OtherIC(_) -> true
              case _ -> false
            };
            if (isIC) {
              # Render 3 specific IC tables
              renderICTable("Heteromeric Pore-forming Subunits", "left", oaps.hpfSubunits) +*
              renderICTable("Auxiliary Subunits", "center", oaps.auxiliarySubunits) +*
              renderICTable("Other Associated Proteins", "right", oaps.otherProteins)
            } else {
              # Render G Proteins and interacting proteins table
              var gProteinsTable =
                if (not(listEmpty(oaps.gProteins))) {
                  renderICTable("G Proteins", "right", oaps.gProteins)
                } else {
                  MvuHTML.empty
                };

              var interactingProteinsTable = {
                var renderedRows = renderRowsIfNonempty(oaps.interactingProteins, true);
                if (not(listEmpty(oaps.interactingProteins))) {
                  td(align("center") +@ valign("top") +@ class("info"),
                    table_(align("center") +@ class("receptor_data_tables")
                      +@ style("margin:0px;min-width:100%;"),
                      colgroup(a0,
                        col(style("min-width:35%"), h0) +*
                        col(style("min-width:35%"), h0) +*
                        col(style("min-width:30%"), h0)) +*
                      thead(a0,
                        tr(a0,
                          td(class("info category") +@ colSpan(3), textNode("Interacting Proteins")))) +*
                      tbody(a0,
                        tr(a0,
                          td(class("info heading"), textNode("Name")) +*
                          td(class("info heading"), textNode("Effect")) +*
                          td(class("info heading"), textNode("References"))) +*
                        renderedRows)))
                } else {
                  MvuHTML.empty
                }
              };

              gProteinsTable +* interactingProteinsTable
            }
          };

          tbody(name("toggle"),
            tr(valign("top"), tables))
          };
        a(name("AssociatedProteins"), MvuHTML.empty) +*
        table_(class("receptor_data_tables fullwidth"),
          colgroup(a0,
            col(style("min-width:280px;"), h0) +*
            col(style("min-width:280px;"), h0) +*
            col(style("min-width:280px;"), h0)) +*
          thead(a0,
            tr(a0,
              td(class("info category") +@ colSpan(3), textNode("Associated Proteins")))) +*
          renderedTables) +*
        comments
      } else {
        MvuHTML.empty
      }
    };

    var enzymeReactionsBox = {
      if (listEmpty(objectInfo.objectEnzymeReactions)) {
        MvuHTML.empty
      } else {
        fun renderRow(reaction) {
          var srs = reaction.specificReactions;

          var renderedSRs = {
            fun renderSR(sr) {
              tr(class("info"),
                td(a0, renderM(sr.description)) +*
                td(a0, renderM(sr.reaction)) +*
                td(a0, Reference.renderCitationList(sr.references, objectInfo.objectReferences)))
            }

            tr(class("info heading"),
              td(a0, textNode("Description")) +*
              td(a0, textNode("Reaction")) +*
              td(a0, textNode("Reference"))) +*
            MvuHTML.concatMap(renderSR, srs)
          };


          var rowspanAttr =
            if (listEmpty(srs)) {
              MvuAttrs.empty
            } else {
              rowSpan(length(srs) + 2)
            };

          var specificReactions =
            if (listEmpty(srs)) {
              MvuHTML.empty
            } else {
              renderedSRs
            };

          tr(class("info"),
            td(rowspanAttr,
              textNode("EC Number: ") +*
              a(href("http://www.genome.jp/dbget-bin/www_bget?ec:" ^^ reaction.ecNumber),
                textNode(reaction.ecNumber))) +*
            td(colSpan(3), renderM(reaction.reaction))) +*
            specificReactions
        }

        a(name("EnzymeReaction"), h0) +*
        table_(class("receptor_data_tables fullwidth"),
          thead(a0,
            tr(a0,
              td(class("info category"), textNode("Enzyme Reaction")))) +*
          tbody(a0,
            tr(a0,
              td(class("table_container"),
                table_(class("inner_receptor_data_tables"),
                  thead(a0, h0) +*
                  tbody(a0,
                    MvuHTML.concatMap(renderRow, objectInfo.objectEnzymeReactions)))))))
      }

    };

    var substratesBox = {
      var shouldDisplay =
        switch(objectInfo.objectType) {
          case Enzyme -> true
          case Transporter(_) -> true
          case _ -> false
        };
      if (shouldDisplay &&
          not(tableEmpty(objectInfo.objectSubstrates))) {
        fun renderRow(subs) {
          var nameCol =
            if (subs.ligandID > 0) {
              a(href("/objectDisplay?objectId=" ^^ intToString(subs.ligandID)),
                  renderM(subs.name))
            } else {
              renderM(subs.name)
            };
          var endoCol =
            if (subs.endogenous) {
              img(src("/images/endogenous.gif") +@
                  alt("Substrate is endogenous in the given species"), h0)
            } else {
              MvuHTML.empty
            };

          var standardValCol =
            if (subs.standardValue == 0.0) {
              MvuHTML.empty
            } else {
              textNode(floatToString(subs.standardValue))
            };

          tr(class("info"),
            td(a0, nameCol) +*
            td(a0, endoCol) +*
            td(style("text-align:center;"), textNode(subs.species)) +*
            td(a0, renderM(subs.property)) +*
            td(a0, textNode(floatToString(subs.value))) +*
            td(a0, renderM(subs.units)) +*
            td(a0, renderM(subs.standardProperty)) +*
            td(a0, standardValCol) +*
            td(a0, renderM(subs.assayDescription)) +*
            td(a0, renderM(subs.assayConditions)) +*
            td(a0, renderM(subs.comments)) +*
            td(a0, Reference.renderCitationList(subs.references, objectInfo.objectReferences)))
        }

        var renderedTable = renderTable(objectInfo.objectSubstrates, renderRow);

        a(name("SubstrateKinetics"), h0) +*
        table_(class("receptor_data_tables fullwidth"),
          thead(a0,
            tr(a0,
              td(class("info category"), textNode("Substrates and Reaction Kinetics")))) +*
          tbody(a0,
            tr(a0,
              td(class("table_container"), renderedTable))))
      } else {
        MvuHTML.empty
      }
    };

    var productsBox = {
      fun renderRow(p) {
        var renderedName =
          if (p.ligandID == (-1)) {
            renderM(p.name)
          } else {
            a(href("/ligandDisplay?ligandId=" ^^ intToString(p.ligandID)), renderM(p.name))
          };

        var endogImg =
          if (p.endogenous) {
            img(src("/images/endogenous.gif"), h0)
          } else {
            MvuHTML.empty
          };
        tr(class("info"),
          td(style("border-style: solid dotted solid solid;"),
            renderedName) +*
          td(style("border-style: solid solid solid dotted;padding:1px;width:20px;text-align:center;"),
            endogImg) +*
          td(a0, textNode(p.speciesName)) +*
          td(a0, Reference.renderCitationList(p.references, objectInfo.objectReferences)))
      }

      if (listEmpty(objectInfo.objectProducts)) {
        MvuHTML.empty
      } else {
        var renderedRows =
          MvuHTML.concatMap(renderRow, objectInfo.objectProducts);

        a(name("Products"), h0) +*
        table_(class("receptor_data_tables fullwidth"),
          thead(a0,
            tr(a0,
              td(class("info category"), textNode("Products")))) +*
          tbody(a0,
            tr(a0,
              td(class("table_container"),
                table_(id("products") +@ class("tablesorter inner_receptor_data_tables"),
                  thead(a0,
                    tr(class("info heading"),
                      th(class("substrate_header header") +@ colSpan(2), textNode("Product")) +*
                      th(class("units_header header"), textNode("Species")) +*
                      th(class("reference_header header"), textNode("References")))) +*
                  tbody(a0, renderedRows))))))
      }
    };

    var cofactorsBox = {
      if (tableEmpty(objectInfo.objectCofactors)) {
        MvuHTML.empty
      } else {
        sig renderRow : (Cofactor) ~%~> HTML(Message)
        fun renderRow(c) {
          var renderedName =
            if (c.ligandID == (-1)) {
              renderM(c.name)
            } else {
              a(href("/ligandDisplay?ligandId=" ^^ intToString(c.ligandID)), renderM(c.name))
            };
          tr(class("info"),
            td(a0, renderedName) +*
            td(a0, textNode(c.speciesName)) +*
            td(a0, renderM(c.comments)) +*
            td(a0, Reference.renderCitationList(c.references, objectInfo.objectReferences)))
        }

        a(name("Cofactors"), h0) +*
        table_(class("receptor_data_tables fullwidth"),
          thead(a0,
            tr(a0,
              td(class("info category"), textNode("Cofactors")))) +*
          tbody(a0,
            tr(a0,
              td(class("table_container"),
                renderTable(objectInfo.objectCofactors, renderRow)))))
      }
    };

    var stoichiometryBox =
      switch(objectInfo.objectType) {
        case Transporter(t) ->
          commentsBox("Stoichiometry", t.stoichiometry)
        case _ -> MvuHTML.empty
      };

    var fcsBox =
      commentsBox("Functional Characteristics",
          objectInfo.objectComments.functionalCharacteristicsComments);

    var selectivityBox = {
      fun nonempty(x) { not(listEmpty(x)) }
      var si = objectInfo.objectSelectivityInfo;
      if (nonempty(si.summaries) || nonempty(si.singleChannelConductance) ||
          nonempty(si.singleChannelCurrentRectification) ||
          nonempty(si.macroscopicCurrentRectification) ||
          not(markupEmpty(si.selectivityComments))) {


          fun renderSummary(x) {
            tr(a0,
              td(class("info"),
                table_(class("inner_receptor_data_tables"),
                  renderKeyVal(("Species", textNode(x.speciesName))) +*
                  renderKeyVal(("Rank order", textNode(x.rankOrder))) +*
                  renderKeyVal(("References", renderCitations(x.references))))))
          }

          fun renderConductanceInfo(dataKey, data) {
            if (not(listEmpty(data))) {
              var colStyle = "width:120px;padding:0px 20px 0px 0px;vertical-align:top;";

              var speciesCols =
                MvuHTML.concatMap(fun(x) {
                    td(style(colStyle), textNode(x.speciesName)) }, data);

              var dataCols =
                MvuHTML.concatMap(fun(x) {
                    td(style(colStyle), renderM(x.data)) }, data);

              var refsCols =
                MvuHTML.concatMap(fun(x) {
                    td(style(colStyle), renderCitations(x.references)) }, data);

              tr(a0,
                td(class("info"),
                  table_(class("inner_receptor_data_tables"),
                    renderKeyVal(("Species", speciesCols)) +*
                    renderKeyVal((dataKey, dataCols)) +*
                    renderKeyVal(("References", refsCols)))))
            } else {
              MvuHTML.empty
            }
          }

          var selectivitySummaries = MvuHTML.concatMap(renderSummary, si.summaries);
          var singleChannelConductance =
            renderConductanceInfo("Single channel conductance (pS)",
                si.singleChannelConductance);

          var singleChannelRectification =
            renderConductanceInfo("Single channel current rectification",
                si.singleChannelCurrentRectification);

          var macroscopicRectification =
            renderConductanceInfo("Macroscopic current rectification",
                si.singleChannelConductance);

          var dataTables = {
            if (nonempty(si.summaries) || nonempty(si.singleChannelConductance) ||
                nonempty(si.singleChannelCurrentRectification) ||
                nonempty(si.macroscopicCurrentRectification)) {
              table_(class("receptor_data_tables fullwidth"),
                thead(a0,
                  tr(a0,
                    td(class("info category"), textNode("Ion Selectivity and Conductance")))) +*
                tbody(a0,
                  selectivitySummaries +*
                  singleChannelConductance +*
                  singleChannelRectification +*
                  macroscopicRectification))
            } else {
              MvuHTML.empty
            }
          };

          a(name("IonSelectivity"), h0) +*
          dataTables +*
          commentsBox("Ion Selectivity and Conductance Comments", si.selectivityComments)

      } else {
        MvuHTML.empty
      }
    };


    var voltageDependenceBox = {
      if (not(listEmpty(objectInfo.objectVoltageDependence))) {
        fun renderVD(vd) {
          var header =
            thead(a0,
              tr(class("info heading"),
                th(a0, h0) +*
                th(width("16%"), unescapedTextNode("V<sub>0.5</sub> (mV)")) +*
                th(width("16%"), unescapedTextNode("&tau; (msec)")) +*
                th(width("16%"), textNode("References")) +*
                th(width("16%"), textNode("Cell type")) +*
                th(width("16%"), textNode("Species"))));

          fun emptyThreeValRange(r) {
            r.low == 0.0 && r.median == 0.0 && r.high == 0.0
          }
          fun emptyTwoValRange(r) {
            r.low == 0.0 && r.high == 0.0
          }

          var deact = vd.deactivationRange;

          var displayDeactivation =
            not(emptyThreeValRange(deact.vRange) && emptyTwoValRange(deact.tRange));

          var rowCount = if (displayDeactivation) { 3 } else { 2 };

          var activationRow =
            tr(class("info"),
              td(style("font-weight:bold;"), textNode("Activation")) +*
              td(a0, renderThreeValRange(vd.activationRange.vRange)) +*
              td(a0, renderTwoValRange(vd.activationRange.tRange)) +*
              td(a0, renderCitations(vd.activationRange.refs)) +*
              td(rowSpan(rowCount), textNode(vd.cellType)) +*
              td(rowSpan(rowCount), textNode(speciesLongName(vd.speciesID))));

          var inactivationRow =
            tr(class("info"),
              td(style("font-weight:bold;"), textNode("Inactivation")) +*
              td(a0, renderThreeValRange(vd.inactivationRange.vRange)) +*
              td(a0, renderTwoValRange(vd.inactivationRange.tRange)) +*
              td(a0, renderCitations(vd.inactivationRange.refs)));

          var deactivationRow =
            if (displayDeactivation) {
              tr(class("info"),
                td(style("font-weight:bold;"), textNode("Inactivation")) +*
                td(a0, renderThreeValRange(vd.deactivationRange.vRange)) +*
                td(a0, renderTwoValRange(vd.deactivationRange.tRange)) +*
                td(a0, renderCitations(vd.deactivationRange.refs)))
            } else {
              MvuHTML.empty
            };


          var comments =
            if (not(markupEmpty(vd.comments))) {
              tr(class("info"),
                td(style("font-weight:bold;"), textNode("Comments")) +*
                td(colSpan(5), renderM(vd.comments)))
            } else {
              MvuHTML.empty
            };

          var content =
            tbody(a0,
              activationRow +* inactivationRow +* deactivationRow +* comments
            );

          tr(a0,
            td(class("table_container"),
              table_(class("receptor_data_tables") +@ width("98%"),
                header +* content)))
        }

        var renderedVDs =
          MvuHTML.concatMap(renderVD, objectInfo.objectVoltageDependence);

        dataBox("Voltage Dependence", 1, renderedVDs)
      } else {
        MvuHTML.empty
      }
    };

    var voltageDependenceCommentsBox = {
      switch(objectInfo.objectType) {
        case VGIC(info) ->
          commentsBox("Voltage Dependence Comments", info.voltageDependenceComments)
        case _ -> MvuHTML.empty
      }
    };

    var conductanceStatesBox = {
      fun renderRange(r) {
        var val = renderTwoValRange(r);
        var star = if (r.mostFrequent) { "*" } else { "" };
        val +* textNode(star)
      }

      if (not(listEmpty(objectInfo.objectConductanceStates))) {
        fun renderRow(state) {
          tr(class("info"),
            td(a0, unescapedTextNode(state.receptor)) +*
            td(a0, renderRange(state.state1)) +*
            td(a0, renderRange(state.state2)) +*
            td(a0, renderRange(state.state3)) +*
            td(a0, renderRange(state.state4)) +*
            td(a0, renderRange(state.state5)) +*
            td(a0, renderRange(state.state6)) +*
            td(a0, renderCitations(state.references)))
        }

        var renderedRows =
          MvuHTML.concatMap(renderRow, objectInfo.objectConductanceStates);

        var conductanceTable =
          table_(class("receptor_data_tables"),
            thead(a0,
              tr(class("info heading"),
                th(class("conductance_receptor_header") +@ rowSpan(2), textNode("Recombinant receptor")) +*
                th(colSpan(6), textNode("Conductance states (pS)")) +*
                th(class("conductance_reference_header") +@ rowSpan(2), textNode("Reference"))) +*
              tr(class("info heading"),
                th(class("conductance_state_header"), textNode("I")) +*
                th(class("conductance_state_header"), textNode("II")) +*
                th(class("conductance_state_header"), textNode("III")) +*
                th(class("conductance_state_header"), textNode("IV")) +*
                th(class("conductance_state_header"), textNode("V")) +*
                th(class("conductance_state_header"), textNode("VI")))) +*
            tbody(a0,
              renderedRows +*
              tr(class("info"),
                td(style("text-align:center;") +@ colSpan(8),
                  textNode("* the most frequently occurring conductance states")))));

        a(name("ConductanceStates"), h0) +*
        table_(class("receptor_data_tables fullwidth"),
          thead(a0,
            tr(name("hotspot") +@ class("hotspot"),
              td(class("info category"), textNode("Single Channel Conductance of Recombinant Receptors")))) +*
          tbody(name("toggle"),
            tr(a0,
              td(class("table_container"), conductanceTable))))
      } else {
        MvuHTML.empty
      }
    };

    var dataBoxes =
      div(class("grid_16 alpha"),
        div(class("contentboxfullhelp"),
          div(class("data_tables_container"),
            qsBox +*
            geneProteinInfoBox +*
            synonymsBox +*
            dbLinksBox +*
            pdbStructureBox +*
            # Primary regulator data does not exist in the DB -- no point implementing
            enzymeReactionsBox +*
            associatedProteinsBox +*
            substratesBox +*
            productsBox +*
            cofactorsBox +*
            stoichiometryBox +*
            fcsBox +*
            selectivityBox +*
            voltageDependenceBox +*
            voltageDependenceCommentsBox +*
            conductanceStatesBox +*
            endogenousLigandsBox +*
            potencyOrderBox +*
            interactionsTables +*
            screens +*
            immunoCommentsBox +*
            malariaCommentsBox +*
            cellTypeAssociationsBox +*
            immunoProcessAssociationsBox +*
            transductionMechanismsBoxes +*
            coregulatorsBox +*
            bindingPartnersBox +*
            targetGenesBox +*
            dnaBindingsBox +*
            dnaComments +*
            tissueDistributionBox +*
            expressionDatasetsBox +*
            functionalAssaysBox +*
            physiologicalFunctionsBox +*
            physiologicalConsequencesBox +*
            phenotypesBox +*
            xenobioticsBox +*
            expressionPathophysiologyBox +*
            expressionPathophysiologyComments +*
            generalCommentsBox)));

    var referencesBox =
      Reference.renderReferencesBox(
          objectInfo.objectShowReferences,
          objectInfo.objectReferences,
          fun() { ToggleReferences });

    var contributorsBox =
      ToggleBox.showBox(objectInfo.objectContributors, ToggleContributors,
        Contributor.renderContributors);

    div(class("grid_12"),
        infoBox +*
        dataBoxes +*
        referencesBox +*
        contributorsBox)
  }

  switch(model) {
    case Just(objectInfo) -> viewModel(objectInfo)
    case Nothing -> textNode("Invalid object ID.")
  }
}

sig updt : (Message, Model) ~%~> (Model, Command(Message))
fun updt(msg, model) {
  fun updtOI(objectInfo) {

    fun toggleIEA(procID) {
      var ipas = objectInfo.objectImmunoProcessAssociations;
      map(fun(x) { if (x.ipImmunoProcess.immunoProcessID == procID) {
            (x with ipShowIEA = not(x.ipShowIEA))
          } else {
            x
          }
        }, ipas)
    }

    fun noCmd(updated) { (updated, MvuCommands.empty) }

    switch(msg) {
      case NoOp -> noCmd(objectInfo)
      case ToggleReferences ->
        noCmd(
          (objectInfo with
            objectShowReferences=not(objectInfo.objectShowReferences)))
      case ToggleContributors ->
        noCmd(
          (objectInfo with
            objectContributors = toggleBox(objectInfo.objectContributors)))
      case ToggleShowIEA(procID) ->
        noCmd(
          (objectInfo with
            objectImmunoProcessAssociations=toggleIEA(procID)))
      case ShowCharts ->
        if (not(objectInfo.chartsShown)) {
          # renderChart : (GeneExpression, String) ~> ();
          var (_, cmds) =
            fold_left(fun((i, cmds), x) {
                var cmd = MvuCommands.spawnProc(fun() {
                  HighchartsWrapper.renderChart(x, "chart" ^^ intToString(i));
                  NoOp
                });
                (i + 1, cmds +$ cmd)
            }, (0, MvuCommands.empty), objectInfo.objectGeneExpression);

          ((objectInfo with chartsShown = true), cmds)
        } else {
          noCmd(objectInfo)
        }
      case SortTable(tableTy, colName, dir) ->
        var osi = objectInfo.objectSortedInteractions;
        fun updateOSI(newOSI) {
          noCmd((objectInfo with objectSortedInteractions = newOSI))
        }

        switch(tableTy) {
          case AgonistsTable ->
            updateOSI((osi with agonists = DataTable.updateSortStatus(osi.agonists, colName, dir)))
          case AntagonistsTable ->
            updateOSI(
              (osi with antagonists = DataTable.updateSortStatus(osi.antagonists, colName, dir)))
          case AllostericModulatorsTable ->
            updateOSI(
              (osi with allostericModulators =
                 DataTable.updateSortStatus(osi.allostericModulators, colName, dir)))
          case ActivatorsTable ->
            updateOSI(
              (osi with activators = DataTable.updateSortStatus(osi.activators, colName, dir)))
          case InhibitorsTable ->
            updateOSI(
              (osi with inhibitors = DataTable.updateSortStatus(osi.inhibitors, colName, dir)))
          case ChannelBlockersTable ->
            updateOSI(
              (osi with channelBlockers =
                 DataTable.updateSortStatus(osi.channelBlockers, colName, dir)))
          case GatingInhibitorsTable ->
            updateOSI(
              (osi with gatingInhibitors =
                 DataTable.updateSortStatus(osi.gatingInhibitors, colName, dir)))
          case SubunitSpecificTable ->
            updateOSI(
              (osi with subunitSpecific =
                 DataTable.updateSortStatus(osi.subunitSpecific, colName, dir)))
          case WholeOrganismAssaysTable ->
            updateOSI(
              (osi with wholeOrganismAssays =
                 DataTable.updateSortStatus(osi.wholeOrganismAssays, colName, dir)))
          case AntibodiesTable ->
            updateOSI(
              (osi with antibodies =
                 DataTable.updateSortStatus(osi.antibodies, colName, dir)))
          case OtherBindingLigandTable ->
            updateOSI(
              (osi with other =
                 DataTable.updateSortStatus(osi.other, colName, dir)))
          case SubstratesTable ->
            noCmd((objectInfo with objectSubstrates =
              DataTable.updateSortStatus(objectInfo.objectSubstrates, colName, dir)))
          case CofactorsTable ->
            noCmd((objectInfo with objectCofactors =
              DataTable.updateSortStatus(objectInfo.objectCofactors, colName, dir)))

        }

      case SortScreenTable(screenID, tblName, colName, dir) ->
        fun sortInnerTable(screens) {
          map(fun((name, tbl)) {
              if (name == tblName) {
                (name, DataTable.updateSortStatus(tbl, colName, dir))
              } else {
                (name, tbl)
              }
          }, screens)
        }

        var screens =
          map(fun(x) {
                if (x.id == screenID) {
                  (x with data = sortInnerTable(x.data))
                } else {
                  x
                }
              }, objectInfo.objectScreens);
        noCmd((objectInfo with objectScreens = screens))

      case _ -> noCmd(objectInfo)
    }
  }

  switch(model) {
    case Just(objectInfo) ->
      var (oi, cmds) = updtOI(objectInfo);
      (Just(oi), cmds)
    case Nothing -> (Nothing, MvuCommands.empty)
  }
}

fun mainPage() {
  var initialModel = getInitialModel();
  run("vdom_placeholder", initialModel, view, updt,
      fun(_) { SubEmpty }, MvuCommands.empty);
  template("Object Display")
}
