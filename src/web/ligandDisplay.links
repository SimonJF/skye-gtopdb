open import Ligand;
open import Mvu;
open import Reference;
open import Parser;
open import RenderMarkup;
open import Utility;
open import Template;
open import Species;
open import DataTable;
open import InteractionUtilities;
open import DbLinks;

import MvuHTML;
import MvuAttrs;

typename Tab =
  [| Summary | BiologicalActivity | ClinicalData | References
   | Structure | SimilarLigands | Analogues | Malaria | Immuno |];


typename Message =
  [| ChangeTab:Tab | SortPrecursorTable:(ColumnName, SortDirection)
   | SortInteractionTable:(InteractionTargetType, ColumnName, SortDirection)
   | SortCofactorTable:(ColumnName, SortDirection)
   | NoOp
  |];

typename ApprovalSource = String;
typename LigandApproval = [| Approved:ApprovalSource | NotApproved |];

typename INN = (innNumber: Int, inn: String);

typename Synonym = (synonymName: Markup, synonymRefs: [ReferenceID]);

typename LigandFamily = (familyName: String, familyId: Int);

typename ClusteredLigand = (id: Int, name: String, targets: [(id: Int, name: String)]);

typename LigandClusters =
  (clusters: [ClusteredLigand],
   oldClusterCount: Int, # Needed to replicate a GtoPdb bug -- will report
   analogue_clusters: [ClusteredLigand],
   peptide_ligand_clusters: [ClusteredLigand],
   peptide_ligand_sequence_clusters: [ClusteredLigand],
   peptide_related_ligands: [ClusteredLigand]
  );

typename LigandPhysicalProperties = (
  lpHydrogenBondAcceptors: Int,
  lpHydrogenBondDonors: Int,
  lpRotatableBonds: Int,
  lpTopologicalPolarSurfaceArea: Float,
  lpMolecularWeight: Float,
  lpXLogP: Float,
  lpLipinskiRules: Int
);

typename Comments = (
  generalComments: Markup,
  clinicalUseComments: Markup,
  mechanismOfActionComments: Markup,
  absorptionDistributionComments: Markup,
  metabolismComments: Markup,
  eliminationComments: Markup,
  popnPharmacokineticsComments: Markup,
  organFunctionImpairmentComments: Markup,
  bioactivityComments: Markup,
  immunoComments: Markup,
  malariaComments: Markup
);

typename EnzymeSubstrate = (
  enzyme: String,
  enzymeID: Int,
  ecNumber: String,
  reaction: String,
  references: [ReferenceID]
);

typename CofactorEnzyme = (
  enzyme: Markup,
  enzymeID: Int,
  references: [ReferenceID]
);

typename TransporterSubstrate = (
  transporter: String,
  transporterID: Int,
  ecNumber: String,
  reaction: String,
  references: [ReferenceID]
);

typename InteractionInfo = (
  interaction: Interaction,
  renderedName: Markup,
  renderedActionComment: Markup,
  renderedAssayDescription: Markup,
  speciesShort: String
);

typename BioactivityTables = (
  # Special tables
  enzymeSubstrates: SortableTable(EnzymeSubstrate, Message),
  cofactorEnzymes: SortableTable(CofactorEnzyme, Message),
  transporterSubstrates: SortableTable(TransporterSubstrate, Message),
  wholeOrganismAssays: SortableTable(InteractionInfo, Message),
  # Sorted interactions with different targets
  gpcrInteractions: SortableTable(InteractionInfo, Message),
  icInteractions: SortableTable(InteractionInfo, Message),
  nhrInteractions: SortableTable(InteractionInfo, Message),
  enzymeInteractions: SortableTable(InteractionInfo, Message),
  catalyticReceptorInteractions: SortableTable(InteractionInfo, Message),
  transporterInteractions: SortableTable(InteractionInfo, Message),
  targetLigandInteractions: SortableTable(InteractionInfo, Message),
  interactionsTargeting: SortableTable(InteractionInfo, Message),
  otherInteractions: SortableTable(InteractionInfo, Message)
);

typename LigandStructure = (
  canonicalSmiles: String,
  isomericSmiles: String,
  inchiStandardID: String,
  inchiStandardKey: String
);

typename LigandURLs = (
  drugsURL: String,
  emaURL: String,
  emcURL: String
);

typename Subunit = (Int, Markup);
typename Heteromer = (Int, Markup);

typename PeptideInfo = (
  peptideOneLetterSeq: String,
  peptideThreeLetterSeq: String,
  peptidePostTranslationalModifications: Markup,
  peptideChemicalModifications: Markup,
  peptideMedicalRelevance: Markup
);

typename PrecursorInfo = (
  precursorID: Int,
  precursorGeneName: String,
  precursorOfficialGeneID: String,
  precursorProteinName: String,
  precursorSpecies: String,
  precursorGeneLongName: String,
  precursorSynonyms: [String]
);

typename ImmunoDiseaseInfo = (
  immunoDiseaseID: Int,
  immunoDiseaseName: String,
  immunoDiseaseXRefs: [(dbName: String, displayID: String, url: String)],
  immunoDiseaseComments: Markup,
  immunoDiseaseReferences: [ReferenceID]
);

typename MalariaTargetProfile = (
  tcpID: Int,
  tcpProfile: Markup,
  tcpIntendedUse: Markup,
  tcpTargetStage: Markup,
  tcpComment: Markup,
  tcpReferences: [ReferenceID]
);

typename RankPotency = (
  description: Markup,
  data: Markup,
  objectID: Int,
  objectName: String,
  references: [ReferenceID]
);

typename MentionedIn = (
  overviews: [(familyID: Int, familyName: String)],
  comments: [(familyID: Int, familyName: String)]
);

typename MentionedInObject = (
  objectID: Int,
  objectName: String,
  families: [(familyID: Int, familyName: String)],
  comment: Markup
);

typename LigandInfo = (
  ligandID: Int,
  rawLigand: Tables.RawLigand, # TODO: A lot of the properties below are duplicated -- just use this instead.
  ligandType: String,
  ligandPeptideInfo: Maybe(PeptideInfo),
  ligandPrecursorTable: SortableTable(PrecursorInfo, Message),
  ligandName: Markup,
  ligandFamilies: [LigandFamily],
  ligandPhysicalProperties: Maybe(LigandPhysicalProperties),
  ligandSubunits: [Subunit],
  ligandHeteromers: [Subunit],
  ligandApproval: LigandApproval,
  ligandWithdrawn: Bool,
  ligandIUPACName: String,
  ligandINNs: [INN],
  ligandSynonyms: [Synonym],
  ligandComments: Comments,
  ligandURLs: LigandURLs,
  ligandDBLinks: [DatabaseLink],
  ligandBioactivityTables: BioactivityTables,
  ligandReferences: [(ReferenceId, (ReferenceNumber, Reference))],
  ligandStructure: Maybe(LigandStructure),
  ligandImmuno: Bool,
  ligandMalaria: Bool,
  ligandImmunoDiseases: [ImmunoDiseaseInfo],
  ligandImmunopaediaCases: [(title: String, url: String)],
  ligandProdrugs: [(id: Int, name: String)],
  ligandActiveForms: [(id: Int, name: String)],
  ligandEndogenousTargets: [(id: Int, name: String)],
  ligandLigandRefs: [(Int, LigandName)],
  ligandClusters: LigandClusters,
  ligandRankPotencies: [RankPotency],
  ligandTCPs: [MalariaTargetProfile],
  ligandMentionedIn: MentionedIn,
  ligandMentionedInObjects: [MentionedInObject]
);

typename Model = Maybe((
  modelTab:Tab,
  modelLigand: LigandInfo,
  modelSpeciesMap: SpeciesMap
));


sig getInitialModel : () {}~> Model
fun getInitialModel() {

  sig getLigandInfo : (Int, SpeciesMap) {}~> Maybe(LigandInfo)
  fun getLigandInfo(ligandId, speciesMap) {
    fun speciesShortName(speciesID) { resolveSpeciesShortName(speciesID, speciesMap) }
    fun speciesLongName(speciesID) { resolveSpeciesLongName(speciesID, speciesMap) }
    fun transformLigandInfo(rawInfo) {
      var rawLigand = rawInfo.ligand;
      fun transformPhysicalProperties(rawProps) {
        switch(rawProps) {
          case [] -> Nothing
          case rawProps :: _ ->
            Just(
            (lpHydrogenBondAcceptors = rawProps.hydrogen_bond_acceptors,
             lpHydrogenBondDonors = rawProps.hydrogen_bond_donors,
             lpRotatableBonds = rawProps.rotatable_bonds_count,
             lpTopologicalPolarSurfaceArea = rawProps.topological_polar_surface_area,
             lpMolecularWeight = rawProps.molecular_weight,
             lpXLogP = rawProps.xlogp,
             lpLipinskiRules = rawProps.lipinski_s_rule_of_five))
        }
      }

      var approval =
        if (rawInfo.ligand.approved) {
          Approved(rawLigand.approved_source)
        } else {
          NotApproved
        };

      fun transformFamilies(fs) {
        map(fun(f) { (familyId = f.family_id, familyName = f.name) }, fs)
      }

      fun transformSynonyms(ss) {
        fold_right(fun(x, acc) {
            if (x.l2s.display) {
              (synonymName = parseOrError(x.l2s.synonym), synonymRefs = x.refs) :: acc
            } else {
              acc
            }
        }, [], ss)
      }

      fun transformInns(inns) {
        map(fun(inn) { (innNumber = inn.inn_number, inn = inn.inn) }, inns)
      }

      fun transformComments(l) {
        var parsed =
         (generalComments = parseOrError(l.comments),
          clinicalUseComments = parseOrError(l.clinical_use),
          mechanismOfActionComments = parseOrError(l.mechanism_of_action),
          absorptionDistributionComments = parseOrError(l.absorption_distribution),
          metabolismComments = parseOrError(l.metabolism),
          eliminationComments = parseOrError(l.elimination),
          popnPharmacokineticsComments = parseOrError(l.popn_pharmacokinetics),
          organFunctionImpairmentComments = parseOrError(l.organ_function_impairment),
          bioactivityComments = parseOrError(l.bioactivity_comments),
          immunoComments = parseOrError(l.immuno_comments),
          malariaComments = parseOrError(l.gtmp_comments));

        var (refs, ligands) =
          RenderMarkup.collectAllIds([
          parsed.generalComments,
          parsed.clinicalUseComments, parsed.mechanismOfActionComments,
          parsed.absorptionDistributionComments, parsed.metabolismComments,
          parsed.eliminationComments, parsed.popnPharmacokineticsComments,
          parsed.organFunctionImpairmentComments, parsed.bioactivityComments,
          parsed.immunoComments, parsed.malariaComments]);
        (parsed, refs, ligands)
      }

      var (comments, commentRefs, commentLigands) =
        transformComments(rawLigand);

      sig transformSubunits : ([(Int, String)]) ~%~> [Subunit]
      fun transformSubunits(ss) {
        map(fun ((id, name)) { (id, parseOrError(name)) }, ss)
      }

      fun transformStructure(structs) {
        switch(structs) {
          case [] -> Nothing
          case x :: _ ->
            Just((canonicalSmiles = x.nonisomeric_smiles,
             isomericSmiles = x.isomeric_smiles,
             inchiStandardID = x.nonisomeric_standard_inchi,
             inchiStandardKey = x.nonisomeric_standard_inchi_key))
        }
      }

      fun transformPeptideInfo(ps) {
        switch(ps) {
          case [] -> (Nothing, [], [])
          case p :: _ ->
            var res =
              (peptideOneLetterSeq = p.one_letter_seq,
               peptideThreeLetterSeq = p.three_letter_seq,
               peptidePostTranslationalModifications =
                 parseOrError(p.post_translational_modifications),
               peptideChemicalModifications =
                 parseOrError(p.chemical_modifications),
               peptideMedicalRelevance =
                 parseOrError(p.medical_relevance));
            var (refs, ligands) =
              collectAllIds([
                res.peptidePostTranslationalModifications,
                res.peptideChemicalModifications,
                res.peptideMedicalRelevance]);
            (Just(res), refs, ligands)
        }
      }

      var (peptideInfo, peptideRefs, peptideLigands) =
        transformPeptideInfo(rawInfo.peptide);

      var urls = (
        drugsURL = rawLigand.drugs_url,
        emcURL = rawLigand.emc_url,
        emaURL = rawLigand.ema_url
      );

      fun transformPrecursors(rawPrecursors) {
        map(fun(p) {
          var precursor = p.precursor;
          var synonyms = p.synonyms;
          (precursorID = precursor.precursor_id,
           precursorGeneName = precursor.gene_name,
           precursorOfficialGeneID = precursor.official_gene_id,
           precursorProteinName = precursor.protein_name,
           precursorSpecies = speciesShortName(precursor.species_id),
           precursorGeneLongName = precursor.gene_long_name,
           precursorSynonyms = synonyms)
        }, rawPrecursors)
      }

      fun transformImmunoDiseases(ids) {
        fun transformXRef(dbLink) {
          (dbName = dbLink.db.name,
           displayID = dbLink.ddl.placeholder,
           url = replacePlaceholder(dbLink.db.url, dbLink.ddl.placeholder))
        }
        fold_right(fun(id, (acc, refs, ligands)) {
          var markup = parseOrError(id.comment);
          var (cRefs, cLigands) = collectIds(markup);
          var res =
            (immunoDiseaseID = id.disease.disease_id,
             immunoDiseaseName = id.disease.name,
             immunoDiseaseComments = markup,
             immunoDiseaseXRefs = map(transformXRef, id.dbLinks),
             immunoDiseaseReferences = id.refs);
          (res :: acc, cRefs ++ id.refs ++ refs, cLigands ++ ligands)
        }, ([], [], []), ids)
      }

      fun transformClusters() {
        # Since we don't have subqueries, we need to do things in two steps
        fun getClusteredLigands(cluster_tbl, clusters, current_ids) {
          var clusterPred = contains(clusters);
          var idsPred = contains(current_ids);
          query nested {
            for (c <-- cluster_tbl)
              where (clusterPred(c.cluster))
              for (l <-- Tables.ligand)
                where (l.ligand_id == c.ligand_id &&
                       l.ligand_id <> ligandId &&
                       not(idsPred(l.ligand_id)))
                [(id = l.ligand_id, name = l.name,
                  targets =
                    for (i <-- Tables.interaction)
                    where (i.ligand_id == l.ligand_id)
                      for (o <-- Tables.object)
                      where (o.object_id == i.object_id)
                      [(id = o.object_id, name = o.name)]
                    )]
          }
        }

        var peptideRelated = {
          var sameName = rawInfo.related_ligands;

          # For each precursor, get all ligand IDs s.t. the ligand ID is different, and the gene name is the same as that contained in the peptide

          # In other words, collect all the gene names and we can go from there
          # This isn't quite right, since equality is too strong: we require
          # case-sensitive equality (i.e., ilike). It's a reasonable approximation though.
          # Update: Given the patch to use ILIKE in general when compiling regex
          # queries, rather than LIKE, this should hopefully be fixed
          var geneNames =
            listConcatMap(fun(p) {
                var gene = p.precursor.gene_name;
                if (gene <> "") {
                  [gene]
                } else {
                  []
                }
              }, rawInfo.precursors);
          #print("Gene Names: " ^^ show(geneNames));
          var pred = containsRegex(geneNames);
          var idsPred = contains(map(fun(x) { x.id }, sameName));
          var geneSimilar =
            query nested {
              for (p2p <-- Tables.precursor2peptide)
                where (p2p.ligand_id <> ligandId)
                for (p <-- Tables.precursor)
                  where (p2p.precursor_id == p.precursor_id && p.gene_name <> "" && pred(p.gene_name))
                  for (l <-- Tables.ligand)
                    where (l.ligand_id == p2p.ligand_id && not(idsPred(l.ligand_id)))
                    [ (id = p2p.ligand_id, name = l.name,
                        targets =
                          for (i <-- Tables.interaction)
                          where (i.ligand_id == l.ligand_id)
                            for (o <-- Tables.object)
                            where (o.object_id == i.object_id)
                              [(id = o.object_id, name = o.name)])  ]
            };
          #print("geneSimilar: " ^^ show(geneSimilar));

          uniquify(sameName ++ geneSimilar)
        };

        # Analogue clusters are handled separately.
        var analogue_clusters =
          getClusteredLigands(Tables.analogue_cluster, rawInfo.analogue_clusters, []);

        var related_ids = map(fun(x) { x.id }, peptideRelated);

        # Three categories: Related sequences, Other similar sequences, structurally similar.
        # Related: related
        # Other similar: peptide ligand sequence clusters
        # Structurally similar: clusters ++ peptide ligand clusters.

        # First: getRelatedLigands() -- which we've done already. No impact on others.
        # Second: getSeqClusterForPeptideLigand() -- peptide_ligand_sequence_cluster.
        # Do not add if in related ligands.
        var peptide_ligand_sequence_clusters =
          getClusteredLigands(Tables.peptide_ligand_sequence_cluster,
              rawInfo.peptide_ligand_sequence_clusters, related_ids);

        # Third: getClusterForPeptideLigand. peptide_ligand_cluster.
        # Also add anything that's in getClusterForNonPeptideLigand.
        var peptide_ligand_clusters =
          getClusteredLigands(Tables.peptide_ligand_cluster,
              rawInfo.peptide_ligand_clusters, []);

        var clusters =
          getClusteredLigands(Tables.ligand_cluster_new, rawInfo.clusters, []);

        var old_clusters =
          getClusteredLigands(Tables.ligand_cluster, rawInfo.old_clusters, []);

        (=clusters,
         oldClusterCount = length(old_clusters),
         =analogue_clusters,
         =peptide_ligand_clusters,
         =peptide_ligand_sequence_clusters,
         peptide_related_ligands = peptideRelated )
      }

      var clusteredLigands = transformClusters();
      #print("Clustered Ligands: " ^^ show(clusteredLigands));

      var (immunoDiseases, immunoDiseaseRefs, immunoDiseaseLigands) =
        transformImmunoDiseases(rawInfo.immunoDiseases);

      var (transformedCofactors, cofactorRefs) =
        fold_right(fun(c, (cfs, refs)) {
            var cf =
              (enzyme = parseOrError(c.name),
               enzymeID = c.objectID, references = c.refs);
            (cf :: cfs, c.refs ++ refs)
        }, ([], []), rawInfo.cofactors);

      # Transform raw interactions into more structured form
      var interactions : [Interaction] =
        map(makeInteraction, rawInfo.interactions);
      # Targeting interactions, too.
      var interactionsTargeting =
        map(makeInteraction, rawInfo.interactions_targeting);


      # Augment with the data we need to parse
      fun augmentInteractions(is) {
        map(fun(i) {
            (interaction = i,
             renderedName = parseOrError(getTargetName(i.interactionTarget)),
             renderedActionComment = parseOrError(i.interactionActionComment),
             renderedAssayDescription = parseOrError(i.assayDescription),
             speciesShort = speciesShortName(i.speciesID))
          },
          is)
      }

      var interactions : [InteractionInfo] = augmentInteractions(interactions);
      var interactionsTargeting : [InteractionInfo] =
        augmentInteractions(interactionsTargeting);

      var bioactivityTables = {
        fun emptyTable() {
          makeTable([], [], fun(colName, dir) { NoOp }) # TODO: Temporary
        }

        var cofactorTable = {
          DataTable.makeTable(
            [("Enzyme", ("receptor_header", Sortable(fun(x, y) { markupCmp(x.enzyme, y.enzyme) }))),
             ("Reference", ("reference_header", Sortable(fun(x, y) { referenceCmp(x.references, y.references) })))],
            transformedCofactors, fun(col, dir) { SortCofactorTable(col, dir) })
        };

        # Whole organism assays get a separate table.
        var (wholeOrganismAssays, interactions) =
          partition(fun(i) { i.interaction.wholeOrganismAssay }, interactions);

        fun makeTable(type, data) {
          DataTable.makeTable(
            [("Target", ("receptor_header", Sortable(fun(x, y) {
                  simpleCmp(getTargetName(x.interaction.interactionTarget),
                            getTargetName(y.interaction.interactionTarget)) }))),
             ("", ("", NotSortable)), ("", ("", NotSortable)),
             ("Sp.", ("keybox_header", Sortable(fun(x, y) {
                  simpleCmp(x.speciesShort, y.speciesShort) }))),
             ("Assay Description", ("assay_long_header",
                Sortable(fun(x, y) { simpleCmp(x.interaction.assayDescription,
                    y.interaction.assayDescription) }))),
             ("Type", ("affinity_header", (Sortable(
                fun(x, y) { simpleCmp(x.interaction.interactionTargetType, y.interaction.interactionTargetType) })))),
             ("Action", ("affinity_header", Sortable(
                fun(x, y) { simpleCmp(x.interaction.interactionAction, y.interaction.interactionAction) }))),
             ("Affinity", ("affinity_header", Sortable(
                fun(x, y) { sortAffinity(
                  x.interaction.affinity,
                  y.interaction.affinity) }))),
             ("Parameter", ("units_header", Sortable(
                fun(x, y) { simpleCmp(
                  x.interaction.affinity.affinityUnits,
                  y.interaction.affinity.affinityUnits) }))),
             ("Concentration range (M)", ("units_header", Sortable(
                fun(x, y) { simpleCmp(x.interaction.concentrationRange, y.interaction.concentrationRange) }))),
             ("Reference", ("reference_header", Sortable(
                fun(x, y) {
                  0 # Meh. FIXME
                })))], data, fun(col, dir) { SortInteractionTable(type, col, dir) })
        }

        var grouped = groupBy(fun(i) { i.interaction.interactionTargetType }, interactions);

        fun makeTableFromType(type) {
          var data =
            switch(lookup(type, grouped)) {
              case Just(xs) -> xs
              case Nothing -> []
            };
          makeTable(type, data)
        }

        (enzymeSubstrates = emptyTable(), # TODO
         cofactorEnzymes = cofactorTable,
         transporterSubstrates = emptyTable(), # TODO
         wholeOrganismAssays = makeTable(WholeOrganismAssay, wholeOrganismAssays),
         gpcrInteractions = makeTableFromType(Object(GPCR)),
         icInteractions = makeTableFromType(Object(IC)),
         nhrInteractions = makeTableFromType(Object(NHR)),
         enzymeInteractions = makeTableFromType(Object(Enzyme)),
         catalyticReceptorInteractions = makeTableFromType(Object(CatalyticReceptor)),
         transporterInteractions = makeTableFromType(Object(Transporter)),
         targetLigandInteractions = makeTableFromType(TargetLigand),
         interactionsTargeting = makeTable(TargetingLigand, interactionsTargeting),
         otherInteractions = makeTableFromType(Object(Other))
        )
      };

      var precursors = transformPrecursors(rawInfo.precursors);
      var precursorTable = DataTable.makeTable(
          [
           ("Gene Symbol", ("", Sortable(fun(x, y) {
                simpleCmp(x.precursorGeneName, y.precursorGeneName) }))),
           ("Gene name", ("", Sortable(fun(x, y) {
                simpleCmp(x.precursorGeneName, y.precursorGeneName) }))),
           ("Species", ("", Sortable(fun(x, y) {
                simpleCmp(x.precursorSpecies, y.precursorSpecies) }))),
           ("Precursor protein name", ("", Sortable(fun(x, y) {
                simpleCmp(x.precursorProteinName, y.precursorProteinName) }))),
           ("Synonyms", ("header", Sortable(fun(x, y) { 0 })))
          ], precursors, fun(name, dir) { SortPrecursorTable(name, dir) });

      var interactionRefs = concatMap(fun(x) { x.interaction.references },
          interactions ++ interactionsTargeting);

      # typename MalariaTargetProfile = (
      #   tcpID: Int,
      #   tcpProfile: Markup,
      #   tcpIntendedUse: Markup,
      #   tcpTargetStage: Markup,
      #   tcpComment: Markup,
      #   tcpReferences: [ReferenceID]
      # )
      sig transformTCPs : (%) ~%~> ([MalariaTargetProfile], [Int], [Int])
      fun transformTCPs(tcps) {
        fold_right(fun(x, (tcps, tcpRefs, tcpLigands)) {
            var tcpProfile = parseOrError(x.tcp.profile);
            var tcpIntendedUse = parseOrError(x.tcp.intended_use);
            var tcpTargetStage = parseOrError(x.tcp.target_stage);
            var tcpComment = parseOrError(x.l2tcp.comment);
            var tcpReferences = x.refs;
            var (refs, ligs) = RenderMarkup.collectAllIds([
                tcpProfile, tcpIntendedUse, tcpTargetStage, tcpComment
            ]);
            var tcp = (tcpID = x.tcp.tcp_id,
             =tcpProfile,
             =tcpIntendedUse,
             =tcpTargetStage,
             =tcpComment,
             =tcpReferences);
            (tcp :: tcps, tcpRefs ++ refs ++ tcpReferences, tcpLigands ++ ligs)
        }, ([], [], []), tcps)
      }

      var (tcps, tcpRefs, tcpLigands) = transformTCPs(rawInfo.target_profiles);

      fun transformRankPotencies(rps) {
        fold_right(fun(x, (rps, rpRefs, rpLigands)) {
            var glrp = x.glrp;
            var references = x.refs;
            
            var description = parseOrError(glrp.description);
            var data = parseOrError(glrp.rank_potency);
            var (mRefs, mLigands) = collectAllIds([description, data]);
            var (objectID, objectName) = x.object;
            var x = (=description, =objectName, =objectID, =data, =references);
            (x :: rps, references ++ mRefs ++ rpRefs, mLigands ++ rpLigands)
        }, ([], [], []), rps)
      }

      fun transformMentionedInObjects(mios) {
        fold_right(fun(x, (mios, mioRefs, mioLigands)) {
            var o = x.o;
            var comment = parseOrError(o.grac_comments);
            var (refs, ligs) = collectIds(comment);
            var mio = (objectID = o.object_id, objectName = o.name,
                families = x.families, =comment);
            (mio :: mios, refs ++ mioRefs, ligs ++ mioLigands)
            }, ([], [], []), mios)
      }

      var (rankPotencies, rpRefs, rpLigands) =
        transformRankPotencies(rawInfo.rank_potencies);

      var (mentionedInObjs, mioRefs, mioLigands) =
        transformMentionedInObjects(rawInfo.mentioned_in_objects);

      # print("Raw rank potencies: " ^^ show(rawInfo.rank_potencies));
      # print("Transformed rank potencies: " ^^ show(rankPotencies));

      # Finally, resolve ligand and comment references
      var rawRefs =
        uniquify(
            commentRefs ++
            peptideRefs ++
            interactionRefs ++
            immunoDiseaseRefs ++
            tcpRefs ++
            rpRefs ++
            mioRefs ++
            cofactorRefs);

      var rawLigands =
        uniquify(commentLigands ++
            peptideLigands ++
            immunoDiseaseLigands ++
            rpLigands ++
            mioLigands ++
            tcpLigands);

      var refs = mkReferenceData(queryReferences(rawRefs));
      # iter(fun((_, (_, x))) { print("PMID: " ^^ intToString(x.pubmedId)) }, refs);
      var ligandRefs = queryLigands(rawLigands);

      var dbLinks = transformDatabaseLinks(rawInfo.databaseLinks);

      fun transformMentionedIn(mis) {
        switch (mis) {
          case [] -> (comments = [], overviews = [])
          case x :: _ -> x
        }
      }

      (ligandID = ligandId,
       rawLigand = rawInfo.ligand,
       ligandType = rawInfo.ligand.type,
       ligandName = parseOrError(rawInfo.ligand.name),
       ligandPeptideInfo = peptideInfo,
       ligandPrecursorTable = precursorTable,
       ligandBioactivityTables = bioactivityTables,
       ligandFamilies = transformFamilies(rawInfo.families),
       ligandPhysicalProperties =
         transformPhysicalProperties(rawInfo.physicalProperties),
       ligandSubunits = transformSubunits(rawInfo.subunits),
       ligandHeteromers = transformSubunits(rawInfo.heteromers),
       ligandApproval = approval,
       ligandWithdrawn = rawLigand.withdrawn_drug,
       ligandIUPACName = rawLigand.iupac_name,
       ligandINNs = transformInns(rawInfo.inns),
       ligandSynonyms = transformSynonyms(rawInfo.synonyms),
       ligandComments = comments,
       ligandURLs = urls,
       ligandDBLinks = transformDatabaseLinks(rawInfo.databaseLinks),
       ligandStructure = transformStructure(rawInfo.structural_info),
       ligandImmuno = rawInfo.ligand.in_gtip,
       ligandMalaria = rawInfo.ligand.in_gtmp,
       ligandImmunopaediaCases = rawInfo.immunopaediaCases,
       ligandImmunoDiseases = immunoDiseases,
       ligandReferences = refs,
       ligandEndogenousTargets = rawInfo.endogenousTargets,
       ligandProdrugs = rawInfo.prodrugs,
       ligandActiveForms = rawInfo.activeForms,
       ligandLigandRefs = ligandRefs,
       ligandClusters = clusteredLigands,
       ligandTCPs = tcps,
       ligandRankPotencies = rankPotencies,
       ligandMentionedIn = transformMentionedIn(rawInfo.mentioned_in),
       ligandMentionedInObjects = mentionedInObjs 
       )
    }

    var results =
      query nested {
        for (l <-- Tables.ligand)
        where (l.ligand_id == ligandId)
          [(ligand = l,
            peptide =
              for (p <-- Tables.peptide)
              where (p.ligand_id == ligandId)
              [p],
            interactions =
              InteractionUtilities.interactionsForLigand(ligandId),
            precursors =
              for (p2p <-- Tables.precursor2peptide)
              where (p2p.ligand_id == ligandId)
                for (p <-- Tables.precursor)
                where (p.precursor_id == p2p.precursor_id)
                [(precursor = p,
                  synonyms =
                    for (p2s <-- Tables.precursor2synonym)
                    where (p2s.precursor_id == p.precursor_id)
                      [p2s.synonym])],
            physicalProperties =
              for (physchem <-- Tables.ligand_physchem)
              where (physchem.ligand_id == ligandId)
              [physchem],
            families =
              for (l2f <-- Tables.ligand2family)
              where (l2f.ligand_id == ligandId)
                for (f <-- Tables.family)
                where (f.family_id == l2f.family_id)
                [f],
            inns =
              for (l2inn <-- Tables.ligand2inn)
              where (l2inn.ligand_id == ligandId)
                for (i <-- Tables.inn)
                where (i.inn_number == l2inn.inn_number)
                [i],
            structural_info =
              for (struct <-- Tables.ligand_structure)
              where (struct.ligand_id == ligandId)
                [struct],
            subunits =
              for (l2s <-- Tables.ligand2subunit)
              where (l2s.ligand_id == ligandId)
                for (l <-- Tables.ligand)
                  where (l.ligand_id == l2s.subunit_id)
                  [(l.ligand_id, l.name)],
            heteromers =
              for (l2s <-- Tables.ligand2subunit)
              where (l2s.subunit_id == ligandId)
                for (l <-- Tables.ligand)
                  where (l.ligand_id == l2s.ligand_id)
                  [(l.ligand_id, l.name)],
            immunopaediaCases =
              for (i2l <-- Tables.immunopaedia2ligand)
              where (i2l.ligand_id == ligandId)
                for (i <-- Tables.immunopaedia_cases)
                where (i.immunopaedia_case_id == i2l.immunopaedia_case_id)
                [(title=i.title, url=i.url)],
            immunoDiseases =
              for (id2l <-- Tables.immuno_disease2ligand)
              where (id2l.ligand_id == ligandId)
                for (d <-- Tables.disease)
                where (d.disease_id == id2l.disease_id)
                  [(disease = d,
                    comment = id2l.comment,
                    refs =
                      for (r <-- Tables.immuno_disease2ligand_refs)
                      where (r.immuno_disease2ligand_id == id2l.immuno_disease2ligand_id)
                      [r.reference_id],
                    dbLinks =
                      for (ddl <-- Tables.disease_database_link)
                      where (ddl.disease_id == d.disease_id)
                        for (db <-- Tables.tbl_database)
                        where (db.database_id == ddl.database_id)
                        [(db = db, ddl = ddl)])],
            prodrugs =
              for (p <-- Tables.prodrug)
              where (p.drug_ligand_id == ligandId)
                for (l <-- Tables.ligand)
                where (l.ligand_id == p.prodrug_ligand_id)
                [(id = l.ligand_id, name = l.name)],
            activeForms =
              for (p <-- Tables.prodrug)
              where (p.prodrug_ligand_id == ligandId)
                for (l <-- Tables.ligand)
                where (l.ligand_id == p.drug_ligand_id)
                [(id = l.ligand_id, name = l.name)],
            endogenousTargets =
              for (l <-- Tables.list_ligand)
              where (l.ligand_id == ligandId)
                for (o <-- Tables.object)
                where (o.object_id == l.object_id)
                [(id = o.object_id, name = o.name)],
            databaseLinks =
              for (dbl <-- Tables.ligand_database_link)
                where (dbl.ligand_id == ligandId)
                [dbl],
            cofactors =
              for (c <-- Tables.cofactor)
                where (c.ligand_id == ligandId)
                  for (o <-- Tables.object)
                  where (o.object_id == c.object_id)
                  [(name = o.name, objectID = c.object_id,
                    refs =
                      for (r <-- Tables.cofactor_refs)
                      where (r.cofactor_id == c.cofactor_id)
                      [r.reference_id])],
            clusters =
              for (cl <-- Tables.ligand_cluster_new)
                where (cl.ligand_id == ligandId)
                  [cl.cluster],
            analogue_clusters =
              for (acl <-- Tables.analogue_cluster)
                where (acl.ligand_id == ligandId)
                  [acl.cluster],
            peptide_ligand_clusters =
              for (pcl <-- Tables.peptide_ligand_cluster)
                where (pcl.ligand_id == ligandId)
                  [pcl.cluster],
            peptide_ligand_sequence_clusters =
              for (pcls <-- Tables.peptide_ligand_sequence_cluster)
                where (pcls.ligand_id == ligandId)
                  [pcls.cluster],
            # Used for Peptide similar ligands
            related_ligands =
              for (l2 <-- Tables.ligand)
                where (l2.name == l.name && l2.ligand_id <> ligandId)
                  [(id = l2.ligand_id, name = l2.name,
                    targets =
                      for (i <-- Tables.interaction)
                      where (i.ligand_id == l2.ligand_id)
                        for (o <-- Tables.object)
                        where (o.object_id == i.object_id)
                        [ (id = o.object_id, name = o.name) ])],
            synonyms =
              for (l2s <-- Tables.ligand2synonym)
                where (l2s.ligand_id == ligandId)
                [(l2s = l2s,
                  refs =
                    for (sref <-- Tables.ligand2synonym_refs)
                      where (sref.ligand2synonym_id == l2s.ligand2synonym_id)
                      [sref.reference_id])],
            target_profiles =
              for (l2tcp <-- Tables.ligand2tcp)
                where (l2tcp.ligand_id == ligandId)
                for (tcp <-- Tables.target_candidate_profile)
                  where (l2tcp.tcp_id == tcp.tcp_id)
                  [(=l2tcp, =tcp,
                    refs =
                      for (r <-- Tables.ligand2tcp_refs)
                      where (r.ligand2tcp_id == l2tcp.ligand2tcp_id)
                      [r.reference_id])],
            interactions_targeting =
              InteractionUtilities.interactionsTargeting(ligandId),
            rank_potencies =
              for (glrp <-- Tables.grac_ligand_rank_potency)
                where (glrp.rank_potency =~ /.*<Ligand\ id={intToString(ligandId)}\/>.*/)
                for (o <-- Tables.object)
                where (o.object_id == glrp.object_id)
                [(=glrp,
                  object = (o.object_id, o.name),
                  refs =
                    for (r <-- Tables.grac_ligand_rank_potency_refs)
                    where (r.grac_ligand_rank_potency_id ==
                      glrp.grac_ligand_rank_potency_id)
                      [r.reference_id])],
            mentioned_in =
              [(overviews =
                   for (gft <-- Tables.grac_family_text)
                   where (gft.overview =~ /.*<Ligand\ id={intToString(ligandId)}\/>.*/)
                     for (f <-- Tables.family)
                     where (f.family_id == gft.family_id)
                     [ (familyID = f.family_id, familyName = f.name) ],
                 comments =
                   for (gft <-- Tables.grac_family_text)
                   where (gft.comments =~ /.*<Ligand\ id={intToString(ligandId)}\/>.*/)
                     for (f <-- Tables.family)
                     where (f.family_id == gft.family_id)
                     [ (familyID = f.family_id, familyName = f.name) ])],
            mentioned_in_objects =
              for (o <-- Tables.object)
                where (o.grac_comments =~ /.*<Ligand\ id={intToString(ligandId)}\/>.*/)
                  [(=o,
                    families =
                      for (r2f <-- Tables.receptor2family)
                      where (r2f.object_id == o.object_id)
                        for (f <-- Tables.family)
                        where (f.family_id == r2f.family_id)
                        [(familyID = f.family_id, familyName = f.name)])],
            old_clusters =
              for (cl <-- Tables.ligand_cluster)
                where (cl.ligand_id == ligandId)
                  [cl.cluster]
          )]
      };

    switch (results) {
      case [] -> debug("No results"); Nothing
      case x :: _ -> Just(transformLigandInfo(x))
    }
  }

  switch(lookup("ligandId", environment())) {
    case Nothing -> debug("No ID"); Nothing
    case Just(id) ->
      var speciesMap = Species.getSpeciesMap();
      switch (getLigandInfo(stringToInt(id), speciesMap)) {
        case Nothing -> debug("Failed getting ligand info"); Nothing
        case Just(ligandInfo) ->
          Just((modelTab = Summary, modelLigand = ligandInfo, modelSpeciesMap = speciesMap))
      }
  }
}

sig updt : (Message, Model) ~%~> Model
fun updt(msg, model) {
  fun updt(model) {
    switch (msg) {
      case ChangeTab(filter) ->
        (model with modelTab = filter)
      case SortPrecursorTable(colName, dir) ->
        var sortedTable =
          updateSortStatus(model.modelLigand.ligandPrecursorTable, colName, dir);
        (model with modelLigand =
          (model.modelLigand with ligandPrecursorTable = sortedTable))
      case SortInteractionTable(ty, colName, dir) ->
        var tables = model.modelLigand.ligandBioactivityTables;

        var newTables =
          switch (ty) {
            case Object(GPCR) ->
              (tables with gpcrInteractions =
                updateSortStatus(tables.gpcrInteractions, colName, dir))
            case Object(IC) ->
              (tables with icInteractions =
                updateSortStatus(tables.icInteractions, colName, dir))
            case Object(NHR) ->
              (tables with nhrInteractions =
                updateSortStatus(tables.nhrInteractions, colName, dir))
            case Object(Enzyme) ->
              (tables with enzymeInteractions =
                updateSortStatus(tables.enzymeInteractions, colName, dir))
            case Object(CatalyticReceptor) ->
              (tables with catalyticReceptorInteractions =
                updateSortStatus(tables.catalyticReceptorInteractions, colName, dir))
            case Object(Transporter) ->
              (tables with transporterInteractions =
                updateSortStatus(tables.transporterInteractions, colName, dir))
            case Object(Other) ->
              (tables with otherInteractions =
                updateSortStatus(tables.otherInteractions, colName, dir))
            case TargetLigand ->
              (tables with targetLigandInteractions =
                updateSortStatus(tables.targetLigandInteractions, colName, dir))
            case TargetingLigand ->
              (tables with interactionsTargeting =
                updateSortStatus(tables.interactionsTargeting, colName, dir))
            case WholeOrganismAssay ->
              (tables with wholeOrganismAssays =
                updateSortStatus(tables.wholeOrganismAssays, colName, dir))
          };
        (model with modelLigand =
          (model.modelLigand with ligandBioactivityTables = newTables))
      case SortCofactorTable(colName, dir) ->
        var tables = model.modelLigand.ligandBioactivityTables;
        var newTables =
          (tables with cofactorEnzymes =
            updateSortStatus(tables.cofactorEnzymes, colName, dir));
        (model with modelLigand =
          (model.modelLigand with ligandBioactivityTables = newTables))
      case NoOp -> model #temp
    }
  }
  switch (model) {
    case Just(model) -> Just(updt(model))
    case Nothing -> model
  }
}

sig view : (Model) ~%~> MvuHTML.HTML(Message)
fun view(model) {
  open MvuHTML;
  open MvuAttrs;

  fun viewModel(model) {
    var ligandInfo = model.modelLigand;
    var strId = intToString(ligandInfo.ligandID);
    var h0 = MvuHTML.empty;
    var a0 = MvuAttrs.empty;

    fun renderCitations(refs) {
      renderCitationList(refs, ligandInfo.ligandReferences)
    }

    fun renderM(m) {
      renderMarkup(m, ligandInfo.ligandReferences,
          ligandInfo.ligandLigandRefs)
    }

    fun renderBox(name, colspan, content) {
      table_(class("receptor_data_tables") +@ style("width:100%"),
        tbody(a0,
          tr(a0,
            td(class("category") +@ colSpan(colspan), textNode(name))) +*
          content))
    }

    fun commentBox(caption, comments) {
      if (markupEmpty(comments)) {
        MvuHTML.empty
      } else {
        renderBox(caption, 1, tr(a0, td(class("info"), renderM(comments))))
      }
    }

    fun renderBoxIfNonempty(boxName, contents) {
      if (markupEmpty(contents)) {
        MvuHTML.empty
      } else {
        table_(class("receptor_data_tables") +@ style("width:100%;"),
          tr(a0,
            td(class("category") +@ colSpan(2), textNode(boxName))) +*
          tr(class("info"),
            td(style("text-align:left;"), renderM(contents))))
      }
    }

    var basicInfoBox = {
      div(class("grid_16 alpha"),
        a(name("top"), h0) +*
        h4(a0, renderM(ligandInfo.ligandName)) +*
        div(class("contentboxfullhelp"),
          div(class("textright"),
            p(a0, b(a0, textNode("Ligand id: ")) +*
              textNode(strId)) +*
            p(a0, b(a0, textNode("Name: ")) +*
              renderM(ligandInfo.ligandName)))))
    };

    var structuralInfoBox = {
      var structureImgBox = {
        td(style("width:453px;min-width:453px;text-align:left;vertical-align:top;"),
          table_(class("ligand_header_table") +@ style("width:453px;margin:0px"),
            tr(a0,
              td(class("ligand_header_category"), textNode("2D Structure"))) +*
            tr(class("ligand_header_info"),
              td(style("vertical-align:middle;text-align:center;"),
                a(style("color:white;") +@ href("/chemicalStructureEditor?ligandId="
                    ^^ strId) +@
                  MvuAttrs.title("Click here for structure editor"),
                  img(src("https://www.guidetopharmacology.org/CHEMSTRUCT/iuphar/" ^^ strId ^^ ".gif") +@
                    height("250") +@ alt("Click here for structure editor"), h0))))))
      };

      var propertiesBox = {
        fun renderProperties(lpps) {
          var properties =
            [("Hydrogen bond acceptors",
                textNode(intToString(lpps.lpHydrogenBondAcceptors))),
             ("Hydrogen bond donors",
                textNode(intToString(lpps.lpHydrogenBondDonors))),
             ("Rotatable bonds", textNode(intToString(lpps.lpRotatableBonds))),
             ("Topological polar surface area",
                textNode(floatToString(lpps.lpTopologicalPolarSurfaceArea))),
             ("Molecular weight",
                textNode(floatToString(lpps.lpMolecularWeight))),
             ("XLogP", textNode(floatToString(lpps.lpXLogP))),
             ("No. Lipinski's rules broken",
                textNode(intToString(lpps.lpLipinskiRules)))];

          fun renderRow((name, html)) {
            tr(class("ligand_header_info"),
              td(a0, textNode(name)) +*
              td(style("text-align:center"), html))
          }
          var rows = MvuHTML.concatMap(renderRow, properties);
          table_(class("ligand_header_table") +@ style("width:453px;margin:0px;"),
            thead(a0,
              tr(a0,
                td(class("ligand_header_category") +@ colSpan(2) +@ style("text-align:left;"),
                  textNode("Calculated Physico-chemical Properties")))) +*
              rows) +*
          p(style("margin:5px;font-size:90%;"),
                textNode("Molecular properties generated using the ") +*
                a(href("https://cdk.github.io"), textNode("CDK")))
        }

        switch(ligandInfo.ligandPhysicalProperties) {
          case Just(lpps) -> renderProperties(lpps)
          case Nothing -> MvuHTML.empty
        }
      };

      div(class("grid_16 alpha"),
        h4(a0,
          textNode("Structure and Physico-chemical Properties")) +*
        div(class("contentboxfullhelp"),
          table_(class("fullwidth") +@ style("position:relative; margin-bottom: 10px"),
            tr(a0,
              structureImgBox +*
              td(style("min-width:10px;width:10px;"), h0) +*
              propertiesBox))))

    };

    var summaryPage = {
      var classificationTable = {
        fun renderFamily(f) {
          a(href("/familyDisplay?familyId=" ^^ intToString(f.familyId)),
              textNode(f.familyName))
        }
        var renderedFamilies =
          MvuHTML.concat(join([textNode(", ")],
            map(fun(f) { [renderFamily(f)] }, ligandInfo.ligandFamilies)));

        fun renderProdrugRefs(refs) {
          MvuHTML.concat(join([textNode(", ")],
            map(fun(r) {
              [a(href("/ligandDisplay?ligandId=" ^^ intToString(r.id)),
                textNode(r.name))]
            }, refs)))
        }

        var renderedActiveForms = renderProdrugRefs(ligandInfo.ligandActiveForms);
        var renderedProdrugs = renderProdrugRefs(ligandInfo.ligandProdrugs);

        var compoundClassData = {
          var ligandHref =
            if (ligandInfo.ligandType == "Synthetic organic") {
              "SyntheticOrganic"
            } else if (ligandInfo.ligandType == "Natural product") {
              "NaturalProduct"
            } else if (ligandInfo.ligandType == "Peptide") {
              "EndogenousPeptide"
            } else {
              ligandInfo.ligandType
            };
          a(href("/ligandList?type=" ^^ ligandHref), textNode(ligandInfo.ligandType))
        };

        var approvalData =
          switch (ligandInfo.ligandApproval) {
            case NotApproved -> textNode("No")
            case Approved(source) ->
              var suffix =
                if (source == "") {
                  MvuHTML.empty
                } else {
                  textNode(" (" ^^ source ^^ ")")
                };
              textNode("Yes") +* suffix
          };

        var rows = [
          ("Compound class", compoundClassData, true),
          ("Ligand families / groups", renderedFamilies, not(listEmpty(ligandInfo.ligandFamilies))),
          ("Approved drug", approvalData, ligandInfo.ligandApproval <> NotApproved),
          ("Withdrawn drug", textNode("Yes"), ligandInfo.ligandWithdrawn),
          ("Is prodrug?", textNode("Yes"), not(listEmpty(ligandInfo.ligandActiveForms))),
          ("Drugs", renderedActiveForms, not(listEmpty(ligandInfo.ligandActiveForms))),
          ("Prodrugs", renderedProdrugs, not(listEmpty(ligandInfo.ligandProdrugs)))
        ];

        fun renderRow((columnName, content, show)) {
          if (show) {
            tr(a0,
              td(class("info") +@ align("left") +@
                style("min-width:250px;max-width:250px;width:250px;"),
                textNode(columnName)) +*
              td(class("info"), content))
          } else {
            MvuHTML.empty
          }
        }

        var renderedRows = MvuHTML.concatMap(renderRow, rows);
        renderBox("Classification", 2, renderedRows)
      };

      var iupacBox = {
        if (ligandInfo.ligandIUPACName == "") {
          MvuHTML.empty
        } else {
          renderBox("IUPAC Name", 1, tr(class("info"),
            td(a0, textNode(ligandInfo.ligandIUPACName))))
        }
      };

      var innsBox = {
        fun renderINN(inn) {
          tr(class("info"),
            td(a0, textNode(intToString(inn.innNumber))) +*
            td(a0, textNode(inn.inn)))
        }
        if (listEmpty(ligandInfo.ligandINNs)) {
          MvuHTML.empty
        } else {
          var innsRows = MvuHTML.concatMap(renderINN, ligandInfo.ligandINNs);
          var contents =
            tr(a0,
              td(class("heading"), textNode("INN Number")) +*
              td(class("heading"), textNode("INN"))) +*
            innsRows;
          renderBox("International Nonproprietary Names", 2, contents)
        }
      };

      var synonymsBox = {
        var contents = MvuHTML.concat(join([textNode(" | ")],
              map(fun(x) { [RenderMarkup.renderSimple(x.synonymName)] }, ligandInfo.ligandSynonyms)));
        if (listEmpty(ligandInfo.ligandSynonyms)) {
          MvuHTML.empty
        } else {
          renderBox("Synonyms", 1, tr(a0, td(class("info"), contents)))
        }
      };

      var medicalRelevanceBox = {
        switch (ligandInfo.ligandPeptideInfo) {
          case Nothing -> MvuHTML.empty
          case Just(pi) ->
            renderBoxIfNonempty("Medical Relevance", pi.peptideMedicalRelevance)
        }
      };

      var commentsBox =
        commentBox("Comments", ligandInfo.ligandComments.generalComments);

      var precursorTableBox = {
        if (listEmpty(getTableData(ligandInfo.ligandPrecursorTable))) {
          MvuHTML.empty
        } else {
          var renderedTable =
            renderTable(ligandInfo.ligandPrecursorTable,
              fun(precursor) {
                var renderedSynonyms = MvuHTML.concat(join([textNode(", ")],
                    map(fun(s) { [textNode(s)] }, precursor.precursorSynonyms)));
                tr(class("info"),
                  td(a0, textNode(precursor.precursorGeneName)) +*
                  td(a0, textNode(precursor.precursorGeneLongName)) +*
                  td(a0, textNode(precursor.precursorSpecies)) +*
                  td(a0, textNode(precursor.precursorProteinName)) +*
                  td(a0, renderedSynonyms))
              });
          table_(class("receptor_data_tables") +@ width("100%"),
            tbody(a0,
              tr(a0,
                td(class("category"), textNode("Gene/Precursor"))) +*
              tr(a0,
                td(class("table_container"), renderedTable))))
        }
      };

      var dbLinksBox = {
        var extraLinks = {
          var hpaLinks = [];

          var inchiLinks = {
            switch (ligandInfo.ligandStructure) {
              case Just(x) ->
                if (x.inchiStandardKey <> "") {
                  var inchi = x.inchiStandardKey;
                  var inchiBackbone =
                    hd(splitOnChar(x.inchiStandardKey, '-'));
                  var inchiLinks =
                    [
                      ("Search Google for chemical match using the InChIKey",
                        ("https://www.google.com/search?q=" ^^ inchi,
                         inchi)),
                      ("Search Google for chemicals with the same backbone",
                        ("https://www.google.com/search?q=" ^^ inchiBackbone,
                         inchiBackbone)),
                      ("Search UniChem for chemical match using the InChIKey",
                        ("https://www.ebi.ac.uk/unichem/widesearch/wideresults?queryText=" ^^
                          inchi ^^
                          "&kind=InChIKey&source=&nameXA=&kindXB=1&kindXC=0&DText=0&EText=0&kindXF=0&kindXG=0",
                         inchi)),
                      ("Search UniChem for chemicals with the same backbone",
                        ("https://www.ebi.ac.uk/unichem/widesearch/wideresults?queryText=" ^^
                          inchiBackbone ^^
                          "&kind=InChIKey&source=&nameXA=&kindXB=1&kindXC=0&DText=0&EText=0&kindXF=0&kindXG=0",
                         inchiBackbone))
                    ];
                  map(fun((name, (url, inchi))) { (name, a(href(url), textNode(inchi))) }, inchiLinks)
                } else {
                  []
                }
              case Nothing -> []
            }
          };

          var innLinks : [(String, (String, String))]=
            listConcatMap(fun(x) {
                var inn = x.inn;
                [
                  ("Search PubMed clinical trials",
                    ("http://www.ncbi.nlm.nih.gov/pubmed/?term="
                       ^^ inn ^^
                      "[Title]+AND+(\"clinical+trial+phase+i\"[Filter]+OR+\"clinical+trial+phase+ii\"[Filter]+OR+\"clinical+trial+phase+iii\"[Filter]+OR+\"clinical+trial+phase+iv\"[Filter])", inn)),
                  ("Search PubMed clinical title",
                     ("http://www.ncbi.nlm.nih.gov/pubmed/?term=" ^^ inn ^^ "[Title]&cmd=DetailsSearch", inn)),
                  ("Search PubMed clinical titles/abstracts",
                     ("http://www.ncbi.nlm.nih.gov/pubmed/?term=" ^^ inn ^^ "[Title%2FAbstract]&cmd=DetailsSearch", inn))
                ]
              }, ligandInfo.ligandINNs);
          var innLinks : [(String, MvuHTML.HTML(%))]=
            map(fun((name, (url, inchi))) { (name, a(href(url), textNode(inchi))) }, innLinks);


          var pubchemLinks =
            if (ligandInfo.rawLigand.pubchem_sid <> 0) {
              var sid = intToString(ligandInfo.rawLigand.pubchem_sid);
              [("GtoPdb PubChem SID", a(href("https://pubchem.ncbi.nlm.nih.gov/substance/" ^^ sid), textNode(sid)))]
            } else {
              []
            };

          hpaLinks ++ inchiLinks ++ innLinks ++ pubchemLinks
        };

        var dbLinks = {
          # These are relevant DB IDs. These are explicitly stated in the GtoPdb
          # code -- so we have to do the same here.
          var relevant =
            [1, 3, 5, 8, 10, 11, 12, 15, 16, 17, 20, 21, 24,
             25, 29, 31, 33, 39, 18, 63, 55, 58, 59, 40, 65];
          filter(fun(x) { listElem(x.dbID, relevant) }, ligandInfo.ligandDBLinks)
        };


        renderDatabaseLinks(dbLinks, extraLinks, model.modelSpeciesMap)
      };

      classificationTable +*
      iupacBox +*
      innsBox +*
      synonymsBox +*
      commentsBox +*
      precursorTableBox +*
      medicalRelevanceBox +*
      dbLinksBox
    };

    var biologicalActivityPage = {
      # TO DO:
      # 1. ~~~Bioactivity comments~~~ DONE!
      # 2. ~~~Endogenous targets~~~ DONE!
      # 3. ~~~Enzyme substrates~~~ DONE!
      # 4. ~~~Cofactor enzymes~~~ DONE!
      # 5. Transporters
      # 6. ~~~Interactions~~~ DONE!
      # 7. Rank potencies
      # 8. ~~~Targeting ligands~~~ DONE!

      var endogenousTargetsBox = {
        if (listEmpty(ligandInfo.ligandEndogenousTargets)) {
          MvuHTML.empty
        } else {
          fun renderRow(t) {
            tr(class("info"),
              td(a0,
                a(href("/objectDisplay?objectId=" ^^ intToString(t.id)), unescapedTextNode(t.name))))
          }

          var renderedRows =
            MvuHTML.concatMap(renderRow, ligandInfo.ligandEndogenousTargets);

          table_(class("receptor_data_tables") +@ style("width:100%"),
            thead(a0,
              tr(name("hotspot") +@ class("hotspot"),
                td(class("category") +@ colSpan(2), textNode("Natural/Endogenous Targets")))) +*
            tbody(name("toggle"),
              tr(a0,
                td(class("table_container"),
                  table_(id("endogenous-targets") +@ class("inner_receptor_data_tables"),
                    thead(a0,
                      tr(class("heading"),
                        th(class("receptor_header header"), textNode("Target")))) +*
                    tbody(a0, renderedRows))))))

        }
      };

      var enzymeSubstrates = {
        var tbl = ligandInfo.ligandBioactivityTables.enzymeSubstrates;
        if (listEmpty(getTableData(tbl))) {
          MvuHTML.empty
        } else {

          fun renderRow(e) {
            tr(class("info"),
              td(a0,
                a(href("/objectDisplay?objectId=" ^^ intToString(e.enzymeID)),
                  unescapedTextNode(e.enzyme))) +*
              td(a0, unescapedTextNode(e.ecNumber)) +*
              td(a0, unescapedTextNode(e.reaction)) +*
              td(a0,
                renderCitationList(e.references, ligandInfo.ligandReferences)))
          }

          table_(class("receptor_data_tables") +@ style("width:100"),
            thead(a0,
              tr(name("hotspot") +@ class("hotspot"),
                td(class("category") +@ colSpan(2),
                  textNode("Enzymes Catalysing Reactions with this Compound as a Substrate or Product")))) +*
            tbody(name("toggle"),
              tr(a0,
                td(class("table_container"),
                  renderTable(tbl, renderRow)))))
        }
      };

      var cofactorEnzymes = {
        var tbl = ligandInfo.ligandBioactivityTables.cofactorEnzymes;
        if (listEmpty(getTableData(tbl))) {
          MvuHTML.empty
        } else {

          fun renderRow(cfe) {
            tr(class("info"),
              td(a0,
                a(href("/objectDisplay?objectId=" ^^ intToString(cfe.enzymeID)),
                  renderM(cfe.enzyme))) +*
              td(a0,
                renderCitationList(cfe.references, ligandInfo.ligandReferences)))
          }

          table_(class("receptor_data_tables") +@ style("width:100"),
            thead(a0,
              tr(name("hotspot") +@ class("hotspot"),
                td(class("category") +@ colSpan(2),
                  textNode("Cofactor in Enzyme Reactions")))) +*
            tbody(name("toggle"),
              tr(a0,
                td(class("table_container"),
                  renderTable(tbl, renderRow)))))
        }
      };
      var transporters = {
        MvuHTML.empty
      };

      var interactions = {
        var tables = ligandInfo.ligandBioactivityTables;
        fun renderIfNonempty(tableName, tbl) {
          fun renderRow(row) {
            var i = row.interaction;
            var renderedTarget = {
              if (i.targetLigandID > 0) {
                a(href("/ligandDisplay?ligandId=" ^^ intToString(i.targetLigandID)),
                    renderM(row.renderedName))
              } else if (i.objectID > 0) {
                a(href("/objectDisplay?objectId=" ^^ intToString(i.objectID)),
                    renderM(row.renderedName))
              } else {
                textNode("Unknown MOA")
              }
            };

            fun mkCol(contents) { td(a0, contents) }
            var renderedType = {
              textNode(showInteractionTargetType(i.interactionTargetType)) +*
              (if (i.ligandContext <> "") {
                textNode(i.ligandContext ^^ " ")
              } else {
                MvuHTML.empty
              })
            };
            tr(class("info"),
              td(style("border-style: solid dotted solid solid;"), #+@ rowSpan(2),
                renderedTarget) +*
              boolImage(("/images/primary.png", i.primaryTarget, "Primary target of this compound")) +*
              boolImage(("/images/endogenous.gif", i.endogenous, "Ligand is endogenous in the given species")) +*
              td(style("text-align:center;"), textNode(row.speciesShort)) +*
              mkCol(renderM(row.renderedAssayDescription)) +*
              mkCol(renderedType) +*
              mkCol(textNode(i.interactionAction)) +*
              mkCol(displayAffinity(i.affinity, true)) +*
              mkCol(textNode(i.affinity.affinityUnits)) +*
              mkCol(textNode(i.concentrationRange)) +*
              mkCol(renderCitationList(i.references, ligandInfo.ligandReferences)))
          }

          if (listEmpty(getTableData(tbl))) {
            MvuHTML.empty
          } else {
            table_(class("receptor_data_tables") +@ style("width:100%"),
              thead(a0,
                tr(name("hotspot") +@ class("hotspot"),
                  td(class("category") +@ colSpan(3), textNode(tableName)))) +*
              tbody(name("toggle"),
                tr(a0,
                  td(class("table_container") +@ colSpan(3),
                    renderTable(tbl, renderRow)))))
          }
        }

        renderIfNonempty("Selectivity at GPCRs", tables.gpcrInteractions) +*
        renderIfNonempty("Selectivity at ion channels", tables.icInteractions) +*
        renderIfNonempty("Selectivity at nuclear hormone receptors", tables.nhrInteractions) +*
        renderIfNonempty("Selectivity at enzymes", tables.enzymeInteractions) +*
        renderIfNonempty("Selectivity at catalytic receptors", tables.catalyticReceptorInteractions) +*
        renderIfNonempty("Selectivity at transporters", tables.transporterInteractions) +*
        renderIfNonempty("Selectivity at ligand targets", tables.targetLigandInteractions) +*
        renderIfNonempty("Selectivity at other protein targets", tables.otherInteractions) +*
        renderIfNonempty("Whole organism assay data", tables.wholeOrganismAssays) +*
        renderIfNonempty("Other ligands which bind to or alter the activity of this ligand", tables.interactionsTargeting)

      };

      var rankPotencies = {
        var rps = ligandInfo.ligandRankPotencies;

        if (listEmpty(rps)) {
          MvuHTML.empty
        } else {
          fun renderRow(x) {
            var link =
              a(href("/objectDisplay?objectId=" ^^
                    intToString(x.objectID)), unescapedTextNode(x.objectName));
            tr(class("info"),
              td(class("embedded_link"),
                renderM(x.description) +* textNode(" at ") +* link) +*
              td(class("embedded_link"), renderM(x.data)) +*
              td(class("embedded_link"), renderCitations(x.references)))
          }

          var headers = {
            tr(class("heading"),
              td(a0, textNode("Description")) +*
              td(a0, textNode("Data")) +*
              td(a0, textNode("Reference")))
          };

          var renderedRows =
            MvuHTML.concatMap(renderRow, ligandInfo.ligandRankPotencies);

          table_(class("receptor_data_tables") +@ style("width:100%"),
            thead(a0,
              tr(name("hotspot") +@ class("hotspot"),
                td(class("category") +@ colSpan(3),
                  textNode("Additional information and targets (data relate to human unless otherwise stated)")))) +*
            tbody(name("toggle"),
              headers +*
              renderedRows))
        }
      };

      var familyComments = {
        var mi = ligandInfo.ligandMentionedIn;
        fun renderRow(x, type) {
          tr(class("info"),
              td(class("embedded_link"),
                a(href("/familyDisplay?familyId=" ^^ intToString(x.familyID)), unescapedTextNode(x.familyName))))
        }

        var renderedRows =
          MvuHTML.concatMap(fun(x) { renderRow(x, "overview") }, mi.overviews) +*
          MvuHTML.concatMap(fun(x) { renderRow(x, "comments") }, mi.comments);

        if (not(listEmpty(mi.overviews ++ mi.comments))) {
          table_(class("receptor_data_tables") +@ style("width:100%"),
            thead(a0,
              tr(class("hotspot"),
                td(class("category"),
                  textNode("Ligand mentioned in the following text fields")))) +*
            tbody(name("toggle"), renderedRows))
        } else {
          MvuHTML.empty
        }
      };

      var objectComments = {
        if (listEmpty(ligandInfo.ligandMentionedInObjects)) {
          MvuHTML.empty
        } else {
          fun renderRow(x) {
            var targetCol =
              switch (x.families) {
                case [] -> MvuHTML.empty
                case [f] ->
                  td(class("embedded_link"),
                    a(href("/familyDisplay?familyId=" ^^ intToString(f.familyID)),
                        unescapedTextNode(x.objectName)))
                case _ ->
                  var links =
                    map(fun(f) {
                          [a(href("/familyDisplay?familyId=" ^^ intToString(f.familyID)),
                              unescapedTextNode(x.objectName)) +*
                          small(a0,
                            i(a0, textNode(" in ")) +*
                            unescapedTextNode(f.familyName))]
                        }, x.families);
                  MvuHTML.concat(join([br(a0, h0)], links))
              };
            var commentCol =
              td(class("embedded_link"), renderM(x.comment));

            tr(class("info"),
              targetCol +* commentCol)
          }

          var renderedRows =
            MvuHTML.concatMap(renderRow, ligandInfo.ligandMentionedInObjects);

          table_(class("receptor_data_tables") +@ style("width:100%"),
            thead(a0,
              tr(class("hotspot"),
                td(class("category") +@ colSpan(2),
                  textNode("Targets where the ligand is described in the comment field"))) +*
              tr(class("heading"),
                td(class("grac_receptor_ligand_table_header"), textNode("Target")) +*
                td(a0, textNode("Comment")))) +*
            tbody(name("toggle"), renderedRows))
        }
      };

      commentBox("Bioactivity Comments", ligandInfo.ligandComments.bioactivityComments) +*
      endogenousTargetsBox +*
      enzymeSubstrates +*
      cofactorEnzymes +*
      transporters +*
      interactions +*
      rankPotencies +*
      familyComments +*
      objectComments
    };

    var clinicalDataPage = {
      var comments = ligandInfo.ligandComments;
      var commentsTable = {
        var commentsRows =
          [("Absorption/Distribution", comments.absorptionDistributionComments),
           ("Biotransformation/Metabolism", comments.metabolismComments),
           ("Elimination", comments.eliminationComments),
           ("Population Pharmacokinetics", comments.popnPharmacokineticsComments),
           ("Organ function impairment", comments.organFunctionImpairmentComments)];

        fun renderRow((colName, comments)) {
          if (markupEmpty(comments)) {
            MvuHTML.empty
          } else {
            tr(a0,
              td(class("category") +@ style("background:white;font-style:italic;"),
                textNode(colName))) +*
            tr(class("info"),
              td(a0, renderM(comments)))
          }
        }
        var renderedRows = MvuHTML.concatMap(renderRow, commentsRows);
        var showTable = any(fun((_, comment)) { not(markupEmpty(comment)) }, commentsRows);
        if (showTable) {
          table_(class("receptor_data_tables") +@ style("width:100%"),
            tr(a0,
              td(class("category"), textNode("Pharmacokinetics"))) +*
            renderedRows)
        } else {
          MvuHTML.empty
        }
      };

      var externalURLs = {
        var urls = ligandInfo.ligandURLs;
        var urlInfo =
          [("Electronic Medicines Compendium (eMC)", "Information about medicines licensed for use in the UK", urls.emcURL),
           ("Drugs.com", "Drug Information Online", urls.drugsURL),
           ("European Medicines Agency (EMA)", "Database of medicines used in Europe", urls.emaURL)];
        fun renderURLRow((name, altText, url)) {
          if (url == "") {
            MvuHTML.empty
          } else {
            a(href(url) +@ title(altText), textNode(name)) +* br(a0, h0)
          }
        }
        var renderedRows = MvuHTML.concatMap(renderURLRow, urlInfo);
        var showURLs = any(fun((_, _, url)) { url <> "" }, urlInfo);
        if (showURLs) {
          table_(class("receptor_data_tables") +@ style("width:100%"),
            tbody(a0,
              tr(a0,
                td(class("category"), textNode("External links"))) +*
              tr(class("info"),
                td(class("embedded_link"),
                  p(a0, textNode("For extended ADME data see the following:")) +*
                  renderedRows))))
        } else {
          MvuHTML.empty
        }
      };

      commentBox("Summary of Clinical Use", comments.clinicalUseComments) +*
      commentBox("Mechanism Of Action and Pharmacodynamic Effects", comments.mechanismOfActionComments) +*
      commentsTable +*
      externalURLs
    };

    var referencesPage = {
      fun renderReference((refID, (refNum, ref))) {
        var issueNode =
          if(ref.issue == "") {
            MvuHTML.empty
          } else {
            textNode(" (" ^^ ref.issue ^^ ")")
          };
        var volumeNode =
          if (ref.volume == "") {
            MvuHTML.empty
          } else {
            b(a0, textNode(ref.volume))
          };

        var pubMedHref =
          "javascript:newWindow('http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=pubmed&dopt=AbstractPlus&list_uids="
          ^^ intToString(ref.pubmedId) ^^ "', 800, 500)";

        var pubMedNode =
        {
          if (ref.pubmedId == (-1)) {
            MvuHTML.empty
          } else {
            textNode("[PMID:") +*
            a(href(pubMedHref), textNode(intToString(ref.pubmedId))) +*
            textNode("]")
          }
        };

        tr(class("info"),
          td(a0,
            span(class("referenceAuthors"),
              textNode(intToString(refNum) ^^ ". ") +*
              textNode(ref.authors)) +*
            br(a0, h0) +*
            textNode(ref.title ^^ ".") +*
            br(a0, h0) +*
            i(a0, textNode(ref.journalName)) +*
            textNode(", ") +*
            volumeNode +*
            issueNode +*
            textNode(": ") +*
            textNode(ref.pages) +*
            textNode(". ") +*
            pubMedNode))
      }

      var ligandRefs = ligandInfo.ligandReferences;
      var renderedReferences = MvuHTML.concatMap(renderReference, ligandRefs);

      if (listEmpty(ligandInfo.ligandReferences)) {
        textNode("There are no references to display")
      } else {
        table_(class("receptor_data_tables") +@ style("width:100%"),
          tr(a0,
            td(class("category"), textNode("References"))) +*
            renderedReferences)
      }
    };

    var structurePage = {
      fun renderSubunit((id, name)) {
        tr(class("info"),
          td(class("embedded_link"),
            a(href("/ligandDisplay?ligandId=" ^^ intToString(id)), renderM(name))))
      }

      fun renderSubunitBox(caption, contents) {
        if (listEmpty(contents)) {
          MvuHTML.empty
        } else {
          var renderedSubunits =
            MvuHTML.concatMap(renderSubunit, contents);
          table_(class("receptor_data_tables") +@ style("width:100%"),
            tr(a0, td(class("category"), textNode(caption))) +*
            renderedSubunits)
        }
      }
      var subunitsBox = renderSubunitBox("Subunits", ligandInfo.ligandSubunits);
      var heteromersBox =
        renderSubunitBox("Is a component of", ligandInfo.ligandHeteromers);

      var structureBox = {
        switch (ligandInfo.ligandStructure) {
          case Nothing -> MvuHTML.empty
            case Just(struct) ->
              fun renderRow((k, v)) {
                tr(class("info"),
                  td(style("text-align:left; min-width:250px;max-width:250px;width:250px;"),
                    textNode(k)) +*
                  td(style("text-align:left;"),
                    textNode(v)))
              }

              var rows = [
                ("Canonical SMILES", struct.canonicalSmiles),
                ("Isomeric SMILES", struct.isomericSmiles),
                ("InChI standard identifier", struct.inchiStandardID),
                ("InChI standard key", struct.inchiStandardKey)
              ];

              var renderedRows = MvuHTML.concatMap(renderRow, rows);

              table_(class("receptor_data_tables") +@ style("width:100%;"),
                tr(a0,
                  td(class("category") +@ colSpan(2), textNode("Download 2D Structure"))) +*
                renderedRows)
        }
      };

      var peptideStructureBox = {
        fun renderIfNonempty(text) {
          if (text == "") {
            MvuHTML.empty
          } else {
            tr(class("info"),
              td(style("text-align:left;"), textNode(text)))
          }
        }

        switch (ligandInfo.ligandPeptideInfo) {
          case Nothing -> MvuHTML.empty
          case Just(pi) ->
            var content =
              if (pi.peptideOneLetterSeq <> "" || pi.peptideThreeLetterSeq <> "") {
                renderIfNonempty(pi.peptideOneLetterSeq) +*
                renderIfNonempty(pi.peptideThreeLetterSeq)
              } else {
                tr(class("info"),
                  td(style("text-align:left;"), textNode("No information available.")))
              };

            table_(class("receptor_data_tables") +@ style("width:100%;"),
                tr(a0,
                  td(class("category") +@ colSpan(2), textNode("Peptide Sequence"))) +*
                content)
        }
      };

      var peptideStructureCommentsBox = {
        switch (ligandInfo.ligandPeptideInfo) {
          case Nothing -> MvuHTML.empty
          case Just(pi) ->
            renderBoxIfNonempty("Post-translational Modification",
                pi.peptidePostTranslationalModifications) +*
            renderBoxIfNonempty("Chemical Modification",
                pi.peptideChemicalModifications)
        }
      };

      var pdbStructureBox = {
        # 30: ID of PDB
        var pdb =
          filter(fun(x) { x.dbID == 30 }, ligandInfo.ligandDBLinks);
        var pdbIDs =
          switch(pdb) {
            case [] -> []
            case x :: _ -> map(fun((_, placeholder, _)) { placeholder }, x.dbEntries)
          };

        if (listEmpty(pdbIDs)) {
          MvuHTML.empty
        } else {

          fun render(strID) {
            var link = "https://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=" ^^ strID;
            td(align("center") +@ valign("center"),
                textNode("PDB Id: ") +*
                a(href(link), unescapedTextNode(strID)) +*
                br(a0, h0) +*
                a(style("color:white;") +@ href(link),
                  img(src("https://www.rcsb.org/pdb/images/" ^^ strID ^^ "_bio_r_500.jpg") +@
                    height("150") +@ width("150"), h0)))
          }

          var rendered = MvuHTML.concatMap(render, pdbIDs);

          table_(class("receptor_data_tables") +@ style("width:100%"),
              tr(name("hotspot") +@ class("hotspot"),
                td(class("category") +@ colSpan(2), textNode("Selected 3D Structures"))) +*
              tr(class("info") +@ align("left") +@ valign("center") +@ colSpan(2),
                table_(a0,
                  tr(a0, rendered))))
        }
      };

      subunitsBox +*
      heteromersBox +*
      peptideStructureBox +*
      peptideStructureCommentsBox +*
      pdbStructureBox +*
      structureBox
    };

    fun similarLigandsGrid(header, ligands) {
      fun renderLigand(l) {
        var targets = {
          if (listEmpty(l.targets)) {
            MvuHTML.empty
          } else {
            var renderedLinks =
              MvuHTML.concat(join([textNode("; ")],
                    map(fun(x) { [
                      a(href("/objectDisplay?objectId=" ^^ intToString(x.id)),
                          unescapedTextNode(x.name))
                    ] }, l.targets)));
            tr(a0,
              td(style("text-align:left vertical-align:top; font-size:85%;"),
                h6(class("target_summary_header"), textNode("Targets")))) +*
            tr(a0,
              td(style("text-align:left; vertical-align:top; font-size:85%;"),
                renderedLinks))
          }
        };

        td(style("height:100%; text-align:center;") +@ colSpan(1),
            table_(width("375px") +@ height("100%"),
              tbody(a0,
                # Name
                tr(a0,
                  td(style("text-align:center; vertical-align:top; font-size:95%;"),
                    a(href("/ligandDisplay?ligandId=" ^^ intToString(l.id)),
                      unescapedTextNode(l.name)))) +*
                # Image
                tr(a0,
                  td(style("text-align:center; vertical-align:top;"),
                    a(style("color:white;") +@ href("/ligandDisplay?ligandId=" ^^ intToString(l.id)),
                      img(src("https://www.guidetopharmacology.org/CHEMSTRUCT/iuphar/" ^^ strId ^^ ".gif") +@
                        height("250px") +@ width("250px"), h0)))) +*
                # Targets (header, if targets present)
                # List of targets
                targets)))

      }

      fun renderLigands(ls) {
        switch(ls) {
          case [] -> MvuHTML.empty
          case [x] -> tr(class("info"), renderLigand(x))
          case x :: y :: xs ->
            tr(class("info"),
                renderLigand(x) +* renderLigand(y)) +* renderLigands(xs)
        }
      }
      var renderedRows = renderLigands(ligands);
      # TODO: Probably want to have the various targets displaying here, too.
      table_(class("receptor_data_tables") +@ style("width:100%"),
          tbody(a0,
            tr(a0,
              td(class("category") +@
                style("text-align:left;border-style:solid none solid solid;") +@
                colSpan(2), textNode(header))) +*
            renderedRows))

    }

    # Tables, used instead of the grid layout when displaying data for peptides
    fun similarLigandsTable(header, ligands) {
      if (listEmpty(ligands)) {
        MvuHTML.empty
      } else {
        fun renderRow(x) {
          var targetLinks =
            MvuHTML.concat(join([textNode("; ")], map(fun(y) {
                    [a(href("/ligandDisplay?ligandId=" ^^ intToString(y.id)), unescapedTextNode(y.name))]
                  }, uniquify(x.targets))));

          var targets =
            if (listEmpty(x.targets)) {
              MvuHTML.empty
            } else {
              span(class("embedded_link") +@ style("font-size: 85%;"),
                h6(class("target_summary_header"), textNode("Targets")) +*
                targetLinks)
            };

          tr(class("info"), 
            td(a0,
              a(href("/ligandDisplay?ligandId=" ^^ intToString(x.id)), unescapedTextNode(x.name))) +*
            td(style("font-size:85%"), targets))
        }

        var renderedRows = MvuHTML.concatMap(renderRow, ligands);

        table_(class("receptor_data_tables") +@ style("width:100%"),
            tbody(a0,
              tr(a0,
                td(class("category") +@
                  style("text-align:left;border-style:solid none solid solid;") +@
                  colSpan(2),
                  textNode(header))) +*
              renderedRows))
      }
    }

    fun similarLigandsClusteredTable(header, ligands) {
      if (listEmpty(ligands)) {
        MvuHTML.empty
      } else {
        fun renderRow(x) {
          var targetLinks =
            MvuHTML.concat(join([textNode("; ")], map(fun(y) {
                    [a(href("/ligandDisplay?ligandId=" ^^ intToString(y.id)), unescapedTextNode(y.name))]
                  }, uniquify(x.targets))));

          var targets =
            if (listEmpty(x.targets)) {
              MvuHTML.empty
            } else {
              span(class("embedded_link") +@ style("font-size: 85%;"),
                h6(class("target_summary_header"), textNode("Targets")) +*
                targetLinks)
            };

          tr(class("info"),
            td(class("embedded_link") +@
                style("text-align:left; vertical-align: top; border-style:solid none solid solid;"),
                a(href("/ligandDisplay?ligandId=" ^^ intToString(x.id)),
                  unescapedTextNode(x.name)) +*
                br(a0, h0) +*
                br(a0, h0) +*
                targets) +*
            td(style("text-align:right; vertical-align: top; border-style: solid solid solid none;"),
              a(style("color:white;") +@ href("/ligandDisplay?ligandId=" ^^ intToString(x.id)),
                img(src("https://www.guidetopharmacology.org/CHEMSTRUCT/iuphar/" ^^ strId ^^ ".gif"), h0))))
        }

        var renderedRows = MvuHTML.concatMap(renderRow, ligands);

        table_(class("receptor_data_tables") +@ style("width:100%"),
            tbody(a0,
              tr(a0,
                td(class("category") +@
                  style("text-align:left;border-style:solid none solid solid;") +@
                  colSpan(2),
                  textNode(header))) +*
              renderedRows))
      }
    }


    var similarLigandsPage = {
      if (ligandInfo.ligandType == "Peptide" || ligandInfo.ligandType == "Antibody") {
        var lcs = ligandInfo.ligandClusters;
        similarLigandsTable("Related Sequences", lcs.peptide_related_ligands) +*
        similarLigandsTable("Other Similar Sequences",
            lcs.peptide_ligand_sequence_clusters) +*
        similarLigandsClusteredTable("Structurally Similar Ligands",
            uniquify(lcs.clusters ++ lcs.peptide_ligand_clusters))
      } else {
        similarLigandsGrid("Similar Ligands", ligandInfo.ligandClusters.clusters)
      }
    };

    var analoguesPage = {
      similarLigandsGrid("Other Isotopes/Labelled or Unlabelled Forms",
          ligandInfo.ligandClusters.analogue_clusters)
    };

    var immunoPage = {
      var immunoCommentBox = {
        var immunoComments = ligandInfo.ligandComments.immunoComments;
        if (not(markupEmpty(immunoComments))) {
          table_(id("immuno") +@ class("receptor_data_tables") +@ style("width:100%"),
            tr(a0,
              td(class("category_immuno"), textNode("Immunopharmacology Comments"))) +*
            tr(class("info"),
              td(a0, renderM(immunoComments))))
        } else {
          MvuHTML.empty
        }
      };

      var immunoDiseasesBox = {
        var immunoDiseases = ligandInfo.ligandImmunoDiseases;
        if (listEmpty(immunoDiseases)) {
          MvuHTML.empty
        } else {

          fun renderRow(row) {
            fun renderXRef(ref) {
              p(a0,
                textNode(ref.dbName ^^ ": ") +*
                a(href(ref.url), textNode(ref.displayID)))
            }

            var renderedXRefs = MvuHTML.concatMap(renderXRef, row.immunoDiseaseXRefs);

            tr(class("info"),
              td(a0,
                a(href("/diseaseDisplay?diseaseId=" ^^ intToString(row.immunoDiseaseID)),
                  textNode(row.immunoDiseaseName))) +*
              td(a0, renderedXRefs) +*
              td(a0, renderM(row.immunoDiseaseComments)) +*
              td(a0, renderCitationList(row.immunoDiseaseReferences, ligandInfo.ligandReferences)))
          }
          var renderedRows = MvuHTML.concatMap(renderRow, ligandInfo.ligandImmunoDiseases);

          table_(class("receptor_data_tables") +@ style("width:100%;"),
              tr(a0,
                td(class("category_immuno") +@ colSpan(4),
                  textNode("Immunopharmacology Disease"))) +*
              tr(a0,
                td(class("heading"), textNode("Disease")) +*
                td(class("heading") +@ style("width:200px;"), textNode("X-Refs")) +*
                td(class("heading") +@ style("width:400px;"), textNode("Comment")) +*
                td(class("heading") +@ style("width:100px;"), textNode("References"))) +*
              renderedRows)
        }
      };

      var immunoCasesBox = {
        fun renderRow(x) {
          tr(class("info"),
            td(a0, a(href(x.url), textNode(x.title))))
        }

        var immunoCases = ligandInfo.ligandImmunopaediaCases;
        var renderedRows = MvuHTML.concatMap(renderRow, immunoCases);
        if (not(listEmpty(immunoCases))) {
          table_(class("receptor_data_tables") +@ style("width:100%"),
            tr(a0,
              td(class("category_immuno"),
                textNode("Immunopaedia Case Studies Links"))) +*
            renderedRows)
        } else {
          MvuHTML.empty
        }
      };

      immunoCommentBox +*
      immunoDiseasesBox +*
      immunoCasesBox
    };

    var malariaPage = {
      var malariaComments = ligandInfo.ligandComments.malariaComments;
      if (markupEmpty(malariaComments) && listEmpty(ligandInfo.ligandTCPs)) {
        table_(class("receptor_data_tables") +@ style("width:100%"),
          tr(a0,
            td(a0,
              b(a0, renderM(ligandInfo.ligandName)) +*
              textNode(" has been tagged as relevant to malaria") +*
              textNode(" pharmacology and is awaiting detailed") +*
              textNode(" curation for the Guide to MALARIA PHARMACOLOGY"))))
      } else {
        var malaria_comments =
          table_(id("malaria") +@ class("receptor_data_tables") +@ style("width:100%"),
            tr(a0,
              td(class("category_gtmp"), textNode("Guide to Malaria Pharmacology Comments"))) +*
            tr(class("info"),
              td(a0, renderM(malariaComments))));

        var tcps = {
          fun renderRow(tcp) {
            tr(class("info"),
              td(a0, renderM(tcp.tcpProfile)) +*
              td(a0, renderM(tcp.tcpIntendedUse)) +*
              td(a0, renderM(tcp.tcpTargetStage)) +*
              td(a0, renderM(tcp.tcpComment)) +*
              td(a0, renderCitations(tcp.tcpReferences)))
          }

          if (listEmpty(ligandInfo.ligandTCPs)) {
            MvuHTML.empty
          } else {
            var header = {
              tr(a0,
                  td(class("heading"), textNode("Profile")) +*
                  td(class("heading") +@ style("width:100px;"), textNode("Intended Use")) +*
                  td(class("heading") +@ style("width:100px;"), textNode("Profile")) +*
                  td(class("heading") +@ style("width:400px;"), textNode("Comment")) +*
                  td(class("heading") +@ style("width:100px;"), textNode("References")))
            };
            var renderedRows = MvuHTML.concatMap(renderRow, ligandInfo.ligandTCPs);
            table_(class("receptor_data_tables") +@ style("width:100%;"),
                tbody(a0,
                  tr(a0,
                    td(class("category_gtmp") +@ colSpan(5),
                      textNode("Target Candidate Profiles"))) +*
                  header +* renderedRows))
          }
        };

        malaria_comments +* tcps
      }
    };

    var tabBox = {
      # TODO: This needs to be tightened up
      var showBioActivity = true;
      var showClinicalData = {
        var comments = ligandInfo.ligandComments;
        var urls = ligandInfo.ligandURLs;
        not(
            markupEmpty(comments.absorptionDistributionComments) &&
            markupEmpty(comments.metabolismComments) &&
            markupEmpty(comments.eliminationComments) &&
            markupEmpty(comments.popnPharmacokineticsComments) &&
            markupEmpty(comments.organFunctionImpairmentComments) &&
            markupEmpty(comments.clinicalUseComments) &&
            markupEmpty(comments.mechanismOfActionComments) &&
            urls.drugsURL == "" && urls.emaURL == "" && urls.emcURL == "")
      };
      var showReferences = not(listEmpty(ligandInfo.ligandReferences));
      var showStructure = {

        var subunitsEmpty = listEmpty(ligandInfo.ligandSubunits);
        var heteromersEmpty = listEmpty(ligandInfo.ligandHeteromers);
        var structureEmpty = not(isJust(ligandInfo.ligandStructure));
        var peptideStructureEmpty = {
          switch (ligandInfo.ligandPeptideInfo) {
            case Just(pi) -> pi.peptideOneLetterSeq == "" && pi.peptideThreeLetterSeq == ""
            case Nothing -> true
          }
        };
        var peptideStructureCommentsEmpty = {
          switch (ligandInfo.ligandPeptideInfo) {
            case Just(pi) ->
              markupEmpty(pi.peptidePostTranslationalModifications) &&
              markupEmpty(pi.peptideChemicalModifications)
            case Nothing -> true
          }
        };

        not(subunitsEmpty &&
          heteromersEmpty &&
          structureEmpty &&
          peptideStructureEmpty &&
          peptideStructureCommentsEmpty)
      };
      var ls = ligandInfo.ligandClusters;
      var showSimilarLigands =
        not(ls.oldClusterCount < 1 &&
            # listEmpty(ls.clusters) &&
            listEmpty(ls.peptide_ligand_clusters) &&
            listEmpty(ls.peptide_ligand_sequence_clusters) &&
            listEmpty(ls.peptide_related_ligands));
      var showAnalogues = not(listEmpty(ls.analogue_clusters));
      var showImmuno = ligandInfo.ligandImmuno;
      var showMalaria = ligandInfo.ligandMalaria;
      var tabs = [
        ("Summary", Summary, true),
        ("Biological activity", BiologicalActivity, showBioActivity),
        ("Clinical data", ClinicalData, showClinicalData),
        ("References", References, showReferences),
        ("Structure", Structure, showStructure),
        ("Similar ligands", SimilarLigands, showSimilarLigands),
        ("(Un)labelled forms", Analogues, showAnalogues),
        ("Immunopharmacology", Immuno, showImmuno),
        ("Malaria", Malaria, showMalaria)
      ];

      fun renderTab((name, filter, show)) {
        var attr =
          if (filter == model.modelTab) {
            class("active")
          } else {
            MvuAttrs.empty
          };
        if (show) {
          li(attr,
            a(href("#") +@ onClick(fun() { ChangeTab(filter) }), textNode(name)))
        } else {
          MvuHTML.empty
        }
      }

      var renderedTabs = MvuHTML.concatMap(renderTab, tabs);

      var content =
        switch(model.modelTab) {
          case Summary -> summaryPage
          case BiologicalActivity -> biologicalActivityPage
          case ClinicalData -> clinicalDataPage
          case References -> referencesPage
          case Structure -> structurePage
          case SimilarLigands -> similarLigandsPage
          case Analogues -> analoguesPage
          case Immuno -> immunoPage
          case Malaria -> malariaPage
        };

      div(class("grid_16 alpha"),
        div(class("contentboxfullhelp"),
          div(id("cssmenu"),
            ul(a0, renderedTabs)) +*
          div(class("clear"), h0) +*
          div(class("data_tables_container") +@ style("padding-top:10px; padding-bottom: 10px;"),
            content)))
    };

    basicInfoBox +*
    structuralInfoBox +*
    tabBox

  }

  switch(model) {
    case Just(model) -> viewModel(model)
    case Nothing -> textNode("Invalid Ligand ID")
  }
}

fun mainPage() {
  var initialModel = getInitialModel();
  Mvu.runSimple("vdom_placeholder", initialModel, view, updt);
  template("Ligand Display")
}

