import Tables;
import Template;
import Mvu;
import MvuHTML;
import MvuAttrs;
import Species;
import InteractionUtilities;
open import Utility;

# STILL TO DO:
#  - Malaria pharmacology
#  - Inserting from scratch
#  - Adding new interactions
#  - References

typename InteractionID = Int;
typename ReferenceID = Int;
typename MalariaStageID = Int;


# Affinity values are stored in the database as floats.  We can't modify the
# model directly as we do with other fields since it's perfectly reasonable to
# have the model in an inconsistent state during editing. We should only
# validate when submitting.
typename AffinityType = [| AffinityLog | AffinityVoltage | AffinityOriginal |];
typename AffinityBox = [| Low | Median | High |];

typename AffinityValues =
  (logHigh: String, logMedian: String, logLow: String,
   avHigh: String, avMedian: String, avLow: String,
   origHigh: String, origMedian: String, origLow: String,
   rank:String, percentActivity:String
  );

fun mkAffinityValues(int) {
  # Hack, since we can't currently distinguish between nulls and 0.0.
  # This means "0.0" won't display if it's set as such in the DB --
  # but it's a slightly better alternative than having "Infinity" pop up
  # all over the place when calculating logarithms.
  fun f2s(f) { if (f == 0.0) { "" } else { floatToString(f) } }
  (logHigh = f2s(int.affinity_high), logMedian = f2s(int.affinity_median),
   logLow = f2s(int.affinity_low), avHigh = f2s(int.affinity_voltage_high),
   avMedian = f2s(int.affinity_voltage_median), avLow = f2s(int.affinity_voltage_low),
   origHigh = f2s(int.original_affinity_high_nm),
   origMedian = f2s(int.original_affinity_median_nm),
   origLow = f2s(int.original_affinity_low_nm),
   rank = intToString(int.rank),
   percentActivity = f2s(int.percent_activity))
}

typename InteractionInfo =
  (interaction: Tables.DbInteraction,
   ligand: Tables.RawLigand,
   malariaStages: [MalariaStageID],
   references: [ReferenceID]);

typename EditingInfo =
  (interactionInfo: InteractionInfo,
   affinityValues: AffinityValues,
   selectedMalariaStage: MalariaStageID);

typename Error = String;

typename Model =
  Maybe((
      object: Tables.RawObject,
      receptorBasic: Maybe(Tables.DbReceptorBasic),
      ligands: [(ligand_id: Int, name: String)],
      malariaStages: [Tables.DbMalariaStage],
      interactions: [InteractionInfo],
      currentInteraction: Maybe(EditingInfo),
      references: [Tables.DbReference],
      speciesMap: Species.SpeciesMap,
      errors: [Error],
      submit: (Maybe(Tables.DbReceptorBasic), [InteractionInfo]) {}~> ()
  ));


typename CommentType =
  [| Activators | GatingInhibitors | Agonists | ChannelBlockers
   | Antagonists | AllostericModulators | SubunitSpecific | Inhibitors
   | Antibodies
  |];


var commentTypes =
  [ Activators, GatingInhibitors, Agonists, ChannelBlockers,
    Antagonists, AllostericModulators, SubunitSpecific, Inhibitors,
    Antibodies ];

# My kingdom for "deriving Show"
fun showCommentType(ct) {
  switch(ct) {
    case Activators -> "Activators"
    case GatingInhibitors -> "Gating Inhibitors"
    case Agonists -> "Agonists"
    case ChannelBlockers -> "Channel Blockers"
    case Antagonists -> "Antagonists"
    case AllostericModulators -> "Allosteric Modulators"
    case SubunitSpecific -> "Subunit Specific"
    case Inhibitors -> "Inhibitors"
    case Antibodies -> "Antibodies"
  }
}

typename DisplayOption = [| ShowInConcise | OnlyInConcise | Hide |];

typename Field =
  [| LigandContext | ReceptorSite | ActionComment | AssayDescription
   | AssayConditions | AssayURL | ConcentrationRange |];

typename InteractionProperty =
  [| Endogenous | UseDependent | VoltageDependent
   | PrimaryTarget | WholeOrganismAssay |];

typename Message =
  [| UpdateComment:(CommentType, String)
   | UpdateField:(Field, String)
   | EditInteraction:InteractionInfo | DeleteInteraction:InteractionID
   | SubmitCurrentInteraction | CancelCurrentInteraction | DeleteCurrentInteraction
   | ChangeDisplayOption:(DisplayOption, Bool)
   | ChangeSpeciesID:Int | ChangeInteractionType:String
   | ChangeAction:String | ChangeSelectivity:String
   | ChangeInteractionProperty:(InteractionProperty, Bool)
   | ChangeAffinity:(AffinityType, AffinityBox, String)
   | ChangePercentActivity:String
   | ChangeRank:String
   | SetPhysiologicalVoltage:Bool
   | ChangeOriginalAffinityUnits:String
   | ChangeOriginalAffinityRelation:String
   | CalculateLogAffinity
   | ChangeMalariaStage:MalariaStageID
   | AddMalariaStage
   | DeleteMalariaStage:MalariaStageID
   | Submit | Cancel |];

fun emptyInteraction(objectID) {
  (interaction_id = (-1),
   ligand_id = (-1),
   object_id = objectID,
   type = "None",
   action = "None",
   action_comment = "",
   species_id = (-1), # TODO: This should default to something...
   endogenous = false,
   selective = false,
   use_dependent = false,
   voltage_dependent = false,
   affinity_units = "-",
   affinity_high = 0.0,
   affinity_median = 0.0,
   affinity_low = 0.0,
   concentration_range = "",
   affinity_voltage_high = 0.0,
   affinity_voltage_median = 0.0,
   affinity_voltage_low = 0.0,
   affinity_physiological_voltage = false,
   rank= (-1),
   selectivity = "",
   original_affinity_low_nm = 0.0,
   original_affinity_median_nm = 0.0,
   original_affinity_high_nm = 0.0,
   original_affinity_units = "",
   original_affinity_relation = "",
   assay_description = "",
   assay_conditions = "",
   from_grac = false,
   only_grac = false,
   receptor_site = "",
   ligand_context = "",
   percent_activity = 0.0,
   assay_url = "",
   primary_target = false,
   target_ligand_id= (-1),
   whole_organism_assay = false,
   hide = false)
}

fun emptyInteractionInfo(objectID, ligand) {
  (interaction = emptyInteraction(objectID),
   =ligand,
   malariaStages = [],
   references = [])
}


sig commit: (Int, (Maybe(Tables.DbReceptorBasic), [InteractionInfo]), (Maybe(Tables.DbReceptorBasic), [InteractionInfo])) {}~> ()
fun commit(objectID, oldInfo, newInfo) server {
  var (oldComments, oldInteractions) = oldInfo;
  var (newComments, newInteractions) = newInfo;

  fun updateComments() {
    switch((oldComments, newComments)) {
      case (Just(oldRB), Just(newRB)) ->
        if (oldRB == newRB) {
          () # Nothing doing
        } else {
          update (rb <-- Tables.receptor_basic)
            where (rb.object_id == objectID)
            set (
              list_comments = newRB.list_comments,
              associated_proteins_comments = newRB.associated_proteins_comments,
              functional_assay_comments = newRB.functional_assay_comments,
              tissue_distribution_comments = newRB.tissue_distribution_comments,
              functions_comments = newRB.functions_comments,
              altered_expression_comments = newRB.altered_expression_comments,
              expression_pathophysiology_comments = newRB.expression_pathophysiology_comments,
              mutations_pathophysiology_comments = newRB.mutations_pathophysiology_comments,
              variants_comments = newRB.variants_comments,
              xenobiotic_expression_comments = newRB.xenobiotic_expression_comments,
              antibody_comments = newRB.antibody_comments,
              agonists_comments = newRB.agonists_comments,
              antagonists_comments = newRB.antagonists_comments,
              allosteric_modulators_comments = newRB.allosteric_modulators_comments,
              activators_comments = newRB.activators_comments,
              inhibitors_comments = newRB.inhibitors_comments,
              channel_blockers_comments = newRB.channel_blockers_comments,
              gating_inhibitors_comments = newRB.gating_inhibitors_comments)
        }
      case _ ->
        # Just(old), Nothing; Nothing, Just(new) are impossible
        # due to the way the UI is set up, so ignore them.
        ()
    }
  }

  fun updateInteractions() {
    var (toInsert, toUpdate) =
      partition(fun(i) { i.interaction.interaction_id < 0 }, newInteractions);

    # Diff: toUpdate will have all negative IDs removed. This is unproblematic.
    # Assumptions:
    #   - interaction_ids increase monotonically (Postgres guarantees this).
    #   - interaction_ids not changed by the application
    # So, if we sort both lists by ID, we will have the following situations:
    #   new, old have same ID: zip and add to appropriate list
    #   new, old have different IDs: "old" has been deleted, add to deleted list
    fun diff(oldI, newI) {
      fun go(oldI, newI, modified, unmodified, deleted) {
        switch ((oldI, newI)) {
          case ([], []) -> (modified, unmodified, deleted)
          case ([], _) ->
            # Should not happen; any newIs should have negative IDs and thus be
            # in the "inserted" list
            error("Non-empty newI list")
          case (olds, []) ->
            # Olds not in list, so should be deleted
            (modified, unmodified, deleted ++ olds)
          case (x::xs, y::ys) ->
            if (x.interaction.interaction_id == y.interaction.interaction_id) {
              if (x == y) {
                go(xs, ys, modified, (x, y) :: unmodified, deleted)
              } else {
                go(xs, ys, (x, y) :: modified, unmodified, deleted)
              }
            } else {
              go(xs, y::ys, modified, unmodified, x :: deleted)
            }
        }
      }
      go(oldI, newI, [], [], [])
    }


    var sortedOld = sortBy(fun(x) { x.interaction.interaction_id }, oldInteractions);
    var sortedNew = sortBy(fun(x) { x.interaction.interaction_id }, newInteractions);
    var (modified, unmodified, deleted) = diff(oldInteractions, newInteractions);

    print("Diffed. Doing updates...\n");
    # Now perform the updates
    iter(fun((oldI, newI)) {

       # Alas -- We can't do this yet, since the we cannot abstract over the
       # `values` field since field sets are not first-class

       # fun updateIntLists(interaction, oldL, newL, tbl, project, mkRow) {
       #  if (oldL <> newL) {
       #    var interactionID = interaction.interaction_id;
       #    var toDelete = filter(fun(x) { not(elem(x, newL)) }, oldL);
       #    var toInsert = filter(fun(x) { not(elem(x, oldL)) }, newL);

       #    var pred = contains(toDelete);

       #    delete (x <-- tbl)
       #      where (x.interaction_id == interactionID && pred(project(x)));

       #    iter(fun(x) {
       #      insert Tables.interaction_affinity_refs
       #      values (mkRow(interactionID, x))
       #    }, toInsert);

       #  } else { () };
       #}

      if (oldI.interaction <> newI.interaction) {
        print("Before update...\n");

        update (i <-- Tables.interaction)
          where (i.interaction_id == newI.interaction.interaction_id)
          set (
            ligand_id = newI.interaction.ligand_id, object_id = newI.interaction.object_id,
            type = newI.interaction.type, action = newI.interaction.action,
            action_comment = newI.interaction.action_comment, species_id = newI.interaction.species_id,
            endogenous = newI.interaction.endogenous, selective = newI.interaction.selective,
            use_dependent = newI.interaction.use_dependent,
            voltage_dependent = newI.interaction.voltage_dependent,
            affinity_units = newI.interaction.affinity_units,
            affinity_high = newI.interaction.affinity_high,
            affinity_median = newI.interaction.affinity_median,
            affinity_low = newI.interaction.affinity_low,
            concentration_range = newI.interaction.concentration_range,
            affinity_voltage_high = newI.interaction.affinity_voltage_high,
            affinity_voltage_median = newI.interaction.affinity_voltage_median,
            affinity_voltage_low = newI.interaction.affinity_voltage_low,
            affinity_physiological_voltage = newI.interaction.affinity_physiological_voltage,
            rank = newI.interaction.rank, selectivity = newI.interaction.selectivity,
            original_affinity_low_nm = newI.interaction.original_affinity_low_nm,
            original_affinity_median_nm = newI.interaction.original_affinity_median_nm,
            original_affinity_high_nm = newI.interaction.original_affinity_high_nm,
            original_affinity_units = newI.interaction.original_affinity_units,
            original_affinity_relation = newI.interaction.original_affinity_relation,
            assay_description = newI.interaction.assay_description,
            assay_conditions = newI.interaction.assay_conditions,
            from_grac = newI.interaction.from_grac, only_grac = newI.interaction.only_grac,
            receptor_site = newI.interaction.receptor_site,
            ligand_context = newI.interaction.ligand_context,
            percent_activity = newI.interaction.percent_activity,
            assay_url = newI.interaction.assay_url, primary_target = newI.interaction.primary_target,
            # target_ligand_id = newI.interaction.target_ligand_id,
            whole_organism_assay = newI.interaction.whole_organism_assay,
            hide = newI.interaction.hide);
        print("After update...\n")
      } else { print("Not updating\n") };

      print("Before updating refs\n");
   #  # Update affinity references
   #  updateIntLists(newI.interaction, oldI.references, newI.references, Tables.interaction_affinity_refs,
   #      fun(x) { x.reference_id },
   #      fun(x) { (interaction_id = newI.interaction.interaction_id, reference_id = x) });
   #  # Update malaria stages
   #  updateIntLists(newI.interaction, oldI.malariaStages, newI.malariaStages, Tables.malaria_stage2interaction,
   #      fun(x) { x.malaria_stage_id },
   #      fun(x) { (interaction_id = newI.interaction.interaction_id, malaria_stage_id = x) });

      # A bit more repetitive than I'd like, since we can't abstract over insert statements right now.
      # (See above for what I'd like to have written)
      var interactionID = newI.interaction.interaction_id;
      if (oldI.references <> newI.references) {
        var toDelete = filter(fun(x) { not(elem(x, newI.references)) }, oldI.references);
        var toInsert = filter(fun(x) { not(elem(x, oldI.references)) }, newI.references);

        var pred = contains(toDelete);

        delete (iar <-- Tables.interaction_affinity_refs)
          where (iar.interaction_id == interactionID && pred(iar.reference_id));

        var insertRecords =
          map(fun(x) { (interaction_id = interactionID, reference_id = x) }, toInsert);

        insert Tables.interaction_affinity_refs
          values (interaction_id, reference_id)
          insertRecords
      } else { () };

      if (oldI.malariaStages <> newI.malariaStages) {
        var toDelete = filter(fun(x) { not(elem(x, newI.malariaStages)) }, oldI.malariaStages);
        var toInsert = filter(fun(x) { not(elem(x, oldI.malariaStages)) }, newI.malariaStages);

        var pred = contains(toDelete);

        delete (ms2i<-- Tables.malaria_stage2interaction)
          where (ms2i.interaction_id == interactionID && pred(ms2i.malaria_stage_id));

        var insertRecords =
          map(fun(x) { (interaction_id = interactionID, malaria_stage_id = x) }, toInsert);

        insert Tables.malaria_stage2interaction
          values (interaction_id, malaria_stage_id)
          insertRecords

      } else { () };
      print("After updating refs\n");

    }, modified);


    print("Updated. Doing deletions...\n");

    ## Do the deletions
    var pred = contains(map(fun(x) { x.interaction.interaction_id }, deleted));
    delete (iar <-- Tables.interaction_affinity_refs)
      where (pred(iar.interaction_id));
    delete (ms2i <-- Tables.malaria_stage2interaction)
      where (pred(ms2i.interaction_id));
    delete (i <-- Tables.interaction)
      where (pred(i.interaction_id));

    print("Deleted. Doing insertions...\n");

    ## And finally do the insertions
    iter(fun(i) {
      # First, insert new record
      var interactionID =
        insert Tables.interaction
        values [
          (ligand_id = i.interaction.ligand_id, object_id = i.interaction.object_id,
            type = i.interaction.type, action = i.interaction.action,
            action_comment = i.interaction.action_comment, species_id = i.interaction.species_id,
            endogenous = i.interaction.endogenous, selective = i.interaction.selective,
            use_dependent = i.interaction.use_dependent,
            voltage_dependent = i.interaction.voltage_dependent,
            affinity_units = i.interaction.affinity_units,
            affinity_high = i.interaction.affinity_high,
            affinity_median = i.interaction.affinity_median,
            affinity_low = i.interaction.affinity_low,
            concentration_range = i.interaction.concentration_range,
            affinity_voltage_high = i.interaction.affinity_voltage_high,
            affinity_voltage_median = i.interaction.affinity_voltage_median,
            affinity_voltage_low = i.interaction.affinity_voltage_low,
            affinity_physiological_voltage = i.interaction.affinity_physiological_voltage,
            rank = i.interaction.rank, selectivity = i.interaction.selectivity,
            original_affinity_low_nm = i.interaction.original_affinity_low_nm,
            original_affinity_median_nm = i.interaction.original_affinity_median_nm,
            original_affinity_high_nm = i.interaction.original_affinity_high_nm,
            original_affinity_units = i.interaction.original_affinity_units,
            original_affinity_relation = i.interaction.original_affinity_relation,
            assay_description = i.interaction.assay_description,
            assay_conditions = i.interaction.assay_conditions,
            from_grac = i.interaction.from_grac, only_grac = i.interaction.only_grac,
            receptor_site = i.interaction.receptor_site,
            ligand_context = i.interaction.ligand_context,
            percent_activity = i.interaction.percent_activity,
            assay_url = i.interaction.assay_url, primary_target = i.interaction.primary_target,
            # target_ligand_id = i.interaction.target_ligand_id,
            whole_organism_assay = i.interaction.whole_organism_assay,
            hide = i.interaction.hide)]
        returning interaction_id;
      # Next, insert all references using new interaction ID
      #var newRefs =
      #  map(fun(r) { (r with interaction_id = interactionID) }, newI.references);
      iter(fun(r) {
        insert Tables.interaction_affinity_refs
        values [(interaction_id = interactionID, reference_id = r)]
      }, i.references);
    }, toInsert);
    print("Done!\n")

   #print("Zipped: " ^^ show(zipped));
   #print("\n\n\n ---- \n\n\n");
   #print("Deleted: " ^^ show(deleted));
   #()
  }

  updateComments();
  updateInteractions()
}

fun getInitialModel(objectID) {
  var object =
    query {
      for (o <-- Tables.object)
        where (o.object_id == objectID)
        [(obj = o,
          rbs =
            for (rb <-- Tables.receptor_basic)
              where (rb.object_id == objectID)
              [rb],
          interactions =
            for (i <-- Tables.interaction)
              where (i.object_id == objectID)
              for (l <-- Tables.ligand)
              where (l.ligand_id == i.ligand_id)
              [(interaction = i,
                ligand = l,
                malariaStages =
                  for (ms2i <-- Tables.malaria_stage2interaction)
                    where (ms2i.interaction_id == i.interaction_id)
                    [ms2i.malaria_stage_id],
                references =
                  for (iar <-- Tables.interaction_affinity_refs)
                    where (iar.interaction_id == i.interaction_id)
                    [iar.reference_id])
              ])
        ]
    };

  switch (object) {
    case [] -> Nothing
    case x :: _ ->
      # TODO: Unfortunately this blows the stack. And is slow. Alas.
      # We might have to have a user-unfriendly "enter a ligand ID" for now...
      var allLigands = [];
      #query {
      #  for (l <-- Tables.ligand)
      #    [(ligand_id = l.ligand_id, name = l.name)]
      #};

      var allReferences = [];
       #query {
       #  for (r <-- Tables.reference)
       #    [r]
       #};

      var allMalariaStages =
        query {
          for (ms <-- Tables.malaria_stage)
            [ms]
        };

      var rb =
        switch(x.rbs) {
          case [] -> Nothing
          case rb :: _ -> Just(rb)
        };

      sig submit : (Maybe(Tables.DbReceptorBasic), [InteractionInfo]) {}~> ()
      fun submit(newRb, newInteractions) {
        commit(objectID, (rb, x.interactions), (newRb, newInteractions));
        redirect("/")
      }

      Just((object = x.obj,
            ligands = allLigands,
            malariaStages = allMalariaStages,
            receptorBasic = rb,
            =submit,
            interactions = x.interactions,
            currentInteraction = Nothing,
            speciesMap = Species.getSpeciesMap(),
            errors = [],
            references = allReferences))
  }
}


sig updt : (Message, Model) {}~> Model
fun updt(msg, model) {
  fun updtModel(model) {
    fun updateComment(ty, newVal, rb) {
      switch(ty) {
        case Activators -> (rb with activators_comments = newVal)
        case GatingInhibitors -> (rb with gating_inhibitors_comments = newVal)
        case Agonists -> (rb with agonists_comments = newVal)
        case ChannelBlockers -> (rb with channel_blockers_comments = newVal)
        case Antagonists -> (rb with antagonists_comments = newVal)
        case AllostericModulators -> (rb with allosteric_modulators_comments = newVal)
        case SubunitSpecific -> rb # TODO
        case Inhibitors -> (rb with inhibitors_comments = newVal)
        case Antibodies -> (rb with antibody_comments = newVal)
      }
    }

    fun deleteInteraction(id) {
      filter(fun(x) {
          x.interaction.interaction_id <> id
      }, model.interactions)
    }

    fun updateEditInfo(f) {
      var currentInteraction =
        switch (model.currentInteraction) {
          case Just(ei) -> Just(f(ei))
          case Nothing -> Nothing
        };
      (model with =currentInteraction)
    }

    fun updateCurrentInteraction(f) {
      updateEditInfo(fun(ei) {
        (ei with interactionInfo = f(ei.interactionInfo))
      })
    }

    fun updateAffinityValues(f) {
      updateEditInfo(fun(ei) {
        (ei with affinityValues = f(ei.affinityValues))
      })
    }

    fun submitCurrentInteraction() {
      fun isValid(str) { isFloat(str) || str == "Infinity" || str == "" }
      fun isValidPA(str) {
        if (isFloat(str)) {
          var paFloat = stringToFloat(str);
          (paFloat >= 0.0) && (paFloat <= 100.0)
        } else if (str == "") { true } else { false }
      }

      fun validate(avs) {
        var conditions =
          [
           (isValid(avs.origHigh),
              "Original Affinity Value (High) must be a floating-point number"),
           (isValid(avs.origMedian),
              "Original Affinity Value (Median) must be a floating-point number"),
           (isValid(avs.origLow),
              "Original Affinity Value (Low) must be a floating-point number"),
           (isValid(avs.logHigh),
              "-log Affinity Value (High) must be a floating-point number"),
           (isValid(avs.logMedian),
              "-log Affinity Value (Median) must be a floating-point number"),
           (isValid(avs.logLow),
              "-log Affinity Value (Low) must be a floating-point number"),
           (isValid(avs.avHigh),
              "Affinity Voltage (High) must be a floating-point number"),
           (isValid(avs.avMedian),
              "Affinity Voltage (Median) must be a floating-point number"),
           (isValid(avs.avLow),
              "Affinity Voltage (Low) must be a floating-point number"),
           (isValidPA(avs.percentActivity),
              "Percentage activity must be a floating-point number between 0.0 and 100.0"),
           (isInt(avs.rank) || avs.rank == "", "Rank must be an integer")
          ];
        # Leave all errors where condition is not satisfied
        filterMap(fun((cond, err)) { if (cond) { Nothing } else { Just(err) } }, conditions)
      }

      switch(model.currentInteraction) {
        case Nothing -> model
        case Just(ei) ->
          var int = ei.interactionInfo;
          var avs = ei.affinityValues;
          var errors = validate(avs);
          var isOK = listEmpty(errors);
          # Only update interaction if no errors
          if (isOK) {
            # Now propagate the changes from AVs fields
            var interaction = int.interaction;
            fun s2f(str) { if (str == "") { 0.0 } else { stringToFloat(str) }}
            fun s2i(str) { if (str == "") { (-1) } else { stringToInt(str) }}
            var interaction =
              (interaction with
               affinity_high = s2f(avs.logHigh), affinity_median =
               s2f(avs.logMedian), affinity_low = s2f(avs.logLow),
               #
               affinity_voltage_high = s2f(avs.avHigh),
               affinity_voltage_median = s2f(avs.avMedian),
               affinity_voltage_low = s2f(avs.avLow),
               #
               original_affinity_high_nm = s2f(avs.origHigh),
               original_affinity_median_nm = s2f(avs.origMedian),
               original_affinity_low_nm = s2f(avs.origLow),
               #
               percent_activity = s2f(avs.percentActivity),
               rank = s2i(avs.rank)
               );
            var int = (int with =interaction);

            fun go(xs) {
              switch(xs) {
                case [] -> []
                case x :: xs ->
                  if (x.interaction.interaction_id == int.interaction.interaction_id) {
                    int :: xs
                  } else {
                    x :: go(xs)
                  }
              }
            }
            (model with interactions = go(model.interactions),
             currentInteraction = Nothing, errors = [])
          } else {
            redirect("#interactionEditor");
            (model with =errors)
          }
      }
    }

    fun calculateLogAffinity(avs) {
      var multiplier = 10.0 ^. (-.(9.0));
      var avs =
        if (isFloat(avs.origHigh)) {
          var affinity = stringToFloat(avs.origHigh);
          var adjusted = -. (log10(affinity *. multiplier));
          (avs with logHigh = floatToString(adjusted))
        } else { avs };
      var avs =
        if (isFloat(avs.origMedian)) {
          var affinity = stringToFloat(avs.origMedian);
          var adjusted = -. (log10(affinity *. multiplier));
          (avs with logMedian = floatToString(adjusted))
        } else { avs };

      if (isFloat(avs.origLow)) {
        var affinity = stringToFloat(avs.origLow);
        var adjusted = -. (log10(affinity *. multiplier));
        (avs with logLow = floatToString(adjusted))
      } else { avs }
    }

    switch(msg) {
      case UpdateComment(ty, newVal) ->
        switch(model.receptorBasic) {
          case Just(rb) ->
            var newRb = updateComment(ty, newVal, rb);
            (model with receptorBasic = Just(newRb))
          case Nothing -> model
        }

      case EditInteraction(interactionInfo) ->
        var affinityValues =
          mkAffinityValues(interactionInfo.interaction);
        var ei =
          (=interactionInfo, =affinityValues,
           selectedMalariaStage = hd(model.malariaStages).malaria_stage_id);
        redirect("#interactionEditor");
        (model with errors = [], currentInteraction = Just(ei))

      case SubmitCurrentInteraction ->
        submitCurrentInteraction()

      case DeleteInteraction(id) ->
        (model with interactions = deleteInteraction(id))

      case DeleteCurrentInteraction ->
        switch(model.currentInteraction) {
          case Just(ei) ->
            var int = ei.interactionInfo;
            var interactions = deleteInteraction(int.interaction.interaction_id);
            (model with =interactions, currentInteraction = Nothing)
          case Nothing -> (model with currentInteraction = Nothing)
        }

      case CancelCurrentInteraction ->
        (model with currentInteraction = Nothing)

      # Editing
      case ChangeDisplayOption(displayOption, val) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction =
            switch (displayOption) {
              case ShowInConcise -> (interaction with from_grac = val)
              case OnlyInConcise -> (interaction with only_grac = val)
              case Hide -> (interaction with hide = val)
            };
          (int with =interaction) })

      case ChangeSpeciesID(speciesID) ->
        updateCurrentInteraction(fun(int) {
            var interaction = int.interaction;
            var interaction = (interaction with species_id = speciesID);
            (int with =interaction)
        })

      case ChangeInteractionType(type) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction = (interaction with =type);
          (int with =interaction)
        })

      case ChangeAction(action) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction = (interaction with =action);
          (int with =interaction)
        })

      case ChangeSelectivity(selectivity) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction = (interaction with =selectivity);
          (int with =interaction)
        })

      case ChangeInteractionProperty(prop, val) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction =
            switch(prop) {
              case Endogenous -> (interaction with endogenous = val)
              case UseDependent -> (interaction with use_dependent = val)
              case VoltageDependent -> (interaction with voltage_dependent = val)
              case PrimaryTarget -> (interaction with primary_target = val)
              case WholeOrganismAssay -> (interaction with whole_organism_assay = val)
            };
          (int with =interaction)
        })

      case UpdateField(field, val) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction =
            switch(field) {
              case LigandContext ->
                (interaction with ligand_context = val)
              case ReceptorSite ->
                (interaction with receptor_site = val)
              case ActionComment ->
                (interaction with action_comment = val)
              case AssayDescription ->
                (interaction with assay_description = val)
              case AssayConditions ->
                (interaction with assay_conditions = val)
              case AssayURL ->
                (interaction with assay_url = val)
              case ConcentrationRange ->
                (interaction with concentration_range = val)
            };
            (int with =interaction)
        })

      case ChangeAffinity(ty, box, val) ->
        updateAffinityValues(fun(affinityValues) {
          switch ((ty, box)) {
            case (AffinityLog, Low) ->
              (affinityValues with logLow = val)
            case (AffinityLog, Median) ->
              (affinityValues with logMedian = val)
            case (AffinityLog, High) ->
              (affinityValues with logHigh = val)
            case (AffinityVoltage, Low) ->
              (affinityValues with avLow = val)
            case (AffinityVoltage, Median) ->
              (affinityValues with avMedian = val)
            case (AffinityVoltage, High) ->
              (affinityValues with avHigh = val)
            case (AffinityOriginal, Low) ->
              (affinityValues with origLow = val)
            case (AffinityOriginal, Median) ->
              (affinityValues with origMedian = val)
            case (AffinityOriginal, High) ->
              (affinityValues with origHigh = val)
          }
        })

      case ChangePercentActivity(str) ->
        updateAffinityValues(fun(avs) {
          (avs with percentActivity = str)
        })

      case SetPhysiologicalVoltage(val) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction =
            (interaction with affinity_physiological_voltage = val);
          (int with =interaction)
        })

      case ChangeOriginalAffinityUnits(val) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction =
            (interaction with original_affinity_units = val);
          (int with =interaction)
        })

      case ChangeOriginalAffinityRelation(val) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction =
            (interaction with original_affinity_relation= val);
          (int with =interaction)
        })

     #case ChangeAffinityUnits(val) ->
     #  updateCurrentInteraction(fun(int) {
     #    var interaction = int.interaction;
     #    var interaction =
     #      (interaction with affinity_units = val);
     #    (int with =interaction)
     #  })

      case ChangeRank(str) ->
        updateAffinityValues(fun(avs) {
          (avs with rank = str)
        })

      case CalculateLogAffinity ->
        updateAffinityValues(fun(avs) {
          calculateLogAffinity(avs)
        })

      case ChangeMalariaStage(id) ->
        updateEditInfo(fun(ei) {
          (ei with selectedMalariaStage = id)
        })

      case AddMalariaStage ->
        updateEditInfo(fun(ei) {
          var int = ei.interactionInfo;
          var id = ei.selectedMalariaStage;
          if (not(elem(id, int.malariaStages))) {
            var malariaStages = int.malariaStages ++ [id];
            (ei with interactionInfo = (int with =malariaStages))
          } else {
            ei
          }
        })

      case DeleteMalariaStage(id) ->
        updateCurrentInteraction(fun(int) {
          var malariaStages = filter(fun(x) { x <> id }, int.malariaStages);
          (int with =malariaStages)
        })

      # Submission
      case Submit ->
        model.submit(model.receptorBasic, model.interactions); model

      case Cancel ->
        redirect("/"); model
    }
  }

  switch(model)  {
    case Just(model) -> Just(updtModel(model))
    case Nothing -> Nothing
  }
}

sig view : (Model) ~> MvuHTML.HTML(Message)
fun view(model) {
  open MvuHTML;
  open MvuAttrs;

  fun viewModel(model) {

    fun speciesShortName(speciesID) {
      Species.resolveSpeciesShortName(speciesID, model.speciesMap)
    }

    fun speciesLongName(speciesID) {
      Species.resolveSpeciesLongName(speciesID, model.speciesMap)
    }

    var h0 = MvuHTML.empty;
    var a0 = MvuAttrs.empty;

    fun renderTextBox(boxID, caption, val, inputCallback) {
      div(class("form-group"),
        label(for_(boxID), textNode(caption)) +*
        input(id(boxID) +@
          class("form-control") +@
          type("input") +@
          value(val) +@
          onInput(inputCallback), h0))
    }

    fun renderDropdown(selectID, caption, renderEntry, changeFn, entries) {
      var options = MvuHTML.concatMap(renderEntry, entries);
      div(class("form-group"),
        label(for_(selectID), textNode(caption)) +*
        select_(id(selectID) +@ class("form-control") +@
          onChange(changeFn), options))
    }

    fun renderCheckbox(checkID, text, value, fn) {
      var checkedAttr =
        if (value) {
          MvuAttrs.attr("checked", "checked")
        } else {
          MvuAttrs.empty
        };

      div(class("form-check"),
        input(class("form-check-input") +@
          type("checkbox") +@
          id(checkID) +@
          checkedAttr +@
          onClick(fn), h0) +*
      label(class("form-check-label") +@ for_(checkID), textNode(text)))
    }

    fun renderButton(f, caption, cls) {
      button(type("button") +@ class(cls) +@
        onClick(f), textNode(caption))
    }

    fun panel(name, contents) {
      div(class("row mt-3"),
        div(class("col-sm"),
          div(class("card"),
            div(class("card-header"), textNode(name)) +*
            div(class("card-body"), contents))))
    }


    var header =
      h1(a0,
        textNode("Editing interactions for ") +*
        unescapedTextNode(model.object.name) +*
        textNode(" (id: " ^^ intToString(model.object.object_id) ^^ ")"));

    var interactionComments = {
      switch(model.receptorBasic) {
        case Just(rb) ->
          var boxes =
            [(Activators, rb.activators_comments),
              (GatingInhibitors, rb.gating_inhibitors_comments),
              (Agonists, rb.agonists_comments),
              (ChannelBlockers, rb.channel_blockers_comments),
              (Antagonists, rb.antagonists_comments),
              (AllostericModulators, rb.allosteric_modulators_comments),
              # SubunitSpecific, rb.subunit_specific_comments TODO: ADD THIS IN
              (Inhibitors, rb.inhibitors_comments),
              (Antibodies, rb.antibody_comments)];

          fun renderBox((type, comments), i) {
            var boxID = "commentBox" ^^ intToString(i);
            div(class("form-group"),
              label(for_(boxID), textNode(showCommentType(type))) +*
              textarea(id(boxID) +@ class("form-control") +@ value(comments)
                +@ onInput(fun(str) { UpdateComment(type, str) }), h0))
          }

          var content =
            MvuHTML.concat(mapi(renderBox, boxes));

          panel("Interaction comments", content)
        case Nothing -> MvuHTML.empty
      }
    };

    var existingInteractions = {
      open InteractionUtilities;
      fun renderInteraction(int) {
        var affinity = mkAffinity(int.interaction.affinity_units,
            int.interaction.affinity_high, int.interaction.affinity_median,
            int.interaction.affinity_low);
        var rawAffinity = mkAffinity(int.interaction.original_affinity_units,
            int.interaction.original_affinity_high_nm, int.interaction.original_affinity_median_nm,
            int.interaction.original_affinity_low_nm);

        # Only display edit / trash buttons if we're not currently editing an interaction
        var editButtons = {
          if (isJust(model.currentInteraction)) {
            MvuHTML.empty
          } else {
            i(class("fas fa-edit fa-fw") +@
                title("Edit interaction") +@
                onClick(fun() { EditInteraction(int) }), h0) +*
            i(class("fas fa-trash fa-fw") +@
                title("Edit interaction") +@
                onClick(fun() { DeleteInteraction(int.interaction.interaction_id) }), h0)
          }
        };

        tr(a0,
          td(a0,
            unescapedTextNode(int.ligand.name) +*
            br(a0, h0) +*
            textNode(" { ID: " ^^ intToString(int.ligand.ligand_id) ^^ "i }")) +*
          td(a0, textNode(int.interaction.type)) +*
          td(a0, textNode(int.interaction.action)) +*
          td(a0, textNode(speciesShortName(int.interaction.species_id))) +*
          td(a0, displayAffinity(affinity, false)) +*
          td(a0, textNode(int.interaction.affinity_units)) +*
          td(a0, textNode(int.interaction.concentration_range)) +*
          td(a0, displayAffinity(rawAffinity, false)) +*
          td(a0, textNode(int.interaction.assay_description)) +*
          td(a0, textNode(if (int.interaction.from_grac) { "true" } else { "false" }) ) +*
          td(a0, textNode(intToString(int.interaction.interaction_id))) +*
          td(a0, editButtons))
      }

      var interactionsTable = {
        table_(class("table table-bordered table-sm"),
          thead(a0,
            tr(a0,
              th(a0, textNode("Ligand")) +*
              th(a0, textNode("Type")) +*
              th(a0, textNode("Action")) +*
              th(a0, textNode("Sp.")) +*
              th(a0, textNode("Affinity")) +*
              th(a0, textNode("Units")) +*
              th(a0, textNode("Concentration range")) +*
              th(a0, textNode("Raw affinity")) +*
              th(a0, textNode("Assay desc.")) +*
              th(a0, textNode("Concise view only?")) +*
              th(a0, textNode("ID")) +*
              th(a0, textNode("Options")))) +*
          tbody(a0, MvuHTML.concatMap(renderInteraction, model.interactions)))
      };

      panel("Existing interactions", interactionsTable)
    };

    fun mkInteractionEditor(ei) {
      var interaction = ei.interactionInfo;
      var avs = ei.affinityValues;
      var int = interaction.interaction;

      var errorBox = {
        fun renderError(err) {
          li(a0, textNode(err))
        }

        if (listEmpty(model.errors)) {
            MvuHTML.empty
        } else {
          var renderedErrors = MvuHTML.concatMap(renderError, model.errors);
          div(class("alert alert-danger") +@ role("alert"),
            textNode("Please correct the following problems:") +*
            ul(a0, renderedErrors))
        }
      };

      var buttons = {
        div(class("row mt-5"),
          div(class("col-sm"),
            button(type("button") +@ class("btn btn-primary mr-2") +@
                onClick(fun() { SubmitCurrentInteraction }), textNode("Update Interaction")) +*
            button(type("button") +@ class("btn btn-danger mr-2") +@
                onClick(fun() { DeleteCurrentInteraction }), textNode("Delete Interaction")) +*
            button(type("button") +@ class("btn btn-primary") +@
                onClick(fun() { CancelCurrentInteraction }), textNode("Cancel"))))
      };

      var ligandInfo = {
        # TODO: This does not (yet) allow changes in ligands, since dumping the
        # entire ligand list overflows the stack.
        panel("Ligand information",
          form(a0,
            div(class("form-group"),
              label(for_("lInfoID"), textNode("Ligand: ")) +*
              div(id("lInfoID") +@ class("form-control"),
                unescapedTextNode(interaction.ligand.name ^^
                  " { ID: " ^^ intToString(interaction.ligand.ligand_id) ^^ " }"))) +*
            div(class("form-group"),
              label(for_("lInfoContext"), textNode("Ligand context: ")) +*
              input(id("lInfoContext") +@
                class("form-control") +@
                type("input") +@
                value(int.ligand_context) +@
                onInput(fun(str) { UpdateField(LigandContext, str) }), h0)) +*
            div(class("form-group"),
              label(for_("lInfoSite"), textNode("Receptor site of action: ")) +*
              input(id("lInfoSite") +@
                class("form-control") +@
                type("input") +@
                value(int.receptor_site) +@
                onInput(fun(str) { UpdateField(ReceptorSite, str) }), h0))

        ))
      };

      var displayOptions = {
        fun renderCB((displayOption, text, value), i) {
          var checkID = "check" ^^ intToString(i);
          renderCheckbox(checkID, text, value,
            fun() { ChangeDisplayOption(displayOption, not(value)) })
        }

        var options = [
          (ShowInConcise, "Show in concise view", int.from_grac),
          (OnlyInConcise, "Only in concise view", int.only_grac),
          (Hide, "Hide", int.hide)
        ];

        var options = MvuHTML.concat(mapi(renderCB, options));

        panel("Display options", options)
      };

      var basicProperties = {

        var speciesDropdown = {
          fun renderSpeciesEntry((speciesID, (speciesShort, speciesLong))) {
            var selAttr =
              if (speciesID == int.species_id) {
                attr("selected", "selected")
              } else {
                MvuAttrs.empty
              };

            option(value(intToString(speciesID)) +@ selAttr,
                textNode(speciesLong ^^ " (" ^^ speciesShort ^^ ")"))
          }
          renderDropdown("speciesSelect", "Species", renderSpeciesEntry,
            fun(x) { ChangeSpeciesID(stringToInt(x)) }, model.speciesMap)
       };

       var typeDropdown = {
         var types =
           [ "None", "Antibody", "Agonist", "Antagonist", "Allosteric modulator",
             "Activator", "Inhibitor", "Channel blocker", "Gating inhibitor" ];

         fun renderType(ty) {
           var selAttr =
             if (ty == int.type) {
               attr("selected", "selected")
             } else {
               MvuAttrs.empty
             };
           option(value(ty) +@ selAttr, textNode(ty))
         }

         renderDropdown("interactionTypeSelect", "Interaction Type", renderType,
             fun(x) { ChangeInteractionType(x) }, types)
       };

       var actionDropdown = {
         var actions =
           [ "None", "Activation", "Agonist", "Biased agonist",
             "Partial agonist", "Full agonist", "Antagonist",
             "Biased antagonist", "Inverse agonist", "Positive",
             "Negative", "Neutral", "Biphasic", "Potentiation",
             "Inhibition", "Mixed", "Competitive", "Uncompetitive",
             "Non-competitive", "Feedback inhibition",
             "Irreversible inhibition", "Binding", "Pore blocker",
             "Slows inactivation", "Voltage-dependent inhibition", "Unknown" ];

        fun renderAction(ty) {
           var selAttr =
             if (ty == int.action) {
               attr("selected", "selected")
             } else {
               MvuAttrs.empty
             };
           option(value(ty) +@ selAttr, textNode(ty))
         }

         renderDropdown("actionSelect", "Action", renderAction,
             fun(x) { ChangeAction(x) }, actions)
       };

       var selectivityDropdown = {
         var selectivity =
           [ "Not Determined", "Selective", "Non-selective", "Family selective" ];

         fun renderSelectivity(sel) {
           var selAttr =
             if (sel == int.selectivity) {
               attr("selected", "selected")
             } else {
               MvuAttrs.empty
             };
           option(value(sel) +@ selAttr, textNode(sel))
         }

         renderDropdown("selectivitySelect", "Selectivity", renderSelectivity,
             fun(x) { ChangeSelectivity(x) }, selectivity)
       };

       var checkboxes = {
         fun renderCheckbox((displayOption, text, value), i) {
           var checkedAttr =
             if (value) {
               MvuAttrs.attr("checked", "checked")
             } else {
               MvuAttrs.empty
             };

           var checkID = "interactionPropCheck" ^^ intToString(i);

           div(class("form-check form-check-inline"),
             input(class("form-check-input") +@
               type("checkbox") +@
               id(checkID) +@
               checkedAttr +@
               onClick(fun() { ChangeInteractionProperty(displayOption, not(value)) }), h0) +*
             label(class("form-check-label") +@ for_(checkID), textNode(text)))
         }

         var options = [
           (Endogenous, "Endogenous", int.endogenous),
           (UseDependent, "Use-dependent", int.use_dependent),
           (VoltageDependent, "Voltage-dependent", int.voltage_dependent),
           (PrimaryTarget, "Primary target for this drug", int.primary_target),
           (WholeOrganismAssay, "Whole organism assay", int.whole_organism_assay)
         ];

         var options = MvuHTML.concat(mapi(renderCheckbox, options));

         panel("Properties", options)
       };

       var contents =
         speciesDropdown +*
         typeDropdown +*
         actionDropdown +*
         selectivityDropdown +*
         checkboxes;

       panel("Basic properties", contents)
      };

      var affinity = {

        fun renderHighMedLowBoxes(caption, pref, affinityType, highVal, medVal,
            lowVal, extras) {
          panel(caption,
            renderTextBox(pref ^^ "High", "High",
                highVal, fun(str) {
                  ChangeAffinity(affinityType, High, str) }) +*
            renderTextBox(pref ^^ "Median", "Median",
                medVal, fun(str) {
                  ChangeAffinity(affinityType, Median, str) }) +*
            renderTextBox(pref ^^ "Low", "Low",
                lowVal, fun(str) {
                  ChangeAffinity(affinityType, Low, str) }) +*
            extras)
        }

        var originalAffinity = {
          # Affinity units
          var unitOptions = [ "-", "Kd", "Ki", "IC50", "EC50", "KB" ];
          fun renderUnit(unit) {
            var selAttr =
              if (unit == int.original_affinity_units) {
                attr("selected", "selected")
              } else {
                MvuAttrs.empty
              };
            option(value(unit) +@ selAttr, textNode(unit))
          }

          var units =
            renderDropdown("origAffinityUnits", "Units", renderUnit,
                fun(str) { ChangeOriginalAffinityUnits(str) }, unitOptions);
          # Affinity relation
          # TODO: Can we factor this pattern out?
          fun renderRelation(rel) {
            var selAttr =
              if (rel == int.original_affinity_relation) {
                attr("selected", "selected")
              } else {
                MvuAttrs.empty
              };
            option(value(rel) +@ selAttr, textNode(rel))
          }

          var relationOptions = [ "=", ">", "<", "~" ];
          var relation =
            renderDropdown("origAffinityRelation", "Relation", renderRelation,
                fun(str) { ChangeOriginalAffinityRelation(str) }, relationOptions);
          var calculateButton =
            div(class("form-group"),
              renderButton(fun() { CalculateLogAffinity }, "Caculate -Log Affinity", "btn btn-primary"));

          var extras = units +* relation +* calculateButton;

          renderHighMedLowBoxes("Original Affinity Value (nM)", "orig", AffinityOriginal,
              avs.origHigh, avs.origMedian, avs.origLow, extras)
        };

        var logAffinity =
          renderHighMedLowBoxes("Affinity (-log)", "log", AffinityLog,
              avs.logHigh, avs.logMedian, avs.logLow, h0);

        var affinityVoltage = {
          var cb = renderCheckbox("physVoltageCB", "Physiological Voltage",
            int.affinity_physiological_voltage,
            fun() {
              SetPhysiologicalVoltage(not(int.affinity_physiological_voltage))
            });

          var cb = div(class("form-group"), cb);

          renderHighMedLowBoxes("Affinity Voltage (mV)", "av", AffinityVoltage,
            avs.avHigh, avs.avMedian, avs.avLow, cb)
        };

        var affinityContents =
          div(class("row"),
            div(class("col-sm"), originalAffinity) +*
            div(class("col-sm"), logAffinity) +*
            div(class("col-sm"), affinityVoltage));

        var affinityBoxes =
          panel("Affinity values", affinityContents);

        var concentrationRange =
          renderTextBox("concentrationRange", "Concentration Range",
              int.concentration_range, fun(str) {
                UpdateField(ConcentrationRange, str) });

        var rank =
          renderTextBox("rank", "Rank",
              avs.rank, fun(str) { ChangeRank(str) });

        var percentActivity =
          renderTextBox("percentActivity", "Percent Activity",
              avs.percentActivity, fun(str) { ChangePercentActivity(str) });

        var contents =
          affinityBoxes +*
          concentrationRange +*
          rank +*
          percentActivity;

        panel("Interaction affinity", contents)
      };

      var actionComment = {
        var caption =
          if (int.type == "Subunit-specific") {
            "Subunit specificity order"
          } else {
            "Action comment"
          };


        var contents =
          div(class("form-group"),
            label(for_("actionComment"), textNode(caption)) +*
            textarea(id("actionComment") +@ class("form-control") +@ value(int.action_comment)
              +@ onInput(fun(str) { UpdateField(ActionComment, str) }), h0));

        panel(caption, contents)
      };

      var assayInfo = {

        fun labelledTextarea(taID, caption, val, f) {
          div(class("form-group"),
            label(for_(taID), textNode(caption)) +*
            textarea(id(taID) +@ class("form-control") +@ value(val)
              +@ onInput(f), h0))
        }

        var assayDescription =  {
          labelledTextarea("assayDesc", "Assay description", int.assay_description,
            fun(str) { UpdateField(AssayDescription, str) })
        };

        var assayConditions = {
          labelledTextarea("assayCond", "Assay conditions", int.assay_conditions,
            fun(str) { UpdateField(AssayConditions, str) })
        };

        var assayURL = {
          div(class("form-group"),
            label(for_("assayURL"), textNode("Assay URL")) +*
            input(id("assayURL") +@
              class("form-control") +@
              type("input") +@
              value(int.assay_url) +@
              onInput(fun(str) { UpdateField(AssayURL, str) }), h0))
        };

        var contents = assayDescription +* assayConditions +* assayURL;
        panel("Assay information", contents)
      };

      var malariaInfo = {
        fun lookupStage(id, xs) {
          switch(xs) {
            case [] -> error("Invalid malaria ID")
            case x :: xs ->
              if (x.malaria_stage_id == id) {
                x
              } else {
                lookupStage(id, xs)
              }
          }
        }

        fun renderStage(stage) {
          textNode(stage.name ^^ " [ID: " ^^ intToString(stage.malaria_stage_id) ^^ "]")
        }

        var dropdown = {
          fun renderStageOption(x) {
            var selAttr =
              if (x.malaria_stage_id == ei.selectedMalariaStage) {
                attr("selected", "selected")
              } else {
                MvuAttrs.empty
              };
            option(value(intToString(x.malaria_stage_id)) +@ selAttr, renderStage(x))
          }

          div(class("form-inline"),
            div(class("form-group mb-2"),
              renderDropdown("malariaStage", "Malaria Stage", renderStageOption,
                  fun(id) { ChangeMalariaStage(stringToInt(id)) }, model.malariaStages)) +*
            button(class("mx-sm-3 btn btn-primary mb-2")
              +@ onClick(fun() { AddMalariaStage }), textNode("Add")))
        };

        var stages = {
          fun renderRow(id) {
            # Stages associated with this interaction
            var icon =
              i(class("fas fa-trash fa-fw") +@
                  title("Delete Malaria Stage") +@
                  onClick(fun() { DeleteMalariaStage(id) }), h0);

            tr(a0,
              td(a0, renderStage(lookupStage(id, model.malariaStages))) +*
              td(a0, icon))
          }

          if (listEmpty(interaction.malariaStages)) {
            textNode("No malaria stages associated with this interaction.")
          } else {
            var renderedStages =
              MvuHTML.concatMap(renderRow, interaction.malariaStages);
            table_(class("table table-bordered table-sm"), renderedStages)
          }
        };

        var contents = dropdown +* stages;
        panel("Malaria stages", contents)
      };

      var references = MvuHTML.empty;


      var contents =
        errorBox +*
        ligandInfo +*
        displayOptions +*
        basicProperties +*
        affinity +*
        actionComment +*
        assayInfo +*
        malariaInfo +*
        references +*
        buttons;

      panel("Editing interaction (ID: " ^^
          intToString(interaction.interaction.interaction_id) ^^ ")", contents)
    }

    var interactionEditor = {
      var anchor = a(name("interactionEditor"), h0);
      var editor =
        switch(model.currentInteraction) {
          case Just((ei)) -> mkInteractionEditor(ei)
          case Nothing -> MvuHTML.empty
        };
      anchor +* editor
    };

    var buttons = {
      div(class("row mt-5"),
        div(class("col-sm"),
          button(type("button") +@ class("btn btn-primary mr-2") +@
              onClick(fun() { Submit }), textNode("Submit")) +*
          button(type("button") +@ class("btn btn-primary") +@
              onClick(fun() { Cancel }), textNode("Cancel"))))
    };

    header +*
    interactionComments +*
    existingInteractions +*
    interactionEditor +*
    buttons
  }

  switch(model) {
    case Just(model) -> viewModel(model)
    case Nothing -> textNode("Nonexistent object")
  }
}


fun mainPage() {
  var initialModel =
    switch(lookup("objectID", environment())) {
      case Just(id) ->
        debug("ID: " ^^ id);
        if (isInt(id)) {
          getInitialModel(stringToInt(id))
        } else {
          Nothing
        }
      case Nothing -> Nothing
    };
  Mvu.runSimple("placeholder", initialModel, view, updt);
  Template.template()
}


