import Tables;
import Template;
import Mvu;
import MvuHTML;
import MvuAttrs;
import Species;
import InteractionUtilities;
open import Utility;

# TODAY:
#  - Affinity box
#  - Initial DB update logic

# STILL TO DO:
#  - Inserting from scratch
#  - Adding new interactions
#  - References

typename InteractionID = Int;
typename ReferenceID = Int;


# Affinity values are stored in the database as floats.  We can't modify the
# model directly as we do with other fields since it's perfectly reasonable to
# have the model in an inconsistent state during editing. We should only
# validate when submitting.
typename AffinityType = [| AffinityLog | AffinityVoltage | AffinityOriginal |];
typename AffinityBox = [| Low | Median | High |];

typename AffinityValues =
  (logHigh: String, logMedian: String, logLow: String,
   avHigh: String, avMedian: String, avLow: String,
   origHigh: String, origMedian: String, origLow: String,
   rank:String, percentActivity:String
  );

fun mkAffinityValues(int) {
  var f2s = floatToString;
  (logHigh = f2s(int.affinity_high), logMedian = f2s(int.affinity_median),
   logLow = f2s(int.affinity_low), avHigh = f2s(int.affinity_voltage_high),
   avMedian = f2s(int.affinity_voltage_median), avLow = f2s(int.affinity_voltage_low),
   origHigh = f2s(int.original_affinity_high_nm),
   origMedian = f2s(int.original_affinity_median_nm),
   origLow = f2s(int.original_affinity_low_nm),
   rank = intToString(int.rank),
   percentActivity = f2s(int.percent_activity))
}

typename InteractionInfo =
  (interaction: Tables.DbInteraction,
   ligand: Tables.RawLigand,
   references: [ReferenceID]);


typename Error = String;

typename Model =
  Maybe((
      object: Tables.RawObject,
      receptorBasic: Maybe(Tables.DbReceptorBasic),
      ligands: [(ligand_id: Int, name: String)],
      interactions: [InteractionInfo],
      currentInteraction: Maybe((InteractionInfo, AffinityValues)),
      references: [Tables.DbReference],
      speciesMap: Species.SpeciesMap,
      errors: [Error],
      submit: (Maybe(Tables.DbReceptorBasic), [InteractionInfo]) {}~> ()
  ));


typename CommentType =
  [| Activators | GatingInhibitors | Agonists | ChannelBlockers
   | Antagonists | AllostericModulators | SubunitSpecific | Inhibitors
   | Antibodies
  |];


var commentTypes =
  [ Activators, GatingInhibitors, Agonists, ChannelBlockers,
    Antagonists, AllostericModulators, SubunitSpecific, Inhibitors,
    Antibodies ];

# My kingdom for "deriving Show"
fun showCommentType(ct) {
  switch(ct) {
    case Activators -> "Activators"
    case GatingInhibitors -> "Gating Inhibitors"
    case Agonists -> "Agonists"
    case ChannelBlockers -> "Channel Blockers"
    case Antagonists -> "Antagonists"
    case AllostericModulators -> "Allosteric Modulators"
    case SubunitSpecific -> "Subunit Specific"
    case Inhibitors -> "Inhibitors"
    case Antibodies -> "Antibodies"
  }
}

typename DisplayOption = [| ShowInConcise | OnlyInConcise | Hide |];

typename Field =
  [| LigandContext | ReceptorSite | ActionComment | AssayDescription
   | AssayConditions | AssayURL | ConcentrationRange |];

typename InteractionProperty =
  [| Endogenous | UseDependent | VoltageDependent
   | PrimaryTarget | WholeOrganismAssay |];

typename Message =
  [| UpdateComment:(CommentType, String)
   | UpdateField:(Field, String)
   | EditInteraction:InteractionInfo | DeleteInteraction:InteractionID
   | SubmitCurrentInteraction | CancelCurrentInteraction | DeleteCurrentInteraction
   | ChangeDisplayOption:(DisplayOption, Bool)
   | ChangeSpeciesID:Int | ChangeInteractionType:String
   | ChangeAction:String | ChangeSelectivity:String
   | ChangeInteractionProperty:(InteractionProperty, Bool)
   | ChangeAffinity:(AffinityType, AffinityBox, String)
   | ChangePercentActivity:String
   | ChangeRank:String
   | SetPhysiologicalVoltage:Bool
   | ChangeOriginalAffinityUnits:String
   | ChangeOriginalAffinityRelation:String
   | Submit | Cancel |];

fun emptyInteraction(objectID) {
  (interaction_id = (-1),
   ligand_id = (-1),
   object_id = objectID,
   type = "None",
   action = "None",
   action_comment = "",
   species_id = (-1), # TODO: This should default to something...
   endogenous = false,
   selective = false,
   use_dependent = false,
   voltage_dependent = false,
   affinity_units = "-",
   affinity_high = 0.0,
   affinity_median = 0.0,
   affinity_low = 0.0,
   concentration_range = "",
   affinity_voltage_high = 0.0,
   affinity_voltage_median = 0.0,
   affinity_voltage_low = 0.0,
   affinity_physiological_voltage = false,
   rank= (-1),
   selectivity = "",
   original_affinity_low_nm = 0.0,
   original_affinity_median_nm = 0.0,
   original_affinity_high_nm = 0.0,
   original_affinity_units = "",
   original_affinity_relation = "",
   assay_description = "",
   assay_conditions = "",
   from_grac = false,
   only_grac = false,
   receptor_site = "",
   ligand_context = "",
   percent_activity = 0.0,
   assay_url = "",
   primary_target = false,
   target_ligand_id= (-1),
   whole_organism_assay = false,
   hide = false)
}

fun emptyInteractionInfo(objectID, ligand) {
  (interaction = emptyInteraction(objectID),
   =ligand,
   references = [])
}


sig commit: (Int, (Maybe(Tables.DbReceptorBasic), [InteractionInfo]), (Maybe(Tables.DbReceptorBasic), [InteractionInfo])) {}~> ()
fun commit(objectID, oldInfo, newInfo) server {
  var (oldComments, oldInteractions) = oldInfo;
  var (newComments, newInteractions) = newInfo;

  switch((oldComments, newComments)) {
    case (Just(oldRB), Just(newRB)) ->
      if (oldRB == newRB) {
        () # Nothing doing
      } else {
        update (rb <-- Tables.receptor_basic)
          where (rb.object_id == objectID)
          set (
            list_comments = newRB.list_comments,
            associated_proteins_comments = newRB.associated_proteins_comments,
            functional_assay_comments = newRB.functional_assay_comments,
            tissue_distribution_comments = newRB.tissue_distribution_comments,
            functions_comments = newRB.functions_comments,
            altered_expression_comments = newRB.altered_expression_comments,
            expression_pathophysiology_comments = newRB.expression_pathophysiology_comments,
            mutations_pathophysiology_comments = newRB.mutations_pathophysiology_comments,
            variants_comments = newRB.variants_comments,
            xenobiotic_expression_comments = newRB.xenobiotic_expression_comments,
            antibody_comments = newRB.antibody_comments,
            agonists_comments = newRB.agonists_comments,
            antagonists_comments = newRB.antagonists_comments,
            allosteric_modulators_comments = newRB.allosteric_modulators_comments,
            activators_comments = newRB.activators_comments,
            inhibitors_comments = newRB.inhibitors_comments,
            channel_blockers_comments = newRB.channel_blockers_comments,
            gating_inhibitors_comments = newRB.gating_inhibitors_comments)
      }
    case _ ->
      # Just(old), Nothing; Nothing, Just(new) are impossible
      # due to the way the UI is set up, so ignore them.
      ()
  }
}

fun getInitialModel(objectID) {
  var object =
    query {
      for (o <-- Tables.object)
        where (o.object_id == objectID)
        [(obj = o,
          rbs =
            for (rb <-- Tables.receptor_basic)
              where (rb.object_id == objectID)
              [rb],
          interactions =
            for (i <-- Tables.interaction)
              where (i.object_id == objectID)
              for (l <-- Tables.ligand)
              where (l.ligand_id == i.ligand_id)
              [(interaction = i,
                ligand = l,
                references =
                  for (iar <-- Tables.interaction_affinity_refs)
                    where (iar.interaction_id == i.interaction_id)
                    [iar.reference_id])
              ])
        ]
    };

  switch (object) {
    case [] -> Nothing
    case x :: _ ->
      # TODO: Unfortunately this blows the stack. And is slow. Alas.
      # We might have to have a user-unfriendly "enter a ligand ID" for now...
      var allLigands = [];
      #query {
      #  for (l <-- Tables.ligand)
      #    [(ligand_id = l.ligand_id, name = l.name)]
      #};

      var allReferences = [];
       #query {
       #  for (r <-- Tables.reference)
       #    [r]
       #};

      var rb =
        switch(x.rbs) {
          case [] -> Nothing
          case rb :: _ -> Just(rb)
        };

      sig submit : (Maybe(Tables.DbReceptorBasic), [InteractionInfo]) {}~> ()
      fun submit(newRb, newInteractions) {
        commit(objectID, (rb, x.interactions), (newRb, newInteractions));
        redirect("/")
      }

      Just((object = x.obj,
            ligands = allLigands,
            receptorBasic = rb,
            =submit,
            interactions = x.interactions,
            currentInteraction = Nothing,
            speciesMap = Species.getSpeciesMap(),
            errors = [],
            references = allReferences))
  }
}


sig updt : (Message, Model) {}~> Model
fun updt(msg, model) {
  fun updtModel(model) {
    fun updateComment(ty, newVal, rb) {
      switch(ty) {
        case Activators -> (rb with activators_comments = newVal)
        case GatingInhibitors -> (rb with gating_inhibitors_comments = newVal)
        case Agonists -> (rb with agonists_comments = newVal)
        case ChannelBlockers -> (rb with channel_blockers_comments = newVal)
        case Antagonists -> (rb with antagonists_comments = newVal)
        case AllostericModulators -> (rb with allosteric_modulators_comments = newVal)
        case SubunitSpecific -> rb # TODO
        case Inhibitors -> (rb with inhibitors_comments = newVal)
        case Antibodies -> (rb with antibody_comments = newVal)
      }
    }

    fun deleteInteraction(id) {
      filter(fun(x) {
          x.interaction.interaction_id <> id
      }, model.interactions)
    }

    fun updateCurrentInteraction(f) {
      var currentInteraction =
        switch (model.currentInteraction) {
          case Just((int, avs)) -> Just(f(int), avs)
          case Nothing -> Nothing
        };
      (model with =currentInteraction)
    }

    fun updateAffinityValues(f) {
      var currentInteraction =
        switch (model.currentInteraction) {
          case Just((int, avs)) -> Just(int, f(avs))
          case Nothing -> Nothing
        };
      (model with =currentInteraction)
    }

    fun submitCurrentInteraction() {
      fun validate(avs) {
        var conditions =
          [
           (isFloat(avs.origHigh),
              "Original Affinity Value (High) must be a floating-point number"),
           (isFloat(avs.origMedian),
              "Original Affinity Value (Median) must be a floating-point number"),
           (isFloat(avs.origLow),
              "Original Affinity Value (Low) must be a floating-point number"),
           (isFloat(avs.logHigh),
              "-log Affinity Value (High) must be a floating-point number"),
           (isFloat(avs.logMedian),
              "-log Affinity Value (Median) must be a floating-point number"),
           (isFloat(avs.logLow),
              "-log Affinity Value (Low) must be a floating-point number"),
           (isFloat(avs.avHigh),
              "Affinity Voltage (High) must be a floating-point number"),
           (isFloat(avs.avMedian),
              "Affinity Voltage (Median) must be a floating-point number"),
           (isFloat(avs.avLow),
              "Affinity Voltage (Low) must be a floating-point number")];
        # Leave all errors where condition is not satisfied
        filterMap(fun((cond, err)) { if (cond) { Nothing } else { Just(err) } }, conditions)
      }

      switch(model.currentInteraction) {
        case Nothing -> model
        case Just((int, avs)) ->
          var errors = validate(avs);
          var isOK = listEmpty(errors);
          # Only update interaction if no errors
          if (isOK) {
            # Now propagate the changes from AVs fields
            var interaction = int.interaction;
            var s2f = stringToFloat;
            var interaction =
              (interaction with
               affinity_high = s2f(avs.logHigh), affinity_median =
               s2f(avs.logMedian), affinity_low = s2f(avs.logLow),
               #
               affinity_voltage_high = s2f(avs.avHigh),
               affinity_voltage_median = s2f(avs.avMedian),
               affinity_voltage_low = s2f(avs.avLow),
               #
               original_affinity_high_nm = s2f(avs.origHigh),
               original_affinity_median_nm = s2f(avs.origMedian),
               original_affinity_low_nm = s2f(avs.origLow));
            var int = (int with =interaction);

            fun go(xs) {
              switch(xs) {
                case [] -> []
                case x :: xs ->
                  if (x.interaction.interaction_id == int.interaction.interaction_id) {
                    int :: xs
                  } else {
                    x :: go(xs)
                  }
              }
            }
            (model with interactions = go(model.interactions),
             currentInteraction = Nothing, errors = [])
          } else {
            redirect("#interactionEditor");
            (model with =errors)
          }
      }
    }

    switch(msg) {
      case UpdateComment(ty, newVal) ->
        switch(model.receptorBasic) {
          case Just(rb) ->
            var newRb = updateComment(ty, newVal, rb);
            (model with receptorBasic = Just(newRb))
          case Nothing -> model
        }

      case EditInteraction(interaction) ->
        var avs = mkAffinityValues(interaction.interaction);
        redirect("#interactionEditor");
        (model with errors = [], currentInteraction = Just((interaction, avs)))

      case SubmitCurrentInteraction ->
        submitCurrentInteraction()

      case DeleteInteraction(id) ->
        (model with interactions = deleteInteraction(id))

      case DeleteCurrentInteraction ->
        switch(model.currentInteraction) {
          case Just((int, _)) ->
            var interactions = deleteInteraction(int.interaction.interaction_id);
            (model with =interactions, currentInteraction = Nothing)
          case Nothing -> (model with currentInteraction = Nothing)
        }

      case CancelCurrentInteraction ->
        (model with currentInteraction = Nothing)

      # Editing
      case ChangeDisplayOption(displayOption, val) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction =
            switch (displayOption) {
              case ShowInConcise -> (interaction with from_grac = val)
              case OnlyInConcise -> (interaction with only_grac = val)
              case Hide -> (interaction with hide = val)
            };
          (int with =interaction) })

      case ChangeSpeciesID(speciesID) ->
        updateCurrentInteraction(fun(int) {
            var interaction = int.interaction;
            var interaction = (interaction with species_id = speciesID);
            (int with =interaction)
        })

      case ChangeInteractionType(type) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction = (interaction with =type);
          (int with =interaction)
        })

      case ChangeAction(action) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction = (interaction with =action);
          (int with =interaction)
        })

      case ChangeSelectivity(selectivity) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction = (interaction with =selectivity);
          (int with =interaction)
        })

      case ChangeInteractionProperty(prop, val) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction =
            switch(prop) {
              case Endogenous -> (interaction with endogenous = val)
              case UseDependent -> (interaction with use_dependent = val)
              case VoltageDependent -> (interaction with voltage_dependent = val)
              case PrimaryTarget -> (interaction with primary_target = val)
              case WholeOrganismAssay -> (interaction with whole_organism_assay = val)
            };
          (int with =interaction)
        })

      case UpdateField(field, val) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction =
            switch(field) {
              case LigandContext ->
                (interaction with ligand_context = val)
              case ReceptorSite ->
                (interaction with receptor_site = val)
              case ActionComment ->
                (interaction with action_comment = val)
              case AssayDescription ->
                (interaction with assay_description = val)
              case AssayConditions ->
                (interaction with assay_conditions = val)
              case AssayURL ->
                (interaction with assay_url = val)
              case ConcentrationRange ->
                (interaction with concentration_range = val)
            };
            (int with =interaction)
        })

      case ChangeAffinity(ty, box, val) ->
        updateAffinityValues(fun(affinityValues) {
          switch ((ty, box)) {
            case (AffinityLog, Low) ->
              (affinityValues with logLow = val)
            case (AffinityLog, Median) ->
              (affinityValues with logMedian = val)
            case (AffinityLog, High) ->
              (affinityValues with logHigh = val)
            case (AffinityVoltage, Low) ->
              (affinityValues with avLow = val)
            case (AffinityVoltage, Median) ->
              (affinityValues with avMedian = val)
            case (AffinityVoltage, High) ->
              (affinityValues with avHigh = val)
            case (AffinityOriginal, Low) ->
              (affinityValues with origLow = val)
            case (AffinityOriginal, Median) ->
              (affinityValues with origMedian = val)
            case (AffinityOriginal, High) ->
              (affinityValues with origHigh = val)
          }
        })

      case ChangePercentActivity(str) ->
        updateAffinityValues(fun(avs) {
          (avs with percentActivity = str)
        })

      case SetPhysiologicalVoltage(val) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction =
            (interaction with affinity_physiological_voltage = val);
          (int with =interaction)
        })

      case ChangeOriginalAffinityUnits(val) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction =
            (interaction with original_affinity_units = val);
          (int with =interaction)
        })

      case ChangeOriginalAffinityRelation(val) ->
        updateCurrentInteraction(fun(int) {
          var interaction = int.interaction;
          var interaction =
            (interaction with original_affinity_relation= val);
          (int with =interaction)
        })

     #case ChangeAffinityUnits(val) ->
     #  updateCurrentInteraction(fun(int) {
     #    var interaction = int.interaction;
     #    var interaction =
     #      (interaction with affinity_units = val);
     #    (int with =interaction)
     #  })

      case ChangeRank(str) ->
        updateAffinityValues(fun(avs) {
          (avs with rank = str)
        })

      # Submission
      case Submit ->
        model.submit(model.receptorBasic, model.interactions); model

      case Cancel ->
        redirect("/"); model
    }
  }

  switch(model)  {
    case Just(model) -> Just(updtModel(model))
    case Nothing -> Nothing
  }
}

fun view(model) {
  open MvuHTML;
  open MvuAttrs;

  fun viewModel(model) {

    fun speciesShortName(speciesID) {
      Species.resolveSpeciesShortName(speciesID, model.speciesMap)
    }

    fun speciesLongName(speciesID) {
      Species.resolveSpeciesLongName(speciesID, model.speciesMap)
    }

    var h0 = MvuHTML.empty;
    var a0 = MvuAttrs.empty;

    fun renderTextBox(boxID, caption, val, inputCallback) {
      div(class("form-group"),
        label(for_(boxID), textNode(caption)) +*
        input(id(boxID) +@
          class("form-control") +@
          type("input") +@
          value(val) +@
          onInput(inputCallback), h0))
    }

    fun renderDropdown(selectID, caption, renderEntry, changeFn, entries) {
      var options = MvuHTML.concatMap(renderEntry, entries);
      div(class("form-group"),
        label(for_(selectID), textNode(caption)) +*
        select_(id(selectID) +@ class("form-control") +@
          onChange(changeFn), options))
    }

    fun panel(name, contents) {
      div(class("row mt-3"),
        div(class("col-sm"),
          div(class("card"),
            div(class("card-header"), textNode(name)) +*
            div(class("card-body"), contents))))
    }


    var header =
      h1(a0,
        textNode("Editing interactions for ") +*
        unescapedTextNode(model.object.name) +*
        textNode(" (id: " ^^ intToString(model.object.object_id) ^^ ")"));

    var interactionComments = {
      switch(model.receptorBasic) {
        case Just(rb) ->
          var boxes =
            [(Activators, rb.activators_comments),
              (GatingInhibitors, rb.gating_inhibitors_comments),
              (Agonists, rb.agonists_comments),
              (ChannelBlockers, rb.channel_blockers_comments),
              (Antagonists, rb.antagonists_comments),
              (AllostericModulators, rb.allosteric_modulators_comments),
              # SubunitSpecific, rb.subunit_specific_comments TODO: ADD THIS IN
              (Inhibitors, rb.inhibitors_comments),
              (Antibodies, rb.antibody_comments)];

          fun renderBox((type, comments), i) {
            var boxID = "commentBox" ^^ intToString(i);
            div(class("form-group"),
              label(for_(boxID), textNode(showCommentType(type))) +*
              textarea(id(boxID) +@ class("form-control") +@ value(comments)
                +@ onInput(fun(str) { UpdateComment(type, str) }), h0))
          }

          var content =
            MvuHTML.concat(mapi(renderBox, boxes));

          panel("Interaction comments", content)
        case Nothing -> MvuHTML.empty
      }
    };

    var existingInteractions = {
      open InteractionUtilities;
      fun renderInteraction(int) {
        var affinity = mkAffinity(int.interaction.affinity_units,
            int.interaction.affinity_high, int.interaction.affinity_median,
            int.interaction.affinity_low);
        var rawAffinity = mkAffinity(int.interaction.original_affinity_units,
            int.interaction.original_affinity_high_nm, int.interaction.original_affinity_median_nm,
            int.interaction.original_affinity_low_nm);

        # Only display edit / trash buttons if we're not currently editing an interaction
        var editButtons = {
          if (isJust(model.currentInteraction)) {
            MvuHTML.empty
          } else {
            i(class("fas fa-edit fa-fw") +@
                title("Edit interaction") +@
                onClick(fun() { EditInteraction(int) }), h0) +*
            i(class("fas fa-trash fa-fw") +@
                title("Edit interaction") +@
                onClick(fun() { DeleteInteraction(int.interaction.interaction_id) }), h0)
          }
        };

        tr(a0,
          td(a0,
            unescapedTextNode(int.ligand.name) +*
            br(a0, h0) +*
            textNode(" { ID: " ^^ intToString(int.ligand.ligand_id) ^^ "i }")) +*
          td(a0, textNode(int.interaction.type)) +*
          td(a0, textNode(int.interaction.action)) +*
          td(a0, textNode(speciesShortName(int.interaction.species_id))) +*
          td(a0, displayAffinity(affinity, false)) +*
          td(a0, textNode(int.interaction.affinity_units)) +*
          td(a0, textNode(int.interaction.concentration_range)) +*
          td(a0, displayAffinity(rawAffinity, false)) +*
          td(a0, textNode(int.interaction.assay_description)) +*
          td(a0, textNode(if (int.interaction.from_grac) { "true" } else { "false" }) ) +*
          td(a0, textNode(intToString(int.interaction.interaction_id))) +*
          td(a0, editButtons))
      }

      var interactionsTable = {
        table_(class("table table-bordered"),
          thead(a0,
            tr(a0,
              th(a0, textNode("Ligand")) +*
              th(a0, textNode("Type")) +*
              th(a0, textNode("Action")) +*
              th(a0, textNode("Sp.")) +*
              th(a0, textNode("Affinity")) +*
              th(a0, textNode("Units")) +*
              th(a0, textNode("Concentration range")) +*
              th(a0, textNode("Raw affinity")) +*
              th(a0, textNode("Assay desc.")) +*
              th(a0, textNode("Concise view only?")) +*
              th(a0, textNode("ID")) +*
              th(a0, textNode("Options")))) +*
          tbody(a0, MvuHTML.concatMap(renderInteraction, model.interactions)))
      };

      panel("Existing interactions", interactionsTable)
    };

    fun mkInteractionEditor(interaction, avs) {
      var int = interaction.interaction;

      var errorBox = {
        fun renderError(err) {
          li(a0, textNode(err))
        }

        if (listEmpty(model.errors)) {
            MvuHTML.empty
        } else {
          var renderedErrors = MvuHTML.concatMap(renderError, model.errors);
          div(class("alert alert-danger") +@ role("alert"),
            textNode("Please correct the following problems:") +*
            ul(a0, renderedErrors))
        }
      };

      var buttons = {
        div(class("row mt-5"),
          div(class("col-sm"),
            button(type("button") +@ class("btn btn-primary mr-2") +@
                onClick(fun() { SubmitCurrentInteraction }), textNode("Update Interaction")) +*
            button(type("button") +@ class("btn btn-danger mr-2") +@
                onClick(fun() { DeleteCurrentInteraction }), textNode("Delete Interaction")) +*
            button(type("button") +@ class("btn btn-primary") +@
                onClick(fun() { CancelCurrentInteraction }), textNode("Cancel"))))
      };

      var ligandInfo = {
        # TODO: This does not (yet) allow changes in ligands, since dumping the
        # entire ligand list overflows the stack.
        panel("Ligand information",
          form(a0,
            div(class("form-group"),
              label(for_("lInfoID"), textNode("Ligand: ")) +*
              div(id("lInfoID") +@ class("form-control"),
                unescapedTextNode(interaction.ligand.name ^^
                  " { ID: " ^^ intToString(interaction.ligand.ligand_id) ^^ " }"))) +*
            div(class("form-group"),
              label(for_("lInfoContext"), textNode("Ligand context: ")) +*
              input(id("lInfoContext") +@
                class("form-control") +@
                type("input") +@
                value(int.ligand_context) +@
                onInput(fun(str) { UpdateField(LigandContext, str) }), h0)) +*
            div(class("form-group"),
              label(for_("lInfoSite"), textNode("Receptor site of action: ")) +*
              input(id("lInfoSite") +@
                class("form-control") +@
                type("input") +@
                value(int.receptor_site) +@
                onInput(fun(str) { UpdateField(ReceptorSite, str) }), h0))

        ))
      };

      var displayOptions = {
        fun renderCheckbox((displayOption, text, value), i) {
          var checkedAttr =
            if (value) {
              MvuAttrs.attr("checked", "checked")
            } else {
              MvuAttrs.empty
            };

          var checkID = "check" ^^ intToString(i);

          div(class("form-check form-check-inline"),
            input(class("form-check-input") +@
              type("checkbox") +@
              id(checkID) +@
              checkedAttr +@
              onClick(fun() { ChangeDisplayOption(displayOption, not(value)) }), h0) +*
            label(class("form-check-label") +@ for_(checkID), textNode(text)))
        }

        var options = [
          (ShowInConcise, "Show in concise view", int.from_grac),
          (OnlyInConcise, "Only in concise view", int.only_grac),
          (Hide, "Hide", int.hide)
        ];

        var options = MvuHTML.concat(mapi(renderCheckbox, options));

        panel("Display options", options)
      };

      var basicProperties = {

        var speciesDropdown = {
          fun renderSpeciesEntry((speciesID, (speciesShort, speciesLong))) {
            var selAttr =
              if (speciesID == int.species_id) {
                attr("selected", "selected")
              } else {
                MvuAttrs.empty
              };

            option(value(intToString(speciesID)) +@ selAttr,
                textNode(speciesLong ^^ " (" ^^ speciesShort ^^ ")"))
          }
          renderDropdown("speciesSelect", "Species", renderSpeciesEntry,
            fun(x) { ChangeSpeciesID(stringToInt(x)) }, model.speciesMap)
       };

       var typeDropdown = {
         var types =
           [ "None", "Antibody", "Agonist", "Antagonist", "Allosteric modulator",
             "Activator", "Inhibitor", "Channel blocker", "Gating inhibitor" ];

         fun renderType(ty) {
           var selAttr =
             if (ty == int.type) {
               attr("selected", "selected")
             } else {
               MvuAttrs.empty
             };
           option(value(ty) +@ selAttr, textNode(ty))
         }

         renderDropdown("interactionTypeSelect", "Interaction Type", renderType,
             fun(x) { ChangeInteractionType(x) }, types)
       };

       var actionDropdown = {
         var actions =
           [ "None", "Activation", "Agonist", "Biased agonist",
             "Partial agonist", "Full agonist", "Antagonist",
             "Biased antagonist", "Inverse agonist", "Positive",
             "Negative", "Neutral", "Biphasic", "Potentiation",
             "Inhibition", "Mixed", "Competitive", "Uncompetitive",
             "Non-competitive", "Feedback inhibition",
             "Irreversible inhibition", "Binding", "Pore blocker",
             "Slows inactivation", "Voltage-dependent inhibition", "Unknown" ];

        fun renderAction(ty) {
           var selAttr =
             if (ty == int.action) {
               attr("selected", "selected")
             } else {
               MvuAttrs.empty
             };
           option(value(ty) +@ selAttr, textNode(ty))
         }

         renderDropdown("actionSelect", "Action", renderAction,
             fun(x) { ChangeAction(x) }, actions)
       };

       var selectivityDropdown = {
         var selectivity =
           [ "Not Determined", "Selective", "Non-selective", "Family selective" ];

         fun renderSelectivity(sel) {
           var selAttr =
             if (sel == int.selectivity) {
               attr("selected", "selected")
             } else {
               MvuAttrs.empty
             };
           option(value(sel) +@ selAttr, textNode(sel))
         }

         renderDropdown("selectivitySelect", "Selectivity", renderSelectivity,
             fun(x) { ChangeSelectivity(x) }, selectivity)
       };

       var checkboxes = {
         fun renderCheckbox((displayOption, text, value), i) {
           var checkedAttr =
             if (value) {
               MvuAttrs.attr("checked", "checked")
             } else {
               MvuAttrs.empty
             };

           var checkID = "interactionPropCheck" ^^ intToString(i);

           div(class("form-check form-check-inline"),
             input(class("form-check-input") +@
               type("checkbox") +@
               id(checkID) +@
               checkedAttr +@
               onClick(fun() { ChangeInteractionProperty(displayOption, not(value)) }), h0) +*
             label(class("form-check-label") +@ for_(checkID), textNode(text)))
         }

         var options = [
           (Endogenous, "Endogenous", int.endogenous),
           (UseDependent, "Use-dependent", int.use_dependent),
           (VoltageDependent, "Voltage-dependent", int.voltage_dependent),
           (PrimaryTarget, "Primary target for this drug", int.primary_target),
           (WholeOrganismAssay, "Whole organism assay", int.whole_organism_assay)
         ];

         var options = MvuHTML.concat(mapi(renderCheckbox, options));

         panel("Properties", options)
       };

       var contents =
         speciesDropdown +*
         typeDropdown +*
         actionDropdown +*
         selectivityDropdown +*
         checkboxes;

       panel("Basic properties", contents)
      };

      var affinity = {

        fun renderHighMedLowBoxes(caption, pref, affinityType, highVal, medVal, lowVal) {
          panel(caption,
            renderTextBox(pref ^^ "High", "High",
                highVal, fun(str) {
                  ChangeAffinity(affinityType, High, str) }) +*
            renderTextBox(pref ^^ "Median", "Median",
                medVal, fun(str) {
                  ChangeAffinity(affinityType, Median, str) }) +*
            renderTextBox(pref ^^ "Low", "Low",
                lowVal, fun(str) {
                  ChangeAffinity(affinityType, Low, str) }))
        }

        var originalAffinity = {
          var boxes =
            renderHighMedLowBoxes("Original Affinity Value (nM)", "orig", AffinityOriginal,
                avs.origHigh, avs.origMedian, avs.origLow);
          # Affinity units
          var unitOptions = [ "-", "Kd", "Ki", "IC50", "EC50", "KB" ];
          fun renderUnit(unit) {
            var selAttr =
              if (unit == int.original_affinity_units) {
                attr("selected", "selected")
              } else {
                MvuAttrs.empty
              };
            option(value(unit) +@ selAttr, textNode(unit))
          }

          var units =
            renderDropdown("origAffinityUnits", "Units", renderUnit,
                fun(str) { ChangeOriginalAffinityUnits(str) }, unitOptions);
          # Affinity relation
          # TODO: Can we factor this pattern out?
          fun renderRelation(rel) {
            var selAttr =
              if (rel == int.original_affinity_relation) {
                attr("selected", "selected")
              } else {
                MvuAttrs.empty
              };
            option(value(rel) +@ selAttr, textNode(rel))
          }


          var relationOptions = [ "=", ">", "<", "~" ];
          var relation =
            renderDropdown("origAffinityRelation", "Relation", renderRelation,
                fun(str) { ChangeOriginalAffinityRelation(str) }, relationOptions);
          boxes +* units +* relation
        };

        var logAffinity =
          renderHighMedLowBoxes("Affinity (-log)", "log", AffinityLog,
              avs.logHigh, avs.logMedian, avs.logLow);

        var affinityVoltage =
          renderHighMedLowBoxes("Affinity Voltage (mV)", "av", AffinityVoltage,
              avs.avHigh, avs.avMedian, avs.avLow);

        var calculateButton = MvuHTML.empty;

        var affinityContents =
          div(class("row"),
            div(class("col-sm"), originalAffinity) +*
            div(class("col-sm"), logAffinity) +*
            div(class("col-sm"), affinityVoltage)) +*
          div(class("row"), calculateButton);


        var affinityBoxes =
          panel("Affinity values", affinityContents);

        var concentrationRange =
          renderTextBox("concentrationRange", "Concentration Range",
              int.concentration_range, fun(str) {
                UpdateField(ConcentrationRange, str) });

        var rank =
          renderTextBox("rank", "Rank",
              avs.rank, fun(str) { ChangeRank(str) });

        var percentActivity =
          renderTextBox("percentActivity", "Percent Activity",
              avs.rank, fun(str) { ChangePercentActivity(str) });

        var contents =
          affinityBoxes +*
          concentrationRange +*
          rank +*
          percentActivity;

        panel("Interaction affinity", contents)
      };

      var actionComment = {
        var caption =
          if (int.type == "Subunit-specific") {
            "Subunit specificity order"
          } else {
            "Action comment"
          };


        var contents =
          div(class("form-group"),
            label(for_("actionComment"), textNode(caption)) +*
            textarea(id("actionComment") +@ class("form-control") +@ value(int.action_comment)
              +@ onInput(fun(str) { UpdateField(ActionComment, str) }), h0));

        panel(caption, contents)
      };

      var assayInfo = {

        fun labelledTextarea(taID, caption, val, f) {
          div(class("form-group"),
            label(for_(taID), textNode(caption)) +*
            textarea(id(taID) +@ class("form-control") +@ value(val)
              +@ onInput(f), h0))
        }

        var assayDescription =  {
          labelledTextarea("assayDesc", "Assay description", int.assay_description,
            fun(str) { UpdateField(AssayDescription, str) })
        };

        var assayConditions = {
          labelledTextarea("assayCond", "Assay conditions", int.assay_conditions,
            fun(str) { UpdateField(AssayConditions, str) })
        };

        var assayURL = {
          div(class("form-group"),
            label(for_("assayURL"), textNode("Assay URL")) +*
            input(id("assayURL") +@
              class("form-control") +@
              type("input") +@
              value(int.assay_url) +@
              onInput(fun(str) { UpdateField(AssayURL, str) }), h0))
        };

        var contents = assayDescription +* assayConditions +* assayURL;
        panel("Assay information", contents)
      };

      var malariaInfo = MvuHTML.empty;

      var references = MvuHTML.empty;


      var contents =
        errorBox +*
        ligandInfo +*
        displayOptions +*
        basicProperties +*
        affinity +*
        actionComment +*
        assayInfo +*
        malariaInfo +*
        references +*
        buttons;

      panel("Editing interaction (ID: " ^^
          intToString(interaction.interaction.interaction_id) ^^ ")", contents)
    }

    var interactionEditor = {
      var anchor = a(name("interactionEditor"), h0);
      var editor =
        switch(model.currentInteraction) {
          case Just((i, avs)) -> mkInteractionEditor(i, avs)
          case Nothing -> MvuHTML.empty
        };
      anchor +* editor
    };

    var buttons = {
      div(class("row mt-5"),
        div(class("col-sm"),
          button(type("button") +@ class("btn btn-primary mr-2") +@
              onClick(fun() { Submit }), textNode("Submit")) +*
          button(type("button") +@ class("btn btn-primary") +@
              onClick(fun() { Cancel }), textNode("Cancel"))))
    };

    header +*
    interactionComments +*
    existingInteractions +*
    interactionEditor +*
    buttons
  }

  switch(model) {
    case Just(model) -> viewModel(model)
    case Nothing -> textNode("Nonexistent object")
  }
}


fun mainPage() {
  var initialModel =
    switch(lookup("objectID", environment())) {
      case Just(id) ->
        debug("ID: " ^^ id);
        if (isInt(id)) {
          getInitialModel(stringToInt(id))
        } else {
          Nothing
        }
      case Nothing -> Nothing
    };
  Mvu.runSimple("placeholder", initialModel, view, updt);
  Template.template()
}


