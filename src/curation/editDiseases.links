import Tables;
import Mvu;
import MvuHTML;
import MvuAttrs;
import Template;

typename DiseaseID = Int;
typename DiseaseName = String;

typename HTML(a) = MvuHTML.HTML(a);

# For now -- this will also contain synonym and xref info later
typename DiseaseInfo = Tables.DbDisease;


# The editing process first requires a disease to be selected.
#
# The lens reference only makes sense on the server, so needs to be
# stored in a persistent process.
#
# We then select the disease, at which point we can either edit it, or
# delete it.
#
# When we choose to edit it, we get the disease data back. We then send
# the updated disease data, which gets committed by the lens.
#
# ...could this be... an actual, real-life, non-contrived use of session
# types!?

mutual {
  typename EditDisease = ?[(DiseaseID, DiseaseName)].SelectDisease;

  typename SelectDisease =
    [+| Edit: Editing,
        Delete: !DiseaseID.EditDisease |+];

  typename Editing = !DiseaseID.?DiseaseInfo.!DiseaseInfo.EditDisease;
}


typename SelectingInfo =
  (diseases: [(DiseaseID, DiseaseName)], selectedDisease: DiseaseID);

typename EditingInfo =
  (diseaseID: DiseaseID, diseaseInfo: DiseaseInfo);

typename Model = [|
    Waiting
  | Selecting:(SelectDisease, SelectingInfo)
  | Editing:(Editing, EditingInfo)
|];

typename UnrModel = [|
    UWaiting
  | USelecting:SelectingInfo
  | UEditing:EditingInfo
|];

# TODO: Fill me in
typename Message = ();

sig updt: (Message, Model) ~> (Model, Mvu.Command(Message))
fun updt(msg, model) { (model, NoCommand) }

sig extract : (Model) ~> (Model, UnrModel)
fun extract(model) {
  switch(model) {
    case Waiting -> (Waiting, UWaiting)
    case Selecting(ed, si) -> (Selecting(ed, si), USelecting(si))
    case Editing(ed, ei) -> (Editing(ed, ei), UEditing(ei))
  }
}

sig view : (UnrModel) ~> HTML(Message)
fun view(unrModel) {
  open MvuHTML;
  open MvuAttrs;
  var a0 = MvuAttrs.empty;
  var h0 = MvuHTML.empty;

  fun renderSelecting(si: SelectingInfo) {
    var options =
      MvuHTML.concatMap(fun((di, dn)) {
          var selAttr =
            if (di == si.selectedDisease) { MvuAttrs.attr("selected", "selected") }
            else { MvuAttrs.empty };
          var di = intToString(di);
          option(value(di) +@ selAttr,
              textNode(dn ^^ " [id: " ^^ di ^^ "]"))
      }, si.diseases);

    form(a0,
      div(class("form-group row"),
        label(for_("diseaseName") +@ class("col-sm-2 col-form-label"),
          textNode("Disease Name")) +*
        div(class("col-sm-10"),
          select_(id("diseaseName"), options))) +*
      div(class("form-group row"),
        div(class("col-sm-10"),
          button(type("button") +@ class("btn btn-primary"), textNode("Edit")) +*
          button(type("button") +@ class("btn btn-primary"), textNode("Delete")))))
  }

  var body =
    switch(unrModel) {
      case UWaiting -> textNode("Loading...")
      case USelecting(si) -> renderSelecting(si)
      case UEditing(ei) -> textNode("Editing")
    };

  h1(a0, textNode("Edit Diseases")) +* body
}


sig handleQueries : (~EditDisease) ~> ()
fun handleQueries(s) {
  # Query the list of diseases
  var diseasesLens = lens Tables.disease with { disease_id -> name };
  var diseases = sortBy(fun(x) { x.name }, lensget diseasesLens);
  # TODO: Investigate dropLens
  var s = send(map(fun(d) { (d.disease_id, d.name) }, diseases), s);
  offer(s) {
    case Edit(s) ->
      var (id, s) = receive(s);
      var selectLens = lensselect from diseasesLens by fun (x) { x.disease_id == id };
      var selectLens = lenscheck selectLens;
      var results = lensget selectLens;
      var diseaseInfo =
        switch (results) {
          case [] -> raise # Shouldn't happen.
          case x :: _ -> x
        };
      var s = send(diseaseInfo, s);
      var (updatedInfo, s) = receive(s);
      var _ = lensput selectLens with updatedInfo;
      handleQueries(s);
    case Delete(s) ->
      var (id, s) = receive(s);
      fun filterByDiseaseID(x) { x.disease_id == id }
      var selectLens = lensselect from diseasesLens by fun(x) { x.disease_id == id };
      var selectLens = lenscheck selectLens;
      lensput selectLens with [];
      handleQueries(s)
  }
}

fun mainPage() {
  var c = fork(handleQueries);
  var (diseases, c) = receive(c);
  var selectedID =
    switch(diseases) {
      case [] -> 0
      case (id, _) :: xs -> id
    };

  var initialModel =
    Selecting(c, (diseases = diseases,
          selectedDisease = selectedID));

  Mvu.runLinear("placeholder", initialModel, view, updt, fun(_) { SubEmpty }, extract);
  Template.template()
}
