open Tables;
open Mvu;
open MvuHTML;
open MvuAttrs;
open MvuEvents;
open Template;
open Utility;

# ADT describing the different types of target family.
typename TargetFamily =
  [| TFGpcr
   | TFIonChannel
   | TFNhr
   | TFCatalyticReceptor
   | TFTransporter
   | TFEnzyme
   | TFOther |];

fun showFamily(tf) {
  switch(tf) {
    case TFGpcr -> "G protein-coupled receptors"
    case TFIonChannel -> "Ion channels"
    case TFNhr -> "Nuclear hormone receptors"
    case TFCatalyticReceptor -> "Catalytic receptors"
    case TFTransporter -> "Transporters"
    case TFEnzyme -> "Enzymes"
    case TFOther -> "Other protein families"
  }
}

typename FamilyID = Int;

typename FamilyNode = (name: String, familyId: FamilyID);

fun mkFamilyNode(name, id) {
  (name=name, familyId=id)
}

typename HierarchicalQueryResult = (isGroup:Bool, name: String, familyId:FamilyID);
fun mkHqr(isGroup, name, id) {
  (isGroup=isGroup, name=name, familyId=id)
}

### MVU Functions

typename Model = Maybe((targetFamily: TargetFamily, itemTree: ItemTree(FamilyNode)));

typename Message = [| ToggleSubtree:String | SetTreeVisibility:Bool |];

fun toggleSubtree(str, tree) {
  switch(tree) {
    case ItemNode(x) -> ItemNode(x)
    case ItemSubtree(name, shown, children) ->
      if (name == str) {
        ItemSubtree(name, not(shown), children)
      } else {
        ItemSubtree(name, shown, map(fun(x) { toggleSubtree(str, x) }, children))
      }
  }
}

fun toggleTree(str, tree) {
  (treeRoots=map(fun(x) { toggleSubtree(str, x) }, tree.treeRoots))
}

fun setSubtreeVisibility(isVisible, tree) {
  switch(tree) {
    case ItemNode(x) -> ItemNode(x)
    case ItemSubtree(name, _, children) ->
        ItemSubtree(name, isVisible,
          map(fun(x) { setSubtreeVisibility(isVisible, x) }, children))
  }
}

fun setTreeVisibility(isVisible, tree) {
  (treeRoots=map(fun(x) { setSubtreeVisibility(isVisible, x) }, tree.treeRoots))
}

fun updt(msg, model) {
  switch(model) {
    case Just(model) ->
      var newModel =
        switch(msg) {
          case ToggleSubtree(str) ->
            (model with itemTree=toggleTree(str, model.itemTree))
          case SetTreeVisibility(visibility) ->
            (model with itemTree=setTreeVisibility(visibility, model.itemTree))
        };
      Just(newModel)
    case Nothing -> Nothing
  }
}

fun view(model) {
  var a0 = MvuAttrs.empty;
  var hempty = MvuHTML.empty;

  fun renderTreeNode(tree) {
    switch(tree) {
      case ItemNode(x) ->
        li(class("liBullet"),
          span(class("bullet"), textNode(" ")) +*
          a(href("/familyDisplay?familyId=" ^^ intToString(x.familyId)),
            textNode(x.name))
        )
      case ItemSubtree(name, shown, children) ->
        var bulletClass = class(if (shown) { "liOpen" } else { "liClosed" });
        var renderedChildren = MvuHTML.concat(map(renderTreeNode, children));
        li(bulletClass,
          span(class("bullet") +@ onClick(fun() { ToggleSubtree(name) }), textNode(" " ^^ name)) +*
          ul(a0, renderedChildren))
    }
  }

  fun renderTree(tree) {
    MvuHTML.concat(map(renderTreeNode, tree.treeRoots))
  }


  var pageBody =
    switch(model) {
      case Just(model) ->
        h4(a0, textNode(showFamily(model.targetFamily))) +*
        div(class("contentboxfullhelp"),
          div(class("textright"),
            p(a0, hempty) +*
            div(style("text-align:right;"),
              button(onClick(fun() { SetTreeVisibility(true) }),
                textNode("Expand all nodes")) +*
              button(onClick(fun() { SetTreeVisibility(false) }),
                textNode("Collapse all nodes"))) +*
              ul(class("mktree"), renderTree(model.itemTree))))
      case Nothing ->
        div(class("contentboxfullhelp"),
          div(class("textright"),
            textNode("Invalid family ID specified.")))
    };


  div(class("container_16"),
    div(class("grid_12"),
    div(class("grid_16 alpha"),
      a(name("top"), hempty) +*
      pageBody)))

  }

### DB Accessors

## PROBLEM: Recursive queries are alas not expressible.
## I wonder whether we can generalise the LINQ to allow
## hierarchical data access, through the use of the `CONNECT BY`
## statement...

# fun populateTree(groupId) {
#   for (g <-- Tables.grouping)
#     where (g.group_id == groupId)
#     orderby (g.display_order)
#     for (f <-- family)
#       where (f.family_id == g.family_id)
#       if (f.type == "grouping") {
#         var children = populateTree(f.family_id);
#         [ItemSubtree(f.name, true, children)]
#       } else {
#         [mkFamilyNode(f.name, f.family_id)]
#       }
# }


fun getFamilyInfo(familyId) {
  for (f <-- Tables.family)
    where (f.family_id == familyId)
    [mkFamilyNode(f.name, f.family_id)]
}

fun getGroupChildren(groupId) {
  for (g <-- Tables.grouping)
    where (g.group_id == groupId)
    orderby (-(g.display_order))
    for (f <-- family)
      where (f.family_id == g.family_id)
      [mkHqr(f.type == "grouping", f.name, f.family_id)]
}

sig resolveHierarchy : (HierarchicalQueryResult) ~> ItemTreeNode(FamilyNode)
fun resolveHierarchy(hqr) {
  if (hqr.isGroup) {
    var resolved_hqrs = map(resolveHierarchy, getGroupChildren(hqr.familyId));
    ItemSubtree(hqr.name, true, resolved_hqrs)
  } else {
    ItemNode(mkFamilyNode(hqr.name, hqr.familyId))
  }
}

fun getToplevelGroup(groupId) {
  var familyInfo = getFamilyInfo(groupId);
  var roots = map(resolveHierarchy, getGroupChildren(groupId));
  (treeRoots = roots)
}

fun getTree(targetFamily) {
  var groupId =
    switch(targetFamily) {
      case TFGpcr -> 694
      case TFIonChannel -> 689
      case TFNhr -> 695
      case TFCatalyticReceptor -> 862
      case TFTransporter -> 691
      case TFEnzyme -> 690
      case TFOther -> 864
    };
  getToplevelGroup(groupId)
}

fun getTargetFamily(typeName) {
  if (typeName == "GPCR") {
    Just(TFGpcr)
  } else if (typeName == "IC") {
    Just(TFIonChannel)
  } else if (typeName == "NHR") {
    Just(TFNhr)
  } else if (typeName == "CATALYTICRECEPTOR") {
    Just(TFCatalyticReceptor)
  } else if (typeName == "TRANSPORTER") {
    Just(TFTransporter)
  } else if (typeName == "ENZYME") {
    Just(TFEnzyme)
  } else if (typeName == "OTHER") {
    Just(TFOther)
  } else {
    Nothing
  }
}

# SJF: It would be lovely to have a maybe monad? Maybe worth hacking one in?
fun getInitialModel() {
  switch(lookup("type", environment())) {
    case Nothing -> Nothing
    case Just(typeName) ->
      switch(getTargetFamily(typeName)) {
        case Nothing -> Nothing
        case Just(tfType) ->
          Just(targetFamily=tfType,
               itemTree=getTree(tfType))
      }
  }
}

fun mainPage() {
  var initialModel = getInitialModel();
  runSimple("vdom_placeholder", initialModel, view, updt);
  template("Target Families") # SJF TODO: Plumbing to get the type
}

