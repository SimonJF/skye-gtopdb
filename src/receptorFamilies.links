open Tables;
open Mvu;
open MvuHTML;
open MvuAttrs;
open MvuEvents;
open Utility;

# ADT describing the different types of target family.
typename TargetFamily =
  [| TFGpcr
   | TFIonChannel
   | TFNhr
   | TFKinase
   | TFCatalyticReceptor
   | TFTransporter
   | TFEnzyme
   | TFOther |];

typename FamilyID = Int;

typename FamilyNode = (name: String, familyId: FamilyID);

fun mkFamilyNode(name, id) {
  (name=name, familyId=id)
}

typename HierarchicalQueryResult(a) = [| Leaf:a | More:a |];

### MVU Functions

typename Model = (targetFamily: TargetFamily, itemTree: ItemTree(FamilyNode));
typename Message = [| ToggleSubtree:String |];

fun toggleSubtree(str, tree) {
  switch(tree) {
    case ItemNode(x) -> ItemNode(x)
    case ItemSubtree(name, shown, children) ->
      if (name == str) {
        ItemSubtree(name, not(shown), children)
      } else {
        ItemSubtree(name, shown, toggleSubtree(str, children))
      }
  }
}

fun updt(msg, model) {
  switch(msg) {
    case ToggleSubtree(str) ->
      (model with itemTree=toggleSubtree(str, model.tree))
  }
}



### DB Accessors

## PROBLEM: Recursive queries are alas not expressible.
## I wonder whether we can generalise the LINQ to allow
## hierarchical data access, through the use of the `CONNECT BY`
## statement...

# fun populateTree(groupId) {
#   for (g <-- Tables.grouping)
#     where (g.group_id == groupId)
#     orderby (g.display_order)
#     for (f <-- family)
#       where (f.family_id == g.family_id)
#       if (f.type == "grouping") {
#         var children = populateTree(f.family_id);
#         [ItemSubtree(f.name, true, children)]
#       } else {
#         [mkFamilyNode(f.name, f.family_id)]
#       }
# }


fun getGroupChildren(familyId) {
  for (g <-- Tables.grouping)
    where (g.group_id == groupId)
    orderby (g.display_order)
    for (f <-- family)
      where (f.family_id == g.family_id)
      if (f.type == "grouping") {
        var children = populateTree(f.family_id);
        [More(mkFamilyNode(f.name, f.family_id))]
      } else {
        [Leaf(mkFamilyNode(f.name, f.family_id))]
      }
}

sig resolveHierarchy : (HierarchicalQueryResult(FamilyNode)) ~> ItemTree(FamilyNode)
fun resolveHierarchy(hqr) {
  switch (hqr) {
    case Leaf(fNode) -> ItemNode(fNode)
    case More(fNode) ->
      # This fNode is itself a grouping. Get the children, and recursively resolve.
      var resolved_hqrs = map(resolveHierarchy, getGroupChildren(fNode.familyId));
      ItemSubtree(fNode.name, true, resolved_hqrs)
  }
}

fun getGpcrs() {
}

fun getIonChannels() {
}

fun getNhrs() {
}

fun getKinases() {
}

fun getCatalyticReceptors() {
}

fun getTransporters() {
}

fun getEnzymes() {
}

fun getOtherProteins() {
}



fun mainPage(targetFamily) {
  print(url);
  page
    <html><h1>Hello, world!</h1></html>
}
