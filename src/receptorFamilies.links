open Tables;
open Mvu;
open MvuHTML;
open MvuAttrs;
open MvuEvents;
open Template;
open Utility;

# ADT describing the different types of target family.
typename TargetFamily =
  [| TFGpcr
   | TFIonChannel
   | TFNhr
   | TFCatalyticReceptor
   | TFTransporter
   | TFEnzyme
   | TFOther |];

fun showFamily(tf) {
  switch(tf) {
    case TFGpcr -> "G protein-coupled receptors"
    case TFIonChannel -> "Ion channels"
    case TFNhr -> "Nuclear hormone receptors"
    case TFCatalyticReceptor -> "Catalytic receptors"
    case TFTransporter -> "Transporters"
    case TFEnzyme -> "Enzymes"
    case TFOther -> "Other protein families"
  }
}

typename FamilyID = Int;

typename FamilyNode = (name: String, familyId: FamilyID);

fun mkFamilyNode(name, id) {
  (name=name, familyId=id)
}

typename HierarchicalQueryResult = (isGroup:Bool, name: String, familyId:FamilyID);
fun mkHqr(isGroup, name, id) {
  (isGroup=isGroup, name=name, familyId=id)
}

### MVU Functions

typename Model = (targetFamily: TargetFamily, itemTree: Maybe(ItemTree(FamilyNode)));
typename Message = [| ToggleSubtree:String | SetTreeVisibility:Bool |];

fun toggleSubtree(str, tree) {
  switch(tree) {
    case ItemNode(x) -> ItemNode(x)
    case ItemSubtree(name, shown, children) ->
      if (name == str) {
        ItemSubtree(name, not(shown), children)
      } else {
# FIXME: This requires a traversal of the whole tree even if the child node is found
        ItemSubtree(name, shown, map(fun(x) { toggleSubtree(str, x) }, children))
      }
  }
}

fun setSubtreeVisibility(isVisible, tree) {
  switch(tree) {
    case ItemNode(x) -> ItemNode(x)
    case ItemSubtree(name, _, children) ->
        ItemSubtree(name, isVisible,
          map(fun(x) { setSubtreeVisibility(isVisible, x) }, children))
  }
}

fun updt(msg, model) {
  switch(model.itemTree) {
    case Just(tree) ->
      switch(msg) {
        case ToggleSubtree(str) ->
          (model with itemTree=Just(toggleSubtree(str, tree)))
        case SetTreeVisibility(visibility) ->
          (model with itemTree=Just(setSubtreeVisibility(visibility, tree)))
      }
    case Nothing -> model
  }
}

fun view(model) {
  var a0 = MvuAttrs.empty;
  var hempty = MvuHTML.empty;

  fun renderTree(tree) {
    switch(tree) {
      case ItemNode(x) ->
        li(class("liBullet"),
          span(class("bullet"), textNode(" ")) +*
          a(href("/viewFamily?familyId=" ^^ intToString(x.familyId)),
            textNode(x.name))
        )
      case ItemSubtree(name, shown, children) ->
        var bulletClass = class(if (shown) { "liOpen" } else { "liClosed" });
        var renderedChildren = MvuHTML.concat(map(renderTree, children));
        li(bulletClass,
          span(class("bullet") +@ onClick(fun() { ToggleSubtree(name) }), textNode(" " ^^ name)) +*
          ul(a0, renderedChildren))
    }
  }

  var tree =
    switch(model.itemTree) {
      case Just(tree) ->
        ul(class("mktree"), renderTree(tree))
      case Nothing -> textNode("Invalid family ID specified.")
    };
  var familyTxt = showFamily(model.targetFamily);

  div(class("container_16"),
    div(class("grid_12"),
    div(class("grid_16 alpha"),
      a(name("top"), hempty) +*
      h4(a0, textNode(familyTxt)) +*
      div(class("contentboxfullhelp"),
        div(class("textright"),
          p(a0, hempty) +*
          div(style("text-align:right;"),
            button(onClick(fun() { SetTreeVisibility(true) }),
              textNode("Expand all nodes")) +*
            button(onClick(fun() { SetTreeVisibility(false) }),
              textNode("Collapse all nodes"))) +*
            tree)))))
}

### DB Accessors

## PROBLEM: Recursive queries are alas not expressible.
## I wonder whether we can generalise the LINQ to allow
## hierarchical data access, through the use of the `CONNECT BY`
## statement...

# fun populateTree(groupId) {
#   for (g <-- Tables.grouping)
#     where (g.group_id == groupId)
#     orderby (g.display_order)
#     for (f <-- family)
#       where (f.family_id == g.family_id)
#       if (f.type == "grouping") {
#         var children = populateTree(f.family_id);
#         [ItemSubtree(f.name, true, children)]
#       } else {
#         [mkFamilyNode(f.name, f.family_id)]
#       }
# }


fun getFamilyInfo(familyId) {
  var res =
    for (f <-- Tables.family)
      where (f.family_id == familyId)
      [mkFamilyNode(f.name, f.family_id)];

  switch(res) {
    case [x] -> Just(x)
    case _ -> Nothing
  }
}

fun getGroupChildren(groupId) {
  for (g <-- Tables.grouping)
    where (g.group_id == groupId)
    orderby (-(g.display_order))
    for (f <-- family)
      where (f.family_id == g.family_id)
      [mkHqr(f.type == "grouping", f.name, f.family_id)]
}

sig resolveHierarchy : (HierarchicalQueryResult) ~> ItemTree(FamilyNode)
fun resolveHierarchy(hqr) {
  if (hqr.isGroup) {
    var resolved_hqrs = map(resolveHierarchy, getGroupChildren(hqr.familyId));
    ItemSubtree(hqr.name, true, resolved_hqrs)
  } else {
    ItemNode(mkFamilyNode(hqr.name, hqr.familyId))
  }
}

fun getToplevelGroup(groupId) {
  var familyInfo = getFamilyInfo(groupId);
  switch(familyInfo) {
    case Just(familyNode) ->
      var children = map(resolveHierarchy, getGroupChildren(groupId));
      Just (ItemSubtree(familyNode.name, true, children))
    case Nothing -> Nothing
  }
}

fun getTree(targetFamily) {
  var groupId =
    switch(targetFamily) {
      case TFGpcr -> 694
      case TFIonChannel -> 689
      case TFNhr -> 695
      case TFCatalyticReceptor -> 862
      case TFTransporter -> 691
      case TFEnzyme -> 690
      case TFOther -> 864
    };
  getToplevelGroup(groupId)
}


fun mainPage(targetFamily) {
  var initialModel = (targetFamily=targetFamily, itemTree=getTree(targetFamily));
  runSimple("vdom_placeholder", initialModel, view, updt);
  template(showFamily(targetFamily))
}
